---
/**
 * @component ShowCoins
 * @description A reusable component that displays the player's coin count with accessible animations
 * and full WCAG AAA compliance. Features include high contrast mode support, reduced motion
 * accommodations, keyboard navigation optimizations, and performance-focused rendering.
 *
 * @example
 * <ShowCoins initialCount={playerCoins} />
 */
import { Icon } from "astro-icon/components";
import { getLangFromUrl, useTranslations } from "@utils/i18n";

interface Props {
  /**
   * The initial coin count to display
   * @default 0
   */
  initialCount?: number;
}

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

const { initialCount = 0 } = Astro.props;
---

<div
  class="coinsCount focus-within:ring-opacity-75 flex max-w-[120px] min-w-[48px] items-center justify-center rounded-lg bg-zinc-800 px-4 py-2 text-zinc-50 shadow-md transition-transform duration-300 will-change-transform focus-within:ring focus-within:ring-sky-300 hover:-translate-y-0.5 hover:shadow-lg focus-visible:outline-none motion-safe:hover:shadow-lg"
  role="status"
  aria-label={t("coins.collected")}
  aria-live="polite"
  data-coins
>
  <div class="flex items-center gap-2 p-0.5">
    <Icon
      class="motion-safe:animate-bounce-subtle h-6 w-6 text-amber-400 drop-shadow motion-reduce:transform-none"
      name="coin"
      width={24}
      height={24}
      aria-hidden="true"
    />
    <span
      id="coins-display"
      class="font-sans leading-tight font-bold tabular-nums"
      aria-atomic="true"
    >
      <span class="sr-only">{t("coins.collected")}:</span>
      <span class="inline-block min-w-[2ch] text-right" data-coin-count>{initialCount}</span>
    </span>
  </div>

  <!-- Screen reader announcer for coin updates -->
  <div id="coins-announcer" class="sr-only" aria-live="assertive" aria-atomic="true"></div>
</div>

<style>
  /**
   * Animation for coin display with proper performance optimizations
   * - Uses GPU acceleration with will-change for better performance
   * - Provides subtle but visible animation for better user experience  
   * - Ensures accessibility compliance with motion-reduce support
   */
  .motion-safe\:animate-bounce-subtle {
    animation: bounce-subtle 1s ease-in-out infinite alternate;
    will-change: transform;
    transform: translateZ(0); /* Force GPU acceleration */
  }

  @keyframes bounce-subtle {
    from {
      transform: translateY(0) scale(1);
    }
    to {
      transform: translateY(-3px) scale(1.05);
    }
  }

  /**
   * Focus styles with enhanced visibility for keyboard users
   * Meeting WCAG AAA contrast requirements
   */
  .coinsCount:focus-visible {
    outline: 3px solid rgb(14, 165, 233); /* sky-500 */
    outline-offset: 3px;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
  }

  /**
   * High Contrast Mode support
   * Ensuring visibility in forced-colors environments like Windows High Contrast Mode
   */
  @media (forced-colors: active) {
    div[data-coins] {
      border: 2px solid CanvasText;
      background-color: Canvas;
      color: CanvasText;
    }

    [data-coins] svg {
      color: LinkText;
      forced-color-adjust: none;
    }

    .coinsCount:focus-visible {
      outline: 3px solid Highlight;
      outline-offset: 3px;
    }
  }

  /**
   * Reduced Motion support
   * Respecting user preferences for reduced motion
   */
  @media (prefers-reduced-motion: reduce) {
    .motion-safe\:animate-bounce-subtle {
      animation: none;
    }

    .coinsCount {
      transition: none !important;
    }

    .coinsCount:hover {
      transform: none !important;
    }
  }

  /**
   * Print styles
   * Optimizing display for printed output
   */
  @media print {
    div[data-coins] {
      border: 1px solid #000;
      box-shadow: none;
      background-color: transparent;
      color: #000;
    }

    [data-coins] svg {
      display: none;
    }

    .coinsCount:hover {
      transform: none !important;
      box-shadow: none !important;
    }
  }

  /**
   * Screen reader only class
   * Visually hidden but available to screen readers
   */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }
</style>

<script>
  /**
   * ShowCoins Client Script
   *
   * Manages the coin count display with accessibility-first approach:
   * - Announces changes to screen readers
   * - Implements animation for count changes
   * - Ensures proper cleanup to prevent memory leaks
   * - Optimizes performance with efficient DOM operations
   */
  class CoinDisplay extends HTMLElement {
    /** The current count value */
    private currentCount: number = 0;

    /** DOM element displaying the count */
    private countElement: HTMLElement | null = null;

    /** Screen reader announcer */
    private announcer: HTMLElement | null = null;

    /** Animation controller if supported */
    private countAnimation: Animation | null = null;

    /** MutationObserver to watch for attribute changes */
    private observer: MutationObserver | null = null;

    constructor() {
      super();
      this.initialize();
    }

    /**
     * Initialize the coin display component
     * Sets up event listeners and prepares for updates
     */
    private initialize(): void {
      // Get required DOM elements
      this.countElement = this.querySelector("[data-coin-count]");
      this.announcer = document.getElementById("coins-announcer");

      // Extract initial count
      if (this.countElement) {
        this.currentCount = parseInt(this.countElement.textContent || "0", 10) || 0;
      }

      // Set up observers for accessibility and updates
      this.setupObservers();

      // Listen for custom coin update events
      document.addEventListener("melody-mind:update-coins", this.handleCoinUpdate.bind(this));
    }

    /**
     * Set up observers to watch for changes to the coin count
     * Ensures we catch both programmatic and direct DOM updates
     */
    private setupObservers(): void {
      if (!this.countElement) {
        return;
      }

      // Create observer for attribute and text changes
      this.observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type === "childList" || mutation.type === "characterData") {
            const newValue = parseInt(this.countElement?.textContent || "0", 10) || 0;
            if (newValue !== this.currentCount) {
              this.updateCoins(newValue);
            }
          }
        }
      });

      // Start observing the count element
      this.observer.observe(this.countElement, {
        characterData: true,
        childList: true,
        subtree: true,
      });
    }

    /**
     * Handle custom coin update events
     *
     * @param {CustomEvent} event - The coin update event
     */
    private handleCoinUpdate(event: Event): void {
      if (event instanceof CustomEvent && event.detail && typeof event.detail.count === "number") {
        this.updateCoins(event.detail.count);
      }
    }

    /**
     * Update the displayed coin count with animation
     *
     * @param {number} newCount - The new coin count to display
     */
    public updateCoins(newCount: number): void {
      if (!this.countElement || newCount === this.currentCount) {
        return;
      }

      const oldCount = this.currentCount;
      this.currentCount = newCount;

      // Update the visible text
      this.countElement.textContent = String(newCount);

      // Announce change to screen readers
      this.announceCountChange(oldCount, newCount);

      // Add animation if Web Animation API is supported
      this.animateCountChange();
    }

    /**
     * Announce count change to screen readers
     *
     * @param {number} oldCount - Previous count
     * @param {number} newCount - New count
     */
    private announceCountChange(oldCount: number, newCount: number): void {
      if (!this.announcer) {
        return;
      }

      const difference = newCount - oldCount;
      let message = "";

      // Create an informative message about what changed
      if (difference > 0) {
        message = `Gained ${difference} coin${difference !== 1 ? "s" : ""}. Total: ${newCount}`;
      } else if (difference < 0) {
        message = `Lost ${Math.abs(difference)} coin${Math.abs(difference) !== 1 ? "s" : ""}. Total: ${newCount}`;
      }

      // Set the message and clear it after being announced
      if (message) {
        this.announcer.textContent = message;
        setTimeout(() => {
          if (this.announcer) {
            this.announcer.textContent = "";
          }
        }, 3000);
      }
    }

    /**
     * Animate the count change with subtle highlighting
     * Only runs if Web Animation API is supported and reduced motion is not preferred
     */
    private animateCountChange(): void {
      if (!this.countElement) {
        return;
      }

      // Check if animation is supported and not using reduced motion
      if (
        "animate" in this.countElement &&
        !window.matchMedia("(prefers-reduced-motion: reduce)").matches
      ) {
        // Cancel any existing animation
        if (this.countAnimation) {
          this.countAnimation.cancel();
        }

        // Create and play a subtle highlight animation
        this.countAnimation = this.countElement.animate(
          [
            {
              backgroundColor: "rgba(251, 191, 36, 0.2)",
              transform: "scale(1.1)",
            }, // amber-400 with opacity
            { backgroundColor: "transparent", transform: "scale(1)" },
          ],
          {
            duration: 600,
            easing: "ease-out",
          }
        );
      }
    }

    /**
     * Clean up event listeners and observers when element is removed
     * Prevents memory leaks and ensures proper teardown
     */
    disconnectedCallback(): void {
      // Clean up the observer
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }

      // Cancel any ongoing animation
      if (this.countAnimation) {
        this.countAnimation.cancel();
        this.countAnimation = null;
      }

      // Remove event listeners
      document.removeEventListener("melody-mind:update-coins", this.handleCoinUpdate.bind(this));
    }
  }

  // Check if component is already registered to avoid errors
  if (!customElements.get("coin-display")) {
    customElements.define("coin-display", CoinDisplay);
  }

  // Convert existing coin displays to custom elements
  document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll("[data-coins]").forEach((element) => {
      if (!(element instanceof CoinDisplay) && element instanceof HTMLElement) {
        // Create and replace with custom element
        const coinDisplay = document.createElement("coin-display");

        // Copy attributes
        Array.from(element.attributes).forEach((attr) => {
          coinDisplay.setAttribute(attr.name, attr.value);
        });

        // Copy inner content
        coinDisplay.innerHTML = element.innerHTML;

        // Replace the original element
        element.parentNode?.replaceChild(coinDisplay, element);
      }
    });
  });

  /**
   * Global helper to update coin counts from anywhere in the application
   *
   * @param {number} count - The new coin count
   */
  (window as any).updateCoinCount = function (count: number): void {
    document.dispatchEvent(
      new CustomEvent("melody-mind:update-coins", {
        detail: { count },
      })
    );
  };
</script>
