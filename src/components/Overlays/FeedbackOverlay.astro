---
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import { Icon } from "astro-icon/components";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
---

<div
  id="overlay"
  class="overlay hidden fixed inset-0 z-50 flex items-center justify-center p-6 bg-black/90 backdrop-blur-md"
  role="dialog"
  aria-labelledby="overlay-title"
  aria-modal="true"
  aria-live="polite"
>
  <div
    class="overlayContent w-full max-w-[768px] max-h-[90vh] p-6 md:p-8 bg-zinc-800 border border-zinc-700 rounded-xl shadow-xl overflow-y-auto overscroll-contain scrollbar-gutter-stable"
    role="document"
    tabindex="-1"
  >
    <h2
      id="overlay-title"
      class="title text-2xl font-bold text-zinc-50 text-center mb-6"
    >
      {t("game.feedback.resolution")}
    </h2>

    <p
      id="feedback"
      class="feedback my-6 p-4 rounded-lg text-lg font-semibold text-center"
      role="status"
      aria-live="assertive"
    >
    </p>

    <div
      class="mediaSection flex flex-col items-center gap-4 mb-6"
      aria-label={t("game.feedback.media.section")}
    >
      <img
        id="overlay-cover"
        class="albumCover aspect-square w-full max-w-[250px] h-auto rounded-lg object-cover shadow-md"
        src=""
        alt=""
        loading="eager"
        decoding="async"
      />
      <audio
        id="audio-preview"
        class="audioPlayer w-full max-w-[250px] mt-2"
        controls
        preload="metadata"
        aria-label={t("game.feedback.audio.preview")}
      >
        <source id="audio-preview-source" src="" type="audio/mpeg" />
        <source id="audio-preview-source-ogg" src="" type="audio/ogg" />
        <track kind="captions" src="" label={t("game.feedback.subtitles")} />
        <p>{t("game.feedback.audio.unsupported")}</p>
      </audio>
    </div>

    <div
      class="musicLinks flex flex-wrap justify-center gap-4 my-6"
      role="group"
      aria-label={t("game.feedback.streaming.links")}
    >
      <a
        id="spotify-link"
        class="musicButton inline-flex items-center justify-center min-w-[48px] min-h-[48px] p-3 bg-sky-500 hover:bg-sky-400 text-zinc-900 rounded-lg transition-colors sm:p-2"
        href="#"
        target="_blank"
        rel="noopener noreferrer"
        aria-label={t("game.feedback.listen.spotify")}
      >
        <Icon name="spotify" width={36} height={36} aria-hidden="true" />
        <span class="sr-only">Spotify</span>
      </a>
      <a
        id="deezer-link"
        class="musicButton inline-flex items-center justify-center min-w-[48px] min-h-[48px] p-3 bg-sky-500 hover:bg-sky-400 text-zinc-900 rounded-lg transition-colors sm:p-2"
        href="#"
        target="_blank"
        rel="noopener noreferrer"
        aria-label={t("game.feedback.listen.deezer")}
      >
        <Icon name="deezer" width={36} height={36} aria-hidden="true" />
        <span class="sr-only">Deezer</span>
      </a>
      <a
        id="apple-link"
        class="musicButton inline-flex items-center justify-center min-w-[48px] min-h-[48px] p-3 bg-sky-500 hover:bg-sky-400 text-zinc-900 rounded-lg transition-colors sm:p-2"
        href="#"
        target="_blank"
        rel="noopener noreferrer"
        aria-label={t("game.feedback.listen.apple")}
      >
        <Icon name="apple-music" width={36} height={36} aria-hidden="true" />
        <span class="sr-only">Apple Music</span>
      </a>
    </div>

    <div class="infoSection my-6 text-center space-y-2" role="contentinfo">
      <p id="overlay-artist" class="artist text-xl font-bold text-sky-400"></p>
      <p id="overlay-album" class="album text-zinc-50 mt-2"></p>
      <p id="overlay-year" class="year text-zinc-300 mt-2"></p>
      <p id="overlay-funfact" class="funFact text-zinc-300 mt-2"></p>
    </div>

    <div class="buttonWrapper flex justify-center mt-6">
      <button
        id="next-round-button"
        class="nextButton min-w-[48px] min-h-[48px] py-3 px-6 bg-sky-500 hover:bg-sky-400 text-zinc-900 font-semibold rounded-lg transition-colors"
        aria-label={t("game.feedback.next.round")}
      >
        {t("game.feedback.next.round")}
      </button>
    </div>
  </div>
</div>

<style>
  /* Kompatibilit채tsklassen f체r JS-Funktionen */
  .overlay.hidden {
    pointer-events: none;
    visibility: hidden;
    opacity: 0;
  }

  .feedback.correct {
    color: #fff;
    background-color: rgb(5 150 105); /* emerald-600 */
  }

  .feedback.incorrect {
    color: #fff;
    background-color: rgb(220 38 38); /* red-600 */
  }

  .overlayContent:focus {
    outline: 2px solid rgb(56 189 248); /* sky-300 */
    outline-offset: 2px;
  }

  /* Zus채tzliche Stile f체r Barrierefreiheit */
  @media (forced-colors: active) {
    .overlayContent {
      border: 2px solid CanvasText;
    }

    .musicButton,
    .nextButton {
      border: 2px solid ButtonText;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .overlay {
      transition: none;
    }
  }
</style>

<script>
  /**
   * FeedbackOverlay Component Script
   *
   * Manages the feedback overlay functionality including:
   * - Focus management
   * - Keyboard navigation/accessibility
   * - Album cover display and error handling
   * - Audio player lifecycle
   */

  /**
   * Initialize the FeedbackOverlay component
   */
  function initializeFeedbackOverlay() {
    const overlay = document.getElementById("overlay") as HTMLElement;
    const overlayContent = overlay?.querySelector(
      ".overlayContent",
    ) as HTMLElement;

    if (!overlay || !overlayContent) {
      console.debug("FeedbackOverlay: Required elements not found");
      return;
    }

    // Set up observers and event listeners
    setupOverlayVisibilityObserver(overlay, overlayContent);
    setupKeyboardNavigation();
    const coverObserver = handleAlbumCoverDisplay(overlay);
    setupCleanupHandlers(coverObserver);
  }

  /**
   * Sets up an observer to monitor overlay visibility changes
   * Manages focus and scroll position when overlay becomes visible
   *
   * @param {HTMLElement} overlay - The overlay container element
   * @param {HTMLElement} overlayContent - The content container inside the overlay
   * @returns {MutationObserver} The configured observer
   */
  function setupOverlayVisibilityObserver(
    overlay: HTMLElement,
    overlayContent: HTMLElement,
  ): MutationObserver {
    const observer = new MutationObserver(() => {
      if (!overlay.classList.contains("hidden")) {
        // Reset scroll position and focus the content when overlay becomes visible
        overlayContent.scrollTop = 0;
        overlayContent.focus();
      }
    });

    // Watch for class changes on the overlay element
    observer.observe(overlay, {
      attributes: true,
      attributeFilter: ["class"],
    });

    return observer;
  }

  /**
   * Sets up keyboard navigation handlers for the overlay
   * Implements a focus trap and escape key handling
   */
  function setupKeyboardNavigation() {
    const focusableSelector =
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

    document.addEventListener("keydown", (event) => {
      const overlay = document.getElementById("overlay");
      // Only handle keyboard events when overlay is visible
      if (!overlay || overlay.classList.contains("hidden")) return;

      const content = overlay.querySelector(".overlayContent");
      const focusableElements = Array.from(
        content?.querySelectorAll(focusableSelector) || [],
      ) as HTMLElement[];

      // No focusable elements, nothing to do
      if (focusableElements.length === 0) return;

      const firstFocusable = focusableElements[0];
      const lastFocusable = focusableElements[focusableElements.length - 1];

      switch (event.key) {
        case "Escape":
          // Close the overlay when Escape is pressed
          document.getElementById("next-round-button")?.click();
          break;

        case "Tab":
          // Create a focus trap within the overlay
          if (event.shiftKey && document.activeElement === firstFocusable) {
            // Shift+Tab on first element goes to last element
            event.preventDefault();
            lastFocusable.focus();
          } else if (
            !event.shiftKey &&
            document.activeElement === lastFocusable
          ) {
            // Tab on last element goes to first element
            event.preventDefault();
            firstFocusable.focus();
          }
          break;
      }
    });
  }

  /**
   * Handles album cover display and fixes issues with cover visibility
   *
   * @param {HTMLElement} overlay - The overlay container element
   * @returns {MutationObserver} The observer handling album cover display
   */
  function handleAlbumCoverDisplay(overlay: HTMLElement): MutationObserver {
    const albumCover = document.getElementById(
      "overlay-cover",
    ) as HTMLImageElement;

    if (!albumCover) {
      console.debug("FeedbackOverlay: Album cover element not found");
      return new MutationObserver(() => {});
    }

    // Ensure the album cover is not hidden by removing any hidden class
    albumCover.classList.remove("hidden");

    // Set up error handling for the album cover image
    setupAlbumCoverErrorHandling(albumCover);

    // Define a function to check and update album cover when overlay becomes visible
    const checkAlbumCover = () => {
      if (!overlay.classList.contains("hidden")) {
        // Ensure the album cover is visible
        albumCover.style.display = "";
        albumCover.classList.remove("hidden");

        // If src is empty or points to the current page, try to get it from overlay data
        if (!albumCover.src || albumCover.src === window.location.href) {
          const albumData = overlay.getAttribute("data-album-cover");
          if (albumData) {
            albumCover.src = albumData;
          }
        }
      }
    };

    // Create an observer to watch for overlay visibility changes
    const coverObserver = new MutationObserver(checkAlbumCover);
    coverObserver.observe(overlay, {
      attributes: true,
      attributeFilter: ["class"],
    });

    // Initial check in case the overlay is already visible
    checkAlbumCover();

    return coverObserver;
  }

  /**
   * Sets up error handling for the album cover image
   *
   * @param {HTMLImageElement} albumCover - The album cover image element
   */
  function setupAlbumCoverErrorHandling(albumCover: HTMLImageElement): void {
    albumCover.onerror = () => {
      console.debug("FeedbackOverlay: Error loading album cover image");

      // Set a fallback image or message when loading fails
      albumCover.src = "/images/default-album-cover.jpg";
      albumCover.alt = "Album cover not available";

      // Ensure the image is still visible despite the error
      albumCover.style.display = "";
      albumCover.classList.remove("hidden");
    };
  }

  /**
   * Sets up cleanup handlers for when the component is unmounted
   *
   * @param {MutationObserver} coverObserver - The album cover observer to disconnect
   */
  function setupCleanupHandlers(coverObserver: MutationObserver): void {
    // Get references to elements and observers that need cleanup
    const audioPlayer = document.getElementById(
      "audio-preview",
    ) as HTMLAudioElement;
    const mainObserver = document.querySelector("#overlay")
      ? new MutationObserver(() => {}) // Placeholder if original observer not available
      : null;

    // Handle cleanup before page navigation
    document.addEventListener("astro:before-swap", () => {
      // Disconnect observers
      mainObserver?.disconnect();
      coverObserver?.disconnect();

      // Stop audio playback and clear sources
      if (audioPlayer) {
        audioPlayer.pause();
        audioPlayer.src = "";
      }
    });
  }

  // Initialize the overlay when the DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeFeedbackOverlay);
  } else {
    initializeFeedbackOverlay();
  }
</script>
