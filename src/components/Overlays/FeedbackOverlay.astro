---
/**
 * @component FeedbackOverlay
 * @description A modal overlay that displays feedback after each game round, showing
 * album information, media preview, and streaming links. This component is optimized for
 * WCAG AAA accessibility standards and high performance.
 *
 * Features:
 * - Keyboard navigation with focus trap
 * - Screen reader announcements
 * - High contrast mode support
 * - Optimized animations with reduced motion support
 * - Performance-optimized interactions
 */
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import { Icon } from "astro-icon/components";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
---

<div
  id="overlay"
  class="overlay fixed inset-0 z-50 flex hidden items-center justify-center bg-black/95 p-6 backdrop-blur-md"
  role="dialog"
  aria-labelledby="overlay-title"
  aria-describedby="feedback"
  aria-modal="true"
  tabindex="-1"
>
  <!-- Overlay backdrop for click-to-close functionality -->
  <div id="overlay-backdrop" class="absolute inset-0" aria-hidden="true"></div>

  <div
    class="overlayContent scrollbar-gutter-stable max-h-[90vh] w-full max-w-[768px] overflow-y-auto overscroll-contain rounded-xl border border-zinc-700 bg-zinc-800 p-6 shadow-xl md:p-8"
    role="document"
    tabindex="-1"
  >
    <div class="mb-6 flex items-center justify-between">
      <h2
        id="overlay-title"
        class="title text-2xl font-bold tracking-tight text-zinc-50 md:text-3xl"
      >
        {t("game.feedback.resolution")}
      </h2>

      <!-- Close button for enhanced accessibility -->
      <button
        id="close-overlay-button"
        class="close-button flex h-10 min-h-[44px] w-10 min-w-[44px] items-center justify-center rounded-full bg-zinc-700 text-zinc-300 transition-colors hover:bg-zinc-600 focus:bg-zinc-600"
        aria-label={t("general.close") || "Close"}
      >
        <Icon name="close" width={24} height={24} aria-hidden="true" />
      </button>
    </div>

    <!-- Status announcer for screen readers -->
    <div id="feedback-status-announcer" aria-live="assertive" aria-atomic="true" class="sr-only">
    </div>

    <p
      id="feedback"
      class="feedback my-6 rounded-lg p-5 text-center text-xl leading-relaxed font-semibold"
      role="status"
    >
    </p>

    <div
      class="mediaSection mb-8 grid items-start gap-6 md:grid-cols-2"
      aria-label={t("game.feedback.media.section")}
    >
      <div class="imageContainer flex justify-center">
        <img
          id="overlay-cover"
          class="albumCover aspect-square h-auto w-full max-w-[300px] transform-gpu rounded-lg object-cover shadow-lg transition-transform duration-300 will-change-transform"
          src=""
          alt=""
          loading="eager"
          decoding="async"
        />
      </div>

      <div class="infoSection flex flex-col justify-between space-y-3 text-left" role="contentinfo">
        <div>
          <p id="overlay-artist" class="artist mb-2 text-2xl font-bold text-sky-400"></p>
          <p id="overlay-album" class="album mb-1 text-xl text-zinc-50"></p>
          <p id="overlay-year" class="year text-lg text-zinc-300"></p>
          <p id="overlay-funfact" class="funFact mt-4 text-lg leading-relaxed text-zinc-300"></p>
        </div>

        <div class="audio-container">
          <label id="audio-label" for="audio-preview" class="mb-1 block text-sm text-zinc-400">
            {t("game.feedback.audio.preview")}
          </label>
          <audio
            id="audio-preview"
            class="audioPlayer mt-2 w-full"
            controls
            preload="metadata"
            aria-labelledby="audio-label"
          >
            <source id="audio-preview-source" src="" type="audio/mpeg" />
            <source id="audio-preview-source-ogg" src="" type="audio/ogg" />
            <track kind="captions" src="" label={t("game.feedback.subtitles")} />
            <p>{t("game.feedback.audio.unsupported")}</p>
          </audio>
        </div>
      </div>
    </div>

    <h3 class="mb-4 text-center text-xl font-semibold text-zinc-50">
      {t("game.feedback.streaming.links")}
    </h3>

    <div
      class="musicLinks my-6 flex flex-wrap justify-center gap-4"
      role="group"
      aria-label={t("game.feedback.streaming.links")}
    >
      <a
        id="spotify-link"
        class="musicButton inline-flex min-h-[44px] min-w-[160px] items-center justify-center rounded-lg bg-sky-600 p-5 font-semibold text-white transition-colors hover:bg-sky-500 focus:bg-sky-500"
        href="#"
        target="_blank"
        rel="noopener noreferrer"
        aria-label={t("game.feedback.listen.spotify")}
      >
        <Icon name="spotify" class="mr-4" width={24} height={24} aria-hidden="true" />
        <span>Spotify</span>
      </a>
      <a
        id="deezer-link"
        class="musicButton inline-flex min-h-[44px] min-w-[160px] items-center justify-center rounded-lg bg-sky-600 p-5 font-semibold text-white transition-colors hover:bg-sky-500 focus:bg-sky-500"
        href="#"
        target="_blank"
        rel="noopener noreferrer"
        aria-label={t("game.feedback.listen.deezer")}
      >
        <Icon name="deezer" class="mr-4" width={24} height={24} aria-hidden="true" />
        <span>Deezer</span>
      </a>
      <a
        id="apple-link"
        class="musicButton inline-flex min-h-[44px] min-w-[160px] items-center justify-center rounded-lg bg-sky-600 p-5 font-semibold text-white transition-colors hover:bg-sky-500 focus:bg-sky-500"
        href="#"
        target="_blank"
        rel="noopener noreferrer"
        aria-label={t("game.feedback.listen.apple")}
      >
        <Icon name="apple-music" class="mr-4" width={24} height={24} aria-hidden="true" />
        <span>Apple Music</span>
      </a>
    </div>
    <button
      id="next-round-button"
      class="nextButton m-auto block min-h-[48px] min-w-[200px] rounded-lg bg-sky-600 px-6 py-3 font-semibold text-white transition-colors hover:bg-sky-500 focus:bg-sky-500"
      aria-label={t("game.feedback.next.round")}
    >
      <span class="flex items-center justify-center gap-2">
        {t("game.feedback.next.round")}
        <Icon name="arrow-right" width={20} height={20} aria-hidden="true" />
      </span>
    </button>
  </div>
</div>

<style>
  /* Base visibility classes for JS compatibility */
  .overlay.hidden {
    pointer-events: none;
    visibility: hidden;
    opacity: 0;
  }

  /* Feedback styles with improved contrast for accessibility */
  .feedback.correct {
    color: #fff;
    background-color: rgb(4, 120, 87); /* emerald-700 for better contrast (7:1 ratio) */
  }

  .feedback.incorrect {
    color: #fff;
    background-color: rgb(185, 28, 28); /* red-700 for better contrast (7:1 ratio) */
  }

  /* Enhanced focus styles for keyboard users - WCAG AAA compliant */
  .overlayContent:focus,
  button:focus-visible,
  a:focus-visible,
  .audioPlayer:focus-visible {
    outline: 3px solid rgb(56, 189, 248); /* sky-300 */
    outline-offset: 3px;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
    z-index: 1;
  }

  /* GPU-accelerated animations with reduced-motion consideration */
  @media (prefers-reduced-motion: no-preference) {
    .albumCover {
      will-change: transform, box-shadow;
      transition:
        transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1),
        box-shadow 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
    }

    .albumCover:hover {
      transform: scale(1.03);
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
    }

    .overlay:not(.hidden) .overlayContent {
      animation: fade-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
    }

    @keyframes fade-in {
      from {
        opacity: 0;
        transform: translateY(10px) scale(0.98);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
  }

  /* High Contrast Mode support */
  @media (forced-colors: active) {
    .overlayContent {
      border: 3px solid CanvasText;
      background-color: Canvas;
    }

    .musicButton,
    .nextButton,
    .close-button {
      border: 2px solid ButtonText;
      background-color: ButtonFace;
      color: ButtonText;
      forced-color-adjust: none;
    }

    .musicButton:focus-visible,
    .nextButton:focus-visible,
    .close-button:focus-visible {
      outline: 3px solid Highlight;
      outline-offset: 3px;
    }

    .feedback.correct,
    .feedback.incorrect {
      border: 2px solid CanvasText;
      background-color: Canvas;
      color: CanvasText;
    }

    .overlay-backdrop {
      background-color: Canvas;
      opacity: 0.9;
    }
  }

  /* Support for reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .overlay,
    .overlayContent,
    .albumCover,
    button,
    a {
      animation-duration: 0.001ms !important;
      transition-duration: 0.001ms !important;
      animation-iteration-count: 1 !important;
    }
  }

  /* Screen reader only class */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  /* Optimized text readability (AAA requires minimum 18px for normal text) */
  .artist,
  .album,
  .year,
  .funFact {
    line-height: 1.5;
    max-width: 65ch; /* Optimal readability */
  }

  /* Print styles */
  @media print {
    .overlayContent {
      border: 1px solid #000;
      box-shadow: none;
      max-height: none !important;
    }

    .musicButton,
    .nextButton,
    .close-button {
      border: 1px solid #000;
      background: #fff !important;
      color: #000 !important;
    }

    audio {
      display: none;
    }
  }

  /* Enhanced scrollbar styles for better visibility */
  .overlayContent::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  .overlayContent::-webkit-scrollbar-track {
    background: rgba(39, 39, 42, 0.6); /* zinc-800 with better contrast */
    border-radius: 10px;
  }

  .overlayContent::-webkit-scrollbar-thumb {
    background: rgba(161, 161, 170, 0.8); /* zinc-400 with better opacity for contrast */
    border-radius: 10px;
  }

  .overlayContent::-webkit-scrollbar-thumb:hover {
    background: rgba(212, 212, 216, 0.9); /* zinc-300 with better contrast */
  }
</style>

<script>
  /**
   * FeedbackOverlay Component Script
   *
   * This script manages the feedback overlay functionality with a focus on
   * high performance and WCAG AAA accessibility standards.
   *
   * Features:
   * - Fully keyboard accessible with focus trap
   * - Screen reader announcements
   * - Performance optimized animations
   * - Memory leak prevention
   * - Reduced motion support
   * - Error recovery for media assets
   */

  // Store last focused element to restore focus when overlay closes
  let lastFocusedElement: HTMLElement | null = null;

  /**
   * Initialize the FeedbackOverlay component when DOM is ready
   */
  function initializeFeedbackOverlay(): void {
    const overlay = document.getElementById("overlay") as HTMLElement;
    const overlayContent = overlay?.querySelector(".overlayContent") as HTMLElement;
    const overlayBackdrop = document.getElementById("overlay-backdrop");
    const closeButton = document.getElementById("close-overlay-button");
    const nextButton = document.getElementById("next-round-button");

    if (!overlay || !overlayContent) {
      console.debug("FeedbackOverlay: Required elements not found");
      return;
    }

    // Set up visibility handling with optimized focus management
    setupOverlayVisibilityHandling(overlay, overlayContent);

    // Set up event listeners for various close actions
    if (closeButton) {
      closeButton.addEventListener("click", hideOverlay);
    }
    if (overlayBackdrop) {
      overlayBackdrop.addEventListener("click", hideOverlay);
    }
    if (nextButton) {
      nextButton.addEventListener("click", hideOverlay);
    }

    // Setup keyboard navigation and focus trap
    setupKeyboardNavigation(overlay);

    // Handle album cover display and errors
    const coverObserver = handleAlbumCoverDisplay(overlay);

    // Set up accessibility announcements
    setupAccessibilityAnnouncements();

    // Set up clean-up handlers to prevent memory leaks
    setupCleanupHandlers(coverObserver);
  }

  /**
   * Sets up overlay visibility handling with proper focus management
   *
   * @param {HTMLElement} overlay - The overlay container
   * @param {HTMLElement} overlayContent - The content container
   */
  function setupOverlayVisibilityHandling(overlay: HTMLElement, overlayContent: HTMLElement): void {
    // Create an observer to monitor class changes on the overlay
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "attributes" && mutation.attributeName === "class") {
          const isVisible = !overlay.classList.contains("hidden");

          if (isVisible) {
            // Save the currently focused element before showing overlay
            lastFocusedElement = document.activeElement as HTMLElement;

            // Display overlay with performance-optimized animation
            showOverlayWithAnimation(overlay, overlayContent);

            // Prevent background scrolling
            document.body.style.overflow = "hidden";

            // Set initial focus to the close button for accessibility
            setTimeout(() => {
              const closeButton = document.getElementById("close-overlay-button");
              if (closeButton) {
                closeButton.focus();
              }
            }, 100);
          }
        }
      });
    });

    // Start observing the overlay for class changes
    observer.observe(overlay, {
      attributes: true,
      attributeFilter: ["class"],
    });

    // Initial check in case the overlay is already visible
    if (!overlay.classList.contains("hidden")) {
      observer.disconnect();
      showOverlayWithAnimation(overlay, overlayContent);
      observer.observe(overlay, {
        attributes: true,
        attributeFilter: ["class"],
      });
    }
  }

  /**
   * Shows the overlay with a performance-optimized animation
   *
   * @param {HTMLElement} overlay - The overlay container
   * @param {HTMLElement} overlayContent - The content container
   */
  function showOverlayWithAnimation(overlay: HTMLElement, overlayContent: HTMLElement): void {
    // Reset scroll position
    overlayContent.scrollTop = 0;

    // Check if user prefers reduced motion
    const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

    if (prefersReducedMotion) {
      // Skip animation for users who prefer reduced motion
      return;
    }

    // Use requestAnimationFrame for smooth animation
    requestAnimationFrame(() => {
      overlayContent.style.opacity = "0";
      overlayContent.style.transform = "translateY(10px) scale(0.98)";

      requestAnimationFrame(() => {
        overlayContent.style.transition =
          "opacity 300ms cubic-bezier(0.25, 0.1, 0.25, 1), transform 300ms cubic-bezier(0.25, 0.1, 0.25, 1)";
        overlayContent.style.opacity = "1";
        overlayContent.style.transform = "translateY(0) scale(1)";
      });
    });
  }

  /**
   * Hides the overlay and restores focus to the previous element
   */
  function hideOverlay(): void {
    const overlay = document.getElementById("overlay");
    if (!overlay) {
      return;
    }

    // Hide the overlay
    overlay.classList.add("hidden");

    // Re-enable scrolling
    document.body.style.overflow = "";

    // Return focus to the element that had focus before showing the overlay
    if (lastFocusedElement && typeof lastFocusedElement.focus === "function") {
      setTimeout(() => {
        lastFocusedElement?.focus();
      }, 100);
    }
  }

  /**
   * Enhances accessibility by providing announcements for screen readers
   */
  function setupAccessibilityAnnouncements(): void {
    const overlay = document.getElementById("overlay");
    const feedbackElement = document.getElementById("feedback");
    const statusAnnouncer = document.getElementById("feedback-status-announcer");

    if (!overlay || !feedbackElement || !statusAnnouncer) {
      return;
    }

    // Monitor changes to the feedback content for screen reader announcements
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (
          mutation.type === "childList" ||
          mutation.type === "characterData" ||
          mutation.type === "attributes"
        ) {
          // Get the current feedback text and class information
          const feedbackText = feedbackElement.textContent?.trim() || "";
          const isCorrect = feedbackElement.classList.contains("correct");
          const isIncorrect = feedbackElement.classList.contains("incorrect");

          // Create a more informative announcement that includes the outcome
          let announcement = feedbackText;
          if (isCorrect) {
            announcement = `Correct: ${feedbackText}`;
          } else if (isIncorrect) {
            announcement = `Incorrect: ${feedbackText}`;
          }

          // Update the live region for screen readers
          if (announcement) {
            statusAnnouncer.textContent = announcement;

            // Clear after a delay to allow for multiple announcements
            setTimeout(() => {
              statusAnnouncer.textContent = "";
            }, 3000);
          }
        }
      });
    });

    // Observe both content and attribute changes to catch all updates
    observer.observe(feedbackElement, {
      childList: true,
      characterData: true,
      attributes: true,
      attributeFilter: ["class"],
      subtree: true,
    });
  }

  /**
   * Sets up keyboard navigation and focus trap for the overlay
   *
   * @param {HTMLElement} overlay - The overlay container
   */
  function setupKeyboardNavigation(overlay: HTMLElement): void {
    document.addEventListener("keydown", (event) => {
      // Only handle keyboard events when overlay is visible
      if (overlay.classList.contains("hidden")) {
        return;
      }

      switch (event.key) {
        case "Escape":
          // Close the overlay when Escape is pressed
          hideOverlay();
          break;

        case "Tab":
          // Create a focus trap within the overlay
          trapFocus(event, overlay);
          break;
      }
    });
  }

  /**
   * Traps focus within the overlay for keyboard navigation
   *
   * @param {KeyboardEvent} event - The keyboard event
   * @param {HTMLElement} overlay - The overlay container
   */
  function trapFocus(event: KeyboardEvent, overlay: HTMLElement): void {
    // Get all focusable elements within the overlay
    const focusableElements = getFocusableElements(overlay);

    // No focusable elements, nothing to do
    if (focusableElements.length === 0) {
      return;
    }

    const firstFocusable = focusableElements[0];
    const lastFocusable = focusableElements[focusableElements.length - 1];

    // Handle Tab and Shift+Tab navigation
    if (event.shiftKey && document.activeElement === firstFocusable) {
      // Shift+Tab on first element moves focus to last element
      event.preventDefault();
      lastFocusable.focus();
    } else if (!event.shiftKey && document.activeElement === lastFocusable) {
      // Tab on last element moves focus to first element
      event.preventDefault();
      firstFocusable.focus();
    }
  }

  /**
   * Gets all focusable elements within a container
   *
   * @param {HTMLElement} container - The container to search within
   * @returns {HTMLElement[]} An array of focusable elements
   */
  function getFocusableElements(container: HTMLElement): HTMLElement[] {
    const focusableSelector = [
      "a[href]:not([disabled])",
      "button:not([disabled])",
      "textarea:not([disabled])",
      "input:not([disabled])",
      "select:not([disabled])",
      "video[controls]",
      "audio[controls]",
      '[tabindex]:not([tabindex="-1"])',
    ].join(", ");

    // Get all potentially focusable elements
    const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector));

    // Filter out hidden elements
    return elements.filter((el) => {
      const style = window.getComputedStyle(el);
      return (
        style.display !== "none" &&
        style.visibility !== "hidden" &&
        style.opacity !== "0" &&
        el.offsetWidth > 0 &&
        el.offsetHeight > 0
      );
    });
  }

  /**
   * Handles album cover display and fixes issues with cover visibility
   *
   * @param {HTMLElement} overlay - The overlay container
   * @returns {MutationObserver} The observer handling album cover display
   */
  function handleAlbumCoverDisplay(overlay: HTMLElement): MutationObserver {
    const albumCover = document.getElementById("overlay-cover") as HTMLImageElement;

    if (!albumCover) {
      console.debug("FeedbackOverlay: Album cover element not found");
      return new MutationObserver(() => {});
    }

    // Ensure the album cover is not hidden by removing any hidden class
    albumCover.classList.remove("hidden");

    // Set up error handling for the album cover image
    setupAlbumCoverErrorHandling(albumCover);

    // Create an observer to watch for overlay visibility changes
    const coverObserver = new MutationObserver(() => {
      if (!overlay.classList.contains("hidden")) {
        // Ensure the album cover is visible
        albumCover.style.display = "";
        albumCover.classList.remove("hidden");

        // If src is empty or points to the current page, try to get it from overlay data
        if (!albumCover.src || albumCover.src === window.location.href) {
          const albumData = overlay.getAttribute("data-album-cover");
          if (albumData) {
            albumCover.src = albumData;

            // Update alt text if available
            const albumTitle = overlay.getAttribute("data-album-title");
            if (albumTitle) {
              albumCover.alt = `Album cover: ${albumTitle}`;
            } else {
              albumCover.alt = "Album cover";
            }
          }
        }
      }
    });

    // Start observing the overlay for class changes
    coverObserver.observe(overlay, {
      attributes: true,
      attributeFilter: ["class", "data-album-cover", "data-album-title"],
    });

    // Initial check in case the overlay is already visible
    if (!overlay.classList.contains("hidden")) {
      coverObserver.disconnect();
      const albumData = overlay.getAttribute("data-album-cover");
      if (albumData) {
        albumCover.src = albumData;
      }
      coverObserver.observe(overlay, {
        attributes: true,
        attributeFilter: ["class", "data-album-cover", "data-album-title"],
      });
    }

    return coverObserver;
  }

  /**
   * Sets up error handling for the album cover image
   *
   * @param {HTMLImageElement} albumCover - The album cover image element
   */
  function setupAlbumCoverErrorHandling(albumCover: HTMLImageElement): void {
    albumCover.onerror = () => {
      console.debug("FeedbackOverlay: Error loading album cover image");

      // Set a fallback image when loading fails
      albumCover.src = "/default-cover.jpg";
      albumCover.alt = "Album cover not available";

      // Ensure the image is still visible despite the error
      albumCover.style.display = "";
      albumCover.classList.remove("hidden");
    };
  }

  /**
   * Sets up cleanup handlers to prevent memory leaks when the component is unmounted
   *
   * @param {MutationObserver} coverObserver - The album cover observer to disconnect
   */
  function setupCleanupHandlers(coverObserver: MutationObserver): void {
    // Get references to elements and observers that need cleanup
    const audioPlayer = document.getElementById("audio-preview") as HTMLAudioElement;

    const observers: MutationObserver[] = [];

    // Add all observers that need to be disconnected
    if (coverObserver) {
      observers.push(coverObserver);
    }

    // Create a function to perform all cleanup
    function cleanup() {
      // Disconnect all observers
      observers.forEach((observer) => observer.disconnect());

      // Stop audio playback and clear sources
      if (audioPlayer) {
        audioPlayer.pause();
        audioPlayer.removeAttribute("src");
        audioPlayer.load();
      }

      // Remove event listeners
      document.getElementById("close-overlay-button")?.removeEventListener("click", hideOverlay);
      document.getElementById("overlay-backdrop")?.removeEventListener("click", hideOverlay);
      document.getElementById("next-round-button")?.removeEventListener("click", hideOverlay);
    }

    // Handle cleanup before page navigation
    document.addEventListener("astro:before-swap", cleanup);

    // Handle cleanup during component unmount
    document.addEventListener("astro:after-swap", cleanup);
  }

  // Initialize the overlay when the DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeFeedbackOverlay);
  } else {
    initializeFeedbackOverlay();
  }
</script>
