---
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import { Icon } from "astro-icon/components";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
---

<div
  id="overlay"
  class="overlay hidden fixed inset-0 z-50 flex items-center justify-center p-6 bg-black/95 backdrop-blur-md"
  role="dialog"
  aria-labelledby="overlay-title"
  aria-modal="true"
  aria-live="polite"
>
  <div
    class="overlayContent w-full max-w-[768px] max-h-[90vh] p-6 md:p-8 bg-zinc-800 border border-zinc-700 rounded-xl shadow-xl overflow-y-auto overscroll-contain scrollbar-gutter-stable"
    role="document"
    tabindex="-1"
  >
    <div class="flex justify-between items-center mb-6">
      <h2
        id="overlay-title"
        class="title text-2xl md:text-3xl font-bold text-zinc-50 tracking-tight"
      >
        {t("game.feedback.resolution")}
      </h2>
    </div>

    <p
      id="feedback"
      class="feedback my-6 p-5 rounded-lg text-xl font-semibold text-center leading-relaxed"
      role="status"
      aria-live="assertive"
    >
    </p>

    <div
      class="mediaSection grid md:grid-cols-2 gap-6 mb-8 items-start"
      aria-label={t("game.feedback.media.section")}
    >
      <div class="imageContainer flex justify-center">
        <img
          id="overlay-cover"
          class="albumCover aspect-square w-full max-w-[300px] h-auto rounded-lg object-cover shadow-lg transform transition-transform hover:scale-[1.02] duration-300"
          src=""
          alt=""
          loading="eager"
          decoding="async"
        />
      </div>

      <div
        class="infoSection text-left space-y-3 flex flex-col justify-between"
        role="contentinfo"
      >
        <div>
          <p
            id="overlay-artist"
            class="artist text-2xl font-bold text-sky-400 mb-2"
          >
          </p>
          <p id="overlay-album" class="album text-xl text-zinc-50 mb-1"></p>
          <p id="overlay-year" class="year text-lg text-zinc-300"></p>
          <p
            id="overlay-funfact"
            class="funFact text-lg text-zinc-300 mt-4 leading-relaxed"
          >
          </p>
        </div>

        <audio
          id="audio-preview"
          class="audioPlayer w-full mt-4"
          controls
          preload="metadata"
          aria-label={t("game.feedback.audio.preview")}
        >
          <source id="audio-preview-source" src="" type="audio/mpeg" />
          <source id="audio-preview-source-ogg" src="" type="audio/ogg" />
          <track kind="captions" src="" label={t("game.feedback.subtitles")} />
          <p>{t("game.feedback.audio.unsupported")}</p>
        </audio>
      </div>
    </div>

    <h3 class="text-xl font-semibold text-zinc-50 mb-4 text-center">
      {t("game.feedback.streaming.links")}
    </h3>

    <div
      class="musicLinks flex flex-wrap justify-center gap-4 my-6"
      role="group"
      aria-label={t("game.feedback.streaming.links")}
    >
      <a
        id="spotify-link"
        class="musicButton inline-flex p-5 w-auto bg-sky-600 hover:bg-sky-500 focus:bg-sky-500 text-white font-semibold rounded-lg transition-colors"
        href="#"
        target="_blank"
        rel="noopener noreferrer"
        aria-label={t("game.feedback.listen.spotify")}
      >
        <Icon
          name="spotify"
          class="mr-4"
          width={24}
          height={24}
          aria-hidden="true"
        />
        <span>Spotify</span>
      </a>
      <a
        id="deezer-link"
        class="musicButton inline-flex p-5 w-auto bg-sky-600 hover:bg-sky-500 focus:bg-sky-500 text-white font-semibold rounded-lg transition-colors"
        href="#"
        target="_blank"
        rel="noopener noreferrer"
        aria-label={t("game.feedback.listen.deezer")}
      >
        <Icon
          name="deezer"
          class="mr-4"
          width={24}
          height={24}
          aria-hidden="true"
        />
        <span>Deezer</span>
      </a>
      <a
        id="apple-link"
        class="musicButton inline-flex p-5 w-auto bg-sky-600 hover:bg-sky-500 focus:bg-sky-500 text-white font-semibold rounded-lg transition-colors"
        href="#"
        target="_blank"
        rel="noopener noreferrer"
        aria-label={t("game.feedback.listen.apple")}
      >
        <Icon
          name="apple-music"
          class="mr-4"
          width={24}
          height={24}
          aria-hidden="true"
        />
        <span>Apple Music</span>
      </a>
    </div>
    <button
      id="next-round-button"
      class="nextButton block m-auto min-w-[48px] min-h-[48px] py-2 px-4 bg-sky-600 hover:bg-sky-500 focus:bg-sky-500 text-white font-semibold rounded-lg transition-colors"
      aria-label={t("game.feedback.next.round")}
    >
      <span class="flex items-center gap-2">
        {t("game.feedback.next.round")}
        <Icon name="arrow-right" width={20} height={20} aria-hidden="true" />
      </span>
    </button>
  </div>
</div>

<style>
  /* Kompatibilitätsklassen für JS-Funktionen */
  .overlay.hidden {
    pointer-events: none;
    visibility: hidden;
    opacity: 0;
  }

  .feedback.correct {
    color: #fff;
    background-color: rgb(4, 120, 87); /* emerald-700 für besseren Kontrast */
  }

  .feedback.incorrect {
    color: #fff;
    background-color: rgb(185, 28, 28); /* red-700 für besseren Kontrast */
  }

  /* Verbesserte Fokus-Stile für Tastaturnutzer */
  .overlayContent:focus,
  button:focus-visible,
  a:focus-visible {
    outline: 3px solid rgb(56, 189, 248); /* sky-300 */
    outline-offset: 3px;
  }

  /* Animation für Album-Cover mit Berücksichtigung von reduced-motion */
  @media (prefers-reduced-motion: no-preference) {
    .albumCover {
      transition:
        transform 0.3s ease,
        box-shadow 0.3s ease;
    }

    .albumCover:hover {
      transform: scale(1.03);
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
    }
  }

  /* Zusätzliche Stile für Barrierefreiheit */
  @media (forced-colors: active) {
    .overlayContent {
      border: 3px solid CanvasText;
      background-color: Canvas;
    }

    .musicButton,
    .nextButton {
      border: 2px solid ButtonText;
      background-color: ButtonFace;
      color: ButtonText;
      forced-color-adjust: none;
    }

    .musicButton:focus-visible,
    .nextButton:focus-visible {
      outline: 3px solid Highlight;
      outline-offset: 3px;
    }

    .feedback.correct,
    .feedback.incorrect {
      border: 2px solid CanvasText;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .overlay,
    .albumCover,
    button,
    a {
      transition: none !important;
      transform: none !important;
    }
  }

  /* Unterstützung für Screenreader */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  /* Optimierte Text-Lesbarkeit (AAA erfordert mindestens 18px für normalen Text) */
  .artist,
  .album,
  .year,
  .funFact {
    line-height: 1.5;
    max-width: 65ch; /* Optimale Lesbarkeit */
  }

  /* Print-Stile */
  @media print {
    .overlayContent {
      border: 1px solid #000;
      box-shadow: none;
    }

    .musicButton,
    .nextButton {
      border: 1px solid #000;
      background: #fff !important;
      color: #000 !important;
    }
  }
</style>

<script>
  /**
   * FeedbackOverlay Component Script
   *
   * Manages the feedback overlay functionality including:
   * - Focus management
   * - Keyboard navigation/accessibility
   * - Album cover display and error handling
   * - Audio player lifecycle
   */

  /**
   * Initialize the FeedbackOverlay component
   */
  function initializeFeedbackOverlay() {
    const overlay = document.getElementById("overlay") as HTMLElement;
    const overlayContent = overlay?.querySelector(
      ".overlayContent",
    ) as HTMLElement;

    if (!overlay || !overlayContent) {
      console.debug("FeedbackOverlay: Required elements not found");
      return;
    }

    // Set up observers and event listeners
    setupOverlayVisibilityObserver(overlay, overlayContent);
    setupKeyboardNavigation();
    const coverObserver = handleAlbumCoverDisplay(overlay);
    setupCleanupHandlers(coverObserver);

    // Enhance accessibility announcements
    setupAccessibilityAnnouncements();
  }

  /**
   * Enhances accessibility by providing announcements for screen readers
   */
  function setupAccessibilityAnnouncements() {
    const overlay = document.getElementById("overlay");
    const feedbackElement = document.getElementById("feedback");

    if (!overlay || !feedbackElement) return;

    // Create a live region for screen reader announcements
    const liveRegion = document.createElement("div");
    liveRegion.setAttribute("aria-live", "assertive");
    liveRegion.setAttribute("aria-atomic", "true");
    liveRegion.classList.add("sr-only");
    overlay.appendChild(liveRegion);

    // Monitor changes to the feedback text for announcements
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (
          mutation.type === "childList" ||
          mutation.type === "characterData"
        ) {
          const feedbackText = feedbackElement.textContent?.trim();
          if (feedbackText) {
            // Announce feedback text for screen readers
            liveRegion.textContent = feedbackText;
          }
        }
      });
    });

    observer.observe(feedbackElement, {
      childList: true,
      characterData: true,
      subtree: true,
    });
  }

  /**
   * Sets up an observer to monitor overlay visibility changes
   * Manages focus and scroll position when overlay becomes visible
   *
   * @param {HTMLElement} overlay - The overlay container element
   * @param {HTMLElement} overlayContent - The content container inside the overlay
   * @returns {MutationObserver} The configured observer
   */
  function setupOverlayVisibilityObserver(
    overlay: HTMLElement,
    overlayContent: HTMLElement,
  ): MutationObserver {
    const observer = new MutationObserver(() => {
      if (!overlay.classList.contains("hidden")) {
        // Reset scroll position and focus the content when overlay becomes visible
        overlayContent.scrollTop = 0;
        overlayContent.focus();
      }
    });

    // Watch for class changes on the overlay element
    observer.observe(overlay, {
      attributes: true,
      attributeFilter: ["class"],
    });

    return observer;
  }

  /**
   * Sets up keyboard navigation handlers for the overlay
   * Implements a focus trap and escape key handling
   */
  function setupKeyboardNavigation() {
    const focusableSelector =
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

    document.addEventListener("keydown", (event) => {
      const overlay = document.getElementById("overlay");
      // Only handle keyboard events when overlay is visible
      if (!overlay || overlay.classList.contains("hidden")) return;

      const content = overlay.querySelector(".overlayContent");
      const focusableElements = Array.from(
        content?.querySelectorAll(focusableSelector) || [],
      ) as HTMLElement[];

      // No focusable elements, nothing to do
      if (focusableElements.length === 0) return;

      const firstFocusable = focusableElements[0];
      const lastFocusable = focusableElements[focusableElements.length - 1];

      switch (event.key) {
        case "Escape":
          // Close the overlay when Escape is pressed
          document.getElementById("next-round-button")?.click();
          break;

        case "Tab":
          // Create a focus trap within the overlay
          if (event.shiftKey && document.activeElement === firstFocusable) {
            // Shift+Tab on first element goes to last element
            event.preventDefault();
            lastFocusable.focus();
          } else if (
            !event.shiftKey &&
            document.activeElement === lastFocusable
          ) {
            // Tab on last element goes to first element
            event.preventDefault();
            firstFocusable.focus();
          }
          break;
      }
    });
  }

  /**
   * Handles album cover display and fixes issues with cover visibility
   *
   * @param {HTMLElement} overlay - The overlay container element
   * @returns {MutationObserver} The observer handling album cover display
   */
  function handleAlbumCoverDisplay(overlay: HTMLElement): MutationObserver {
    const albumCover = document.getElementById(
      "overlay-cover",
    ) as HTMLImageElement;

    if (!albumCover) {
      console.debug("FeedbackOverlay: Album cover element not found");
      return new MutationObserver(() => {});
    }

    // Ensure the album cover is not hidden by removing any hidden class
    albumCover.classList.remove("hidden");

    // Set up error handling for the album cover image
    setupAlbumCoverErrorHandling(albumCover);

    // Define a function to check and update album cover when overlay becomes visible
    const checkAlbumCover = () => {
      if (!overlay.classList.contains("hidden")) {
        // Ensure the album cover is visible
        albumCover.style.display = "";
        albumCover.classList.remove("hidden");

        // If src is empty or points to the current page, try to get it from overlay data
        if (!albumCover.src || albumCover.src === window.location.href) {
          const albumData = overlay.getAttribute("data-album-cover");
          if (albumData) {
            albumCover.src = albumData;
          }
        }
      }
    };

    // Create an observer to watch for overlay visibility changes
    const coverObserver = new MutationObserver(checkAlbumCover);
    coverObserver.observe(overlay, {
      attributes: true,
      attributeFilter: ["class"],
    });

    // Initial check in case the overlay is already visible
    checkAlbumCover();

    return coverObserver;
  }

  /**
   * Sets up error handling for the album cover image
   *
   * @param {HTMLImageElement} albumCover - The album cover image element
   */
  function setupAlbumCoverErrorHandling(albumCover: HTMLImageElement): void {
    albumCover.onerror = () => {
      console.debug("FeedbackOverlay: Error loading album cover image");

      // Set a fallback image or message when loading fails
      albumCover.src = "/images/default-album-cover.jpg";
      albumCover.alt = "Album cover not available";

      // Ensure the image is still visible despite the error
      albumCover.style.display = "";
      albumCover.classList.remove("hidden");
    };
  }

  /**
   * Sets up cleanup handlers for when the component is unmounted
   *
   * @param {MutationObserver} coverObserver - The album cover observer to disconnect
   */
  function setupCleanupHandlers(coverObserver: MutationObserver): void {
    // Get references to elements and observers that need cleanup
    const audioPlayer = document.getElementById(
      "audio-preview",
    ) as HTMLAudioElement;
    const mainObserver = document.querySelector("#overlay")
      ? new MutationObserver(() => {}) // Placeholder if original observer not available
      : null;

    // Handle cleanup before page navigation
    document.addEventListener("astro:before-swap", () => {
      // Disconnect observers
      mainObserver?.disconnect();
      coverObserver?.disconnect();

      // Stop audio playback and clear sources
      if (audioPlayer) {
        audioPlayer.pause();
        audioPlayer.src = "";
      }
    });
  }

  // Initialize the overlay when the DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeFeedbackOverlay);
  } else {
    initializeFeedbackOverlay();
  }
</script>
