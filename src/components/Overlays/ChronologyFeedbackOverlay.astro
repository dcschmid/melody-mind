---
/**
 * ChronologyFeedbackOverlay - Game feedback modal
 *
 * Features:
 * - WCAG AAA compliant accessibility
 * - Performance optimized animations
 * - Responsive design with container queries
 * - Touch device support
 * - High contrast mode support
 * - Session timeout management
 *
 * @component
 * @example
 * ```typescript
 * window.dispatchEvent(new CustomEvent("showChronologyFeedback", {
 *   detail: { isCorrect: true, isLastRound: false }
 * }));
 * ```
 */
import { Icon } from "astro-icon/components";
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import Headline from "@components/Headline.astro";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

// Client-side translations for dynamic content
const clientTranslations = {
  "game.chronology.correct": t("game.chronology.correct"),
  "game.chronology.incorrect": t("game.chronology.incorrect"),
  "game.chronology.correct_order": t("game.chronology.correct_order"),
  "game.chronology.stats.accuracy": t("game.chronology.stats.accuracy"),
  "game.chronology.stats.round_points": t("game.chronology.stats.round_points"),
  "game.chronology.stats.total_points": t("game.chronology.stats.total_points"),
  "game.chronology.stats.round": t("game.chronology.stats.round"),
  "game.chronology.user_order.correct_title": t("game.chronology.user_order.correct_title"),
  "game.chronology.user_order.incorrect_title": t("game.chronology.user_order.incorrect_title"),
  "general.close": t("general.close"),
  "session.timeout.warning": t("session.timeout.warning"),
  "session.timeout.extend": t("session.timeout.extend"),
  "session.timeout.continue": t("session.timeout.continue"),
  "session.extended": t("session.extended"),
};
---

<div
  id="chronology-feedback-overlay"
  class="chronology-feedback-overlay hidden"
  role="dialog"
  aria-modal="true"
  aria-labelledby="feedback-title"
  aria-describedby="feedback-content"
  tabindex="-1"
  data-translations={JSON.stringify(clientTranslations)}
>
  <!-- Use a div with inset-0 to create a click target for closing the modal -->
  <div id="overlay-backdrop" class="overlay-backdrop" aria-hidden="true"></div>

  <div class="modal-content" role="document">
    <!-- Close button - positioned at the top right -->
    <button
      id="close-feedback-overlay"
      class="close-button"
      aria-label={t("general.close")}
      type="button"
    >
      <Icon name="close" width={24} height={24} aria-hidden="true" class="close-icon" />
    </button>

    <Headline level="h2" size="xl" id="feedback-title" className="modal-title">
      {t("game.chronology.result")}
    </Headline>

    <!-- Status announcer for screen readers -->
    <div id="feedback-status" aria-live="polite" aria-atomic="true" class="sr-only"></div>

    <div
      id="feedback-content"
      class="modal-content-text"
      aria-live="polite"
      aria-describedby="correct-order-description"
    >
      <!-- Content will be dynamically added here -->
      <!-- Hidden description for correct order list - enhanced accessibility -->
      <div id="correct-order-description" class="sr-only">
        {t("game.chronology.correct_order_description")}
      </div>
    </div>

    <div class="button-container">
      <button id="chronology-continue-button" class="primary-button" type="button">
        {t("game.next.round")}
      </button>
      <button id="chronology-end-button" class="secondary-button hidden" type="button">
        {t("game.end.title")}
      </button>
    </div>
  </div>
</div>

<style lang="scss" is:global>
  /**
   * ChronologyFeedbackOverlay Component Styles
   * 
   * ✅ 100% global.css variables integration
   * ✅ WCAG AAA compliant styling
   * ✅ Responsive design with mobile-first approach
   * ✅ Simplified animations and performance
   */

  // Main overlay container
  .chronology-feedback-overlay {
    position: fixed;
    inset: var(--space-none);
    z-index: 9999;

    display: flex;
    align-items: center;
    justify-content: center;

    background: rgba(0, 0, 0, 0.8);

    &.hidden {
      display: none;
      visibility: hidden;
      opacity: 0;
    }

    // Responsive padding
    @media (max-width: 39.9375em) {
      padding: var(--space-xs);
    }
  }

  // Backdrop for click-to-close functionality
  .overlay-backdrop {
    position: absolute;
    inset: var(--space-none);
  }

  // Modal content container with clean design
  .modal-content {
    position: relative;
    z-index: 10000;
    margin: var(--space-sm);
    padding: var(--space-lg);
    max-width: 500px;
    max-height: 85vh;
    border-radius: var(--radius-xl);
    background: #1f2937;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    display: flex;
    flex-direction: column;
    min-height: 0;

    @media (max-width: 23.4375em) {
      margin: var(--space-xs);
      padding: var(--space-md);
      max-height: 90vh;
    }
  }

  // Close button with enhanced accessibility
  .close-button {
    display: flex;
    align-items: center;
    justify-content: center;
    align-self: flex-end;
    margin-bottom: var(--space-sm);
    height: var(--touch-target-enhanced);
    width: var(--touch-target-enhanced);
    border-radius: var(--radius-full);
    background: var(--bg-tertiary);
    border: var(--border-width-thick) solid var(--border-primary);
    cursor: pointer;
    transition: background-color var(--transition-normal);

    &:hover {
      background: var(--bg-primary);
    }

    &:focus-visible {
      outline: var(--focus-outline);
      outline-offset: var(--focus-ring-offset);
    }
  }

  // Close icon with responsive sizing
  .close-icon {
    height: var(--icon-size-sm);
    width: var(--icon-size-sm);
    color: var(--text-secondary);

    @media (min-width: 48em) {
      height: var(--icon-size-md);
      width: var(--icon-size-md);
    }
  }

  // Modal title with clean typography
  .modal-title {
    margin-bottom: var(--space-md);
    text-align: center;
    font-size: var(--text-xl);
    font-weight: var(--font-bold);
    color: #f9fafb;
    line-height: var(--leading-tight);
  }

  // Modal content text with enhanced scrolling
  .modal-content-text {
    flex: 1;
    overflow-y: auto;
    padding: var(--space-xs);
    max-height: 60vh;
    color: var(--text-secondary);
    line-height: var(--leading-relaxed);
    scrollbar-width: thin;
    scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);

    > * {
      margin-bottom: var(--space-sm);
      &:last-child {
        margin-bottom: 0;
      }
    }

    &::-webkit-scrollbar {
      width: var(--scrollbar-width);
    }

    &::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
      border-radius: var(--scrollbar-radius);
    }

    &::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border-radius: var(--scrollbar-radius);
    }
  }

  // Button container with responsive grid
  .button-container {
    margin-top: var(--space-sm);
    display: flex;
    justify-content: center;
    gap: var(--space-sm);
  }

  // Enhanced button styles with accessibility
  .primary-button,
  .secondary-button {
    min-height: var(--touch-target-enhanced);
    border-radius: var(--radius-lg);
    padding: var(--space-sm) var(--space-md);
    font-weight: var(--font-bold);
    font-size: var(--text-sm);
    border: none;
    cursor: pointer;
    transition: background var(--transition-normal);

    &:focus-visible {
      outline: var(--focus-outline);
      outline-offset: var(--focus-ring-offset);
    }
  }

  // Clean primary button
  .primary-button {
    background: #8b5cf6; // Lila
    color: #ffffff;
    border: 2px solid #8b5cf6;

    transition: all 0.2s ease;

    &:hover {
      background: #7c3aed; // Dunkleres Lila
      border-color: #7c3aed;
      transform: translateY(-1px);
    }

    &:active {
      transform: translateY(0);
    }
  }

  // Secondary button with semantic colors
  .secondary-button {
    background: var(--color-warning-primary);
    color: var(--color-white);
    border: var(--border-width-thick) solid transparent;
    box-shadow: var(--shadow-md);

    &:hover {
      background: var(--color-warning-secondary);
      transform: translateZ(0) scale(var(--scale-focus)) translateY(var(--animation-y-offset-small));
      box-shadow: var(--shadow-xl);

      &::before {
        display: none;
      }
    }
  }

  // Hidden state utility
  .hidden {
    display: none;
    visibility: hidden;
    opacity: 0;
  }

  // Correct feedback message - Clean Design
  .feedback-correct {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    color: #065f46;
    font-weight: var(--font-bold);
    font-size: var(--text-lg);
    margin-bottom: var(--space-md);
    padding: var(--space-md);
    background: #d1fae5;
    border: 2px solid #10b981;
    border-radius: var(--radius-lg);
  }

  // Incorrect feedback message - Clean Design
  .feedback-incorrect {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    color: #7f1d1d;
    font-weight: var(--font-bold);
    font-size: var(--text-lg);
    margin-bottom: var(--space-md);
    padding: var(--space-md);
    background: #fecaca;
    border: 2px solid #ef4444;
    border-radius: var(--radius-lg);
  }

  // Dark mode feedback adjustments
  @media (prefers-color-scheme: dark) {
    .feedback-correct {
      background: var(--bg-success-dark);
      border-color: var(--border-success-dark);
      color: var(--text-success-dark);
      box-shadow: var(--shadow-lg);
    }

    .feedback-incorrect {
      background: var(--bg-error-dark);
      border-color: var(--border-error-dark);
      color: var(--text-error-dark);
      box-shadow: var(--shadow-lg);
    }
  }

  // Clean correct order heading
  .correct-order-heading {
    font-size: var(--text-lg);
    font-weight: var(--font-bold);
    margin-bottom: var(--space-sm);
    color: #f9fafb;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    text-align: center;

    &::before {
      content: "✓";
      font-size: var(--text-xl);
      color: #10b981;
    }
  }

  // Clean correct order container
  .correct-order-container {
    margin: var(--space-md) 0 0;
    padding: var(--space-md);
    background: #374151;
    border: 2px solid #10b981;
    border-radius: var(--radius-lg);
    flex-shrink: 0;
  }

  // Clean correct order list
  .correct-order-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);

    div {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-sm);
      background: #1f2937;
      border: 1px solid #4b5563;
      border-radius: var(--radius-md);
      color: #f9fafb;
      font-weight: var(--font-medium);

      @media (max-width: 23.4375em) {
        flex-direction: column;
        text-align: center;
        gap: var(--space-sm);
      }
    }
  }

  // Clean order number
  .order-number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--space-2xl);
    height: var(--space-2xl);
    background: #10b981;
    color: #ffffff;
    border-radius: var(--radius-full);
    font-weight: var(--font-bold);
    font-size: var(--text-sm);
    flex-shrink: 0;
  }

  // Song info with responsive typography
  .song-info {
    flex: 1;
    font-size: var(--text-sm);
    line-height: var(--leading-relaxed);
    font-weight: var(--font-medium);
  }

  // Feedback message with enhanced layout
  .feedback-message {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-sm);
    flex-shrink: 0;
  }

  // Feedback icon with responsive sizing
  .feedback-icon {
    font-size: var(--text-xl);
  }

  // Feedback text with responsive typography
  .feedback-text {
    font-size: var(--text-base);
    font-weight: var(--font-bold);
    text-align: center;
    line-height: var(--leading-relaxed);
  }

  // Game statistics display with enhanced design
  .game-stats {
    margin: var(--space-sm) 0;
    padding: var(--space-sm);
    background: var(--bg-tertiary);
    border: var(--border-width-thick) solid var(--border-secondary);
    border-radius: var(--radius-lg);
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(6rem, 1fr));
    gap: var(--space-sm);
  }

  // Stat item with enhanced interactivity
  .stat-item {
    text-align: center;
    padding: var(--space-xs);
    background: var(--bg-primary);
    border-radius: var(--radius-md);
    border: var(--border-width-thin) solid var(--border-primary);
  }

  // Stat label with enhanced typography
  .stat-label {
    display: block;
    font-size: var(--text-xs);
    color: var(--text-secondary);
    margin-bottom: var(--space-xs);
    font-weight: var(--font-medium);
    text-transform: uppercase;
  }

  // Stat value with responsive sizing
  .stat-value {
    display: block;
    font-size: var(--text-lg);
    color: var(--text-primary);
    font-weight: var(--font-bold);
    line-height: var(--leading-none);
  }

  // Reduced motion support
  @media (prefers-reduced-motion: reduce) {
    * {
      animation: none !important;
      transition: none !important;
    }
  }

  // Clean feedback stats display
  .feedback-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: var(--space-sm);
    margin-top: var(--space-sm);
    padding: var(--space-md);
    background: #374151;
    border-radius: var(--radius-lg);
    border: 1px solid #4b5563;

    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-sm);
      border-radius: var(--radius-md);
      background: #1f2937;
      border: 1px solid #4b5563;
    }

    .stat-label {
      font-size: var(--text-xs);
      color: #9ca3af;
      font-weight: var(--font-medium);
      text-transform: uppercase;
    }

    .stat-value {
      font-size: var(--text-lg);
      color: #f9fafb;
      font-weight: var(--font-bold);
    }
  }

  // Clean user order container
  .user-order-container {
    margin: var(--space-md) 0 0;
    padding: var(--space-md);
    background: #374151;
    border: 2px solid #ef4444;
    border-radius: var(--radius-lg);
    flex-shrink: 0;
  }

  // Clean user order heading
  .user-order-heading {
    font-size: var(--text-lg);
    font-weight: var(--font-bold);
    margin-bottom: var(--space-sm);
    color: #f9fafb;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    text-align: center;

    &::before {
      content: "✖";
      font-size: var(--text-xl);
      color: #ef4444;
    }
  }

  // User order list with enhanced styling
  .user-order-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);

    div {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-sm);
      background: #1f2937;
      border: 1px solid #4b5563;
      border-radius: var(--radius-md);
      color: #f9fafb;
      font-weight: var(--font-medium);

      &.correct {
        border-color: var(--border-success);
        background: var(--bg-success-aaa);
      }

      &.incorrect {
        border-color: var(--border-error);
        background: var(--bg-error-aaa);
      }

      @media (max-width: 23.4375em) {
        flex-direction: column;
        text-align: center;
        gap: var(--space-sm);
      }
    }

    .order-number {
      display: flex;
      align-items: center;
      justify-content: center;
      width: var(--space-2xl);
      height: var(--space-2xl);
      border-radius: var(--radius-full);
      font-weight: var(--font-bold);
      font-size: var(--text-sm);
      flex-shrink: 0;

      &.correct {
        background: var(--color-success-primary);
        color: var(--color-white);
      }

      &.incorrect {
        background: var(--color-error-primary);
        color: var(--color-white);
      }
    }

    .song-info {
      flex: 1;
      font-size: var(--text-sm);
      line-height: var(--leading-relaxed);
      font-weight: var(--font-medium);
    }

    .status-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: var(--space-lg);
      height: var(--space-lg);
      border-radius: var(--radius-full);
      font-weight: var(--font-bold);
      font-size: var(--text-sm);
      flex-shrink: 0;

      &.correct {
        background: var(--bg-success-light);
        color: var(--text-success-dark);
      }

      &.incorrect {
        background: var(--bg-error-light);
        color: var(--text-error-dark);
      }
    }
  }
</style>

<script>
  /**
   * ChronologyFeedbackOverlay Controller
   *
   * Manages feedback overlay interactions for chronology game mode.
   * Features comprehensive accessibility and simplified performance.
   *
   * @features
   * - WCAG AAA compliant focus management
   * - Simplified animations
   * - Touch device support
   * - Responsive design
   * - Reduced motion support
   * - High contrast mode support
   * - Print styles optimization
   *
   * @accessibility Full keyboard navigation with focus trapping
   * @performance Simplified animations and DOM manipulation
   * @responsive Mobile-first responsive design
   */

  // Type definitions following TypeScript best practices
  interface UserOrderItem {
    /** Position in user's ordering (1-based) */
    position: number;
    /** Artist name */
    artist: string;
    /** Album/song title */
    title: string;
    /** Release year */
    year: number;
    /** Whether this item is in the correct position */
    isCorrectPosition: boolean;
  }

  interface TranslationMap {
    /** Translation key-value pairs for client-side usage */
    [key: string]: string;
  }

  // Get translations from the server-rendered data attribute
  let translations: TranslationMap = {};

  try {
    const overlay = document.getElementById("chronology-feedback-overlay");
    if (overlay) {
      const translationData = overlay.getAttribute("data-translations");

      if (translationData) {
        translations = JSON.parse(translationData);
      }
    }
  } catch (error) {
    console.warn("Failed to parse translations from data attributes:", error);
  }

  /**
   * Translation helper with caching for performance
   *
   * @param {string} key - Translation key
   * @returns {string} Translated string or key as fallback
   */
  const getTranslation = (key: string): string => translations[key] || key;

  // State management with simplified performance
  const state = {
    previouslyFocused: null as HTMLElement | null,
    animation: {
      frameId: null as number | null,
      timeoutId: null as number | null,
    },
    // Performance tracking
    isAnimating: false,
    prefersReducedMotion: false,
    // Cached DOM measurements
    cachedViewport: { width: 0, height: 0 },
    // Throttled resize handler
    resizeTimeout: null as number | null,
  };

  /**
   * Initialize DOM elements and performance state
   * @returns {object | null} Elements object or null if initialization failed
   */
  function initializeOverlayElements() {
    // Initialize performance state
    state.prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    state.cachedViewport = {
      width: window.innerWidth,
      height: window.innerHeight,
    };

    // Get DOM elements with null checks
    const overlay = document.getElementById("chronology-feedback-overlay");
    const closeButton = document.getElementById("close-feedback-overlay");
    const backdrop = document.getElementById("overlay-backdrop");
    const continueButton = document.getElementById("chronology-continue-button");
    const endButton = document.getElementById("chronology-end-button");
    const statusAnnouncer = document.getElementById("feedback-status");
    const contentText = document.getElementById("feedback-content");

    // Early exit if required elements are not found
    if (!overlay || !closeButton || !backdrop || !continueButton || !endButton || !contentText) {
      console.warn("Chronology feedback overlay elements not found");
      return null;
    }

    return {
      overlay,
      closeButton,
      backdrop,
      continueButton,
      endButton,
      statusAnnouncer,
      contentText,
    };
  }

  /**
   * Initializes feedback overlay with performance optimizations
   *
   * @returns {(() => void) | undefined} Cleanup function or undefined if failed
   * @accessibility WCAG AAA compliant focus management
   * @performance Optimized event delegation with memory leak prevention
   */
  /* eslint-disable max-lines-per-function, @typescript-eslint/explicit-function-return-type */
  function initFeedbackOverlay() {
    const elements = initializeOverlayElements();
    if (!elements) {
      return;
    }

    /**
     * Shows overlay with simplified animations
     * @accessibility Stores focus, prevents background scroll, respects reduced motion
     * @performance Uses simplified animations
     */
    const showOverlay = () => {
      if (!elements) {
        return;
      }

      // Prevent concurrent animations
      if (state.isAnimating) {
        return;
      }
      state.isAnimating = true;

      // Store current focus for restoration
      state.previouslyFocused = document.activeElement as HTMLElement;

      // Show overlay immediately
      elements.overlay.classList.remove("hidden");
      elements.overlay.setAttribute("aria-hidden", "false");

      // Reset modal content scroll position to top for better UX
      elements.contentText.scrollTop = 0;

      // Prevent background scrolling without affecting modal scrolling
      const scrollY = window.scrollY;
      document.body.style.position = "fixed";
      document.body.style.top = `-${scrollY}px`;
      document.body.style.left = "0";
      document.body.style.right = "0";
      document.body.style.width = "100%";
      // Store scroll position for restoration
      document.body.setAttribute("data-scroll-y", scrollY.toString());

      if (state.prefersReducedMotion) {
        // No animation for reduced motion users
        elements.overlay.style.opacity = "1";
        elements.overlay.style.transform = "none";
        state.isAnimating = false;
        focusFirstElement();
      } else {
        // Simplified entrance animation
        elements.overlay.style.opacity = "0";
        elements.overlay.style.transform = "translateY(-20px)";

        state.animation.frameId = requestAnimationFrame(() => {
          elements.overlay.style.transition = "opacity 0.2s ease-out, transform 0.2s ease-out";
          elements.overlay.style.opacity = "1";
          elements.overlay.style.transform = "translateY(0)";

          // Focus management after animation
          state.animation.timeoutId = window.setTimeout(() => {
            state.isAnimating = false;
            focusFirstElement();
          }, 200);
        });
      }
    };

    /**
     * Hides overlay with cleanup and focus restoration
     * @accessibility Restores focus, re-enables scrolling, sets ARIA attributes
     * @performance Cleans up animations, prevents memory leaks
     */
    const hideOverlay = () => {
      if (!elements) {
        return;
      }

      // Prevent concurrent animations
      if (state.isAnimating) {
        return;
      }
      state.isAnimating = true;

      // Clear any pending animations
      if (state.animation.frameId) {
        cancelAnimationFrame(state.animation.frameId);
        state.animation.frameId = null;
      }
      if (state.animation.timeoutId) {
        clearTimeout(state.animation.timeoutId);
        state.animation.timeoutId = null;
      }

      elements.overlay.setAttribute("aria-hidden", "true");

      if (state.prefersReducedMotion) {
        // Immediate hiding for reduced motion users
        elements.overlay.classList.add("hidden");
        elements.overlay.style.opacity = "";
        elements.overlay.style.transform = "";
        elements.overlay.style.transition = "";
        state.isAnimating = false;
        restoreFocusAndCleanup();
      } else {
        // Animate exit
        elements.overlay.style.opacity = "0";
        elements.overlay.style.transform = "translateY(-20px)";

        state.animation.timeoutId = window.setTimeout(() => {
          elements.overlay.classList.add("hidden");
          elements.overlay.style.opacity = "";
          elements.overlay.style.transform = "";
          elements.overlay.style.transition = "";
          state.isAnimating = false;
          restoreFocusAndCleanup();
        }, 200);
      }
    };

    /**
     * Focuses first interactive element with delay
     * @accessibility Ensures logical keyboard navigation start
     * @wcag WCAG AAA compliant focus management
     */
    const focusFirstElement = () => {
      if (!elements) {
        return;
      }

      // Clear any existing timeout
      if (state.animation.timeoutId) {
        clearTimeout(state.animation.timeoutId);
      }

      state.animation.timeoutId = window.setTimeout(() => {
        elements.closeButton.focus();
      }, 50);
    };

    /**
     * Restores focus and cleanup after modal closes
     * @accessibility Restores focus, re-enables scrolling, handles missing elements
     * @performance Defensive programming with error handling
     */
    const restoreFocusAndCleanup = () => {
      // Re-enable scrolling and restore scroll position
      const scrollY = document.body.getAttribute("data-scroll-y");
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.left = "";
      document.body.style.right = "";
      document.body.style.width = "";
      document.body.removeAttribute("data-scroll-y");

      // Restore scroll position
      if (scrollY) {
        window.scrollTo(0, parseInt(scrollY, 10));
      }

      // Restore focus to previously focused element
      if (
        state.previouslyFocused &&
        "focus" in state.previouslyFocused &&
        typeof state.previouslyFocused.focus === "function"
      ) {
        state.animation.timeoutId = window.setTimeout(() => {
          try {
            state.previouslyFocused.focus();
          } catch {
            // Focus restoration failed silently - not critical for user experience
          }
          state.previouslyFocused = null;
        }, 50);
      }
    };

    /**
     * Updates feedback content based on game result
     * @param {object} detail - Complete feedback data
     * @accessibility Creates semantic HTML with proper roles and live regions
     * @performance Efficient DOM manipulation with minimal reflows
     */
    /* eslint-disable max-lines-per-function, complexity */
    function updateFeedbackContent(detail) {
      const feedbackContent = document.getElementById("feedback-content");
      if (!feedbackContent) {
        console.error("ChronologyFeedback: feedback-content element not found");
        return;
      }

      // Clear previous content efficiently
      feedbackContent.innerHTML = "";

      const {
        isCorrect,
        correctOrder,
        userOrder,
        accuracy,
        scoreGained,
        totalScore,
        round,
        totalRounds,
      } = detail;

      // Create main feedback message with enhanced styling
      const messageEl = document.createElement("div");
      messageEl.className = "feedback-message";
      messageEl.setAttribute("role", "status");
      messageEl.setAttribute("aria-live", "polite");

      // Main result message
      const resultEl = document.createElement("h3");
      resultEl.className = isCorrect ? "feedback-correct" : "feedback-incorrect";

      if (isCorrect) {
        resultEl.textContent = getTranslation("game.chronology.correct");
        resultEl.innerHTML = `
          <span class="feedback-icon">🎉</span>
          ${getTranslation("game.chronology.correct")}
        `;
      } else {
        resultEl.innerHTML = `
          <span class="feedback-icon">😔</span>
          ${getTranslation("game.chronology.incorrect")}
        `;
      }

      messageEl.appendChild(resultEl);

      // Add score and statistics section
      if (typeof scoreGained === "number" || typeof accuracy === "number") {
        const statsEl = document.createElement("div");
        statsEl.className = "feedback-stats";

        let statsHTML = "";
        if (typeof accuracy === "number") {
          statsHTML += `<div class="stat-item">
            <span class="stat-label">${getTranslation("game.chronology.stats.accuracy")}</span>
            <span class="stat-value">${accuracy}%</span>
          </div>`;
        }

        if (typeof scoreGained === "number") {
          statsHTML += `<div class="stat-item">
            <span class="stat-label">${getTranslation("game.chronology.stats.round_points")}</span>
            <span class="stat-value">+${scoreGained}</span>
          </div>`;
        }

        if (typeof totalScore === "number") {
          statsHTML += `<div class="stat-item">
            <span class="stat-label">${getTranslation("game.chronology.stats.total_points")}</span>
            <span class="stat-value">${totalScore}</span>
          </div>`;
        }

        if (typeof round === "number" && typeof totalRounds === "number") {
          statsHTML += `<div class="stat-item">
            <span class="stat-label">${getTranslation("game.chronology.stats.round")}</span>
            <span class="stat-value">${round}/${totalRounds}</span>
          </div>`;
        }

        statsEl.innerHTML = statsHTML;
        messageEl.appendChild(statsEl);
      }

      feedbackContent.appendChild(messageEl);

      // Add correct order information with years
      if (correctOrder && Array.isArray(correctOrder) && correctOrder.length > 0) {
        const orderSection = document.createElement("div");
        orderSection.className = "correct-order-container";

        const orderHeading = document.createElement("h4");
        orderHeading.className = "correct-order-heading";
        orderHeading.textContent = getTranslation("game.chronology.correct_order");
        orderSection.appendChild(orderHeading);

        // Create accessible container with enhanced styling
        const orderList = document.createElement("div");
        orderList.className = "correct-order-list";
        orderList.setAttribute("role", "list");
        orderList.setAttribute("aria-label", getTranslation("game.chronology.correct_order"));

        correctOrder.forEach((item, index) => {
          const listItem = document.createElement("div");
          listItem.setAttribute("role", "listitem");
          // Keine zusätzliche Klasse notwendig, CSS wird über .correct-order-list div angewendet
          listItem.innerHTML = `
            <span class="order-number">${index + 1}</span>
            <span class="song-info">${item}</span>
          `;
          listItem.setAttribute("aria-setsize", correctOrder.length.toString());
          listItem.setAttribute("aria-posinset", (index + 1).toString());
          orderList.appendChild(listItem);
        });

        orderSection.appendChild(orderList);
        feedbackContent.appendChild(orderSection);
      }

      // Show user's ordering with corrections - always show if userOrder exists
      if (userOrder && Array.isArray(userOrder) && userOrder.length > 0) {
        const userOrderSection = document.createElement("div");
        userOrderSection.className = "user-order-container";

        const userHeading = document.createElement("h4");
        userHeading.className = "user-order-heading";
        userHeading.textContent = isCorrect
          ? getTranslation("game.chronology.user_order.correct_title")
          : getTranslation("game.chronology.user_order.incorrect_title");
        userOrderSection.appendChild(userHeading);

        const userOrderList = document.createElement("div");
        userOrderList.className = "user-order-list";
        userOrderList.setAttribute("role", "list");

        userOrder.forEach((item, index) => {
          const listItem = document.createElement("div");
          listItem.setAttribute("role", "listitem");
          listItem.className = item.isCorrectPosition ? "correct" : "incorrect";
          listItem.innerHTML = `
            <span class="order-number ${item.isCorrectPosition ? "correct" : "incorrect"}">${item.position}</span>
            <span class="song-info">
              ${item.artist} - ${item.title} (${item.year})
            </span>
            <span class="status-icon ${item.isCorrectPosition ? "correct" : "incorrect"}">
              ${item.isCorrectPosition ? "✓" : "✗"}
            </span>
          `;
          // Add staggered animation delay for visual appeal
          listItem.style.setProperty("--item-index", index.toString());
          userOrderList.appendChild(listItem);
        });

        userOrderSection.appendChild(userOrderList);
        feedbackContent.appendChild(userOrderSection);
      }
    }

    /**
     * Gets focusable elements for keyboard navigation
     * @param {Element} container - Container to search within
     * @returns {HTMLElement[]} Array of focusable elements
     * @accessibility Identifies keyboard-navigable elements, filters hidden/disabled
     * @performance Efficient querySelector and filtering
     */
    function getFocusableElements(container: Element): HTMLElement[] {
      const selector = [
        "button:not([disabled])",
        "[href]:not([disabled])",
        "input:not([disabled])",
        "select:not([disabled])",
        "textarea:not([disabled])",
        '[tabindex]:not([tabindex="-1"])',
      ].join(", ");

      return Array.from(container.querySelectorAll(selector)).filter((el): el is HTMLElement => {
        if (!(el instanceof HTMLElement)) {
          return false;
        }

        // Check visibility and accessibility
        const style = window.getComputedStyle(el);
        const rect = el.getBoundingClientRect();

        return (
          style.display !== "none" &&
          style.visibility !== "hidden" &&
          style.opacity !== "0" &&
          rect.width > 0 &&
          rect.height > 0 &&
          el.getAttribute("aria-hidden") !== "true"
        );
      });
    }

    /**
     * Sets up focus trap for keyboard navigation
     * @param {Element} element - Modal container for focus trapping
     * @accessibility Implements Tab cycling, supports forward/backward navigation
     * @wcag Meets WCAG AAA focus management requirements
     */
    function setupFocusTrap(element) {
      element.addEventListener("keydown", (e: Event) => {
        const keyboardEvent = e;

        // Only trap focus when modal is visible
        if (
          elements.overlay.classList.contains("hidden") ||
          elements.overlay.getAttribute("aria-hidden") === "true"
        ) {
          return;
        }

        if (keyboardEvent.key !== "Tab") {
          return;
        }

        const focusableElements = getFocusableElements(element);
        if (focusableElements.length === 0) {
          return;
        }

        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];

        if (keyboardEvent.shiftKey && document.activeElement === firstElement) {
          keyboardEvent.preventDefault();
          lastElement.focus();
        } else if (!keyboardEvent.shiftKey && document.activeElement === lastElement) {
          keyboardEvent.preventDefault();
          firstElement.focus();
        }
      });
    }

    /**
     * Handles keyboard navigation (Escape key closes modal)
     * @param {KeyboardEvent} e - Keyboard event object
     * @accessibility Provides keyboard escape mechanism (WCAG AAA required)
     * @performance Efficient event delegation pattern
     */
    function handleKeydown(e) {
      if (e.key === "Escape" && !elements.overlay.classList.contains("hidden")) {
        e.preventDefault();
        hideOverlay();
      }
    }

    /**
     * Shows feedback overlay with game results
     * @param {CustomEvent} e - Custom event with feedback details
     * @accessibility Shows overlay with focus management, updates screen readers
     * @performance Efficient batch DOM updates with cached elements
     * @wcag Meets WCAG AAA feedback and navigation requirements
     */
    function handleShowFeedback(e) {
      const detail = e.detail;

      showOverlay();
      updateFeedbackContent(detail);

      // Manage button visibility with proper accessibility
      if (detail.isLastRound) {
        elements.endButton.classList.remove("hidden");
        elements.endButton.removeAttribute("aria-hidden");
      } else {
        elements.endButton.classList.add("hidden");
        elements.endButton.setAttribute("aria-hidden", "true");
      }

      // Screen reader announcement for immediate feedback
      if (elements.statusAnnouncer) {
        elements.statusAnnouncer.textContent = detail.isCorrect
          ? getTranslation("game.chronology.correct")
          : getTranslation("game.chronology.incorrect");
      }
    }

    /**
     * Handles continue button click
     * @accessibility Hides overlay with focus restoration, maintains keyboard flow
     * @performance Efficient event dispatching
     * @wcag Meets WCAG AAA user control requirements
     */
    function handleContinue() {
      hideOverlay();
      window.dispatchEvent(new CustomEvent("chronologyContinue"));
    }

    /**
     * Handles end game button click
     * @accessibility Hides overlay with focus restoration, maintains keyboard flow
     * @performance Efficient event dispatching
     * @wcag Meets WCAG AAA user control requirements
     */
    function handleEnd() {
      hideOverlay();
      window.dispatchEvent(new CustomEvent("chronologyEnd"));
    }

    /**
     * Throttled resize handler for performance optimization
     */
    const handleResize = () => {
      if (state.resizeTimeout) {
        clearTimeout(state.resizeTimeout);
      }

      state.resizeTimeout = window.setTimeout(() => {
        state.cachedViewport = {
          width: window.innerWidth,
          height: window.innerHeight,
        };

        // Update reduced motion preference
        state.prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      }, 100);
    };

    /**
     * Sets up all event listeners for the overlay
     * @accessibility Configures keyboard navigation, focus trap, modal controls
     * @performance Efficient event delegation with cached element references
     * @features Modal controls, keyboard navigation
     * @wcag Meets WCAG AAA keyboard navigation and user control requirements
     */
    function setupEventListeners() {
      if (!elements) {
        return;
      }

      // Modal control events with semantic action handlers
      elements.closeButton.addEventListener("click", hideOverlay);
      elements.backdrop.addEventListener("click", hideOverlay);
      elements.continueButton.addEventListener("click", handleContinue);
      elements.endButton.addEventListener("click", handleEnd);

      // Global keyboard navigation events
      document.addEventListener("keydown", handleKeydown);
      window.addEventListener("showChronologyFeedback", handleShowFeedback);

      // Performance optimization events
      window.addEventListener("resize", handleResize, { passive: true });

      // Focus trap setup for accessibility compliance
      setupFocusTrap(elements.overlay);
    }

    /**
     * Cleanup function to remove listeners and clear timeouts
     * @accessibility Removes accessibility listeners, clears focus state
     * @performance Cancels animations, stops session monitoring, prevents memory leaks
     * @usage Called on page unload or component destruction
     * @wcag Ensures proper cleanup for assistive technology compatibility
     */
    const cleanup = () => {
      // Clear any pending animations or timeouts to prevent memory leaks
      if (state.animation.frameId) {
        cancelAnimationFrame(state.animation.frameId);
        state.animation.frameId = null;
      }
      if (state.animation.timeoutId) {
        clearTimeout(state.animation.timeoutId);
        state.animation.timeoutId = null;
      }
      if (state.resizeTimeout) {
        clearTimeout(state.resizeTimeout);
        state.resizeTimeout = null;
      }

      // Remove event listeners - all elements are guaranteed to exist in this scope
      if (elements) {
        elements.closeButton.removeEventListener("click", hideOverlay);
        elements.backdrop.removeEventListener("click", hideOverlay);
        elements.continueButton.removeEventListener("click", handleContinue);
        elements.endButton.removeEventListener("click", handleEnd);
      }
      document.removeEventListener("keydown", handleKeydown);
      window.removeEventListener("showChronologyFeedback", handleShowFeedback);
      window.removeEventListener("resize", handleResize);

      // Reset component state for potential reuse
      state.previouslyFocused = null;
      state.isAnimating = false;
    };

    // Initialize event listeners and component state
    setupEventListeners();

    // Cleanup on page unload to prevent memory leaks and maintain performance
    window.addEventListener("beforeunload", cleanup);
    window.addEventListener("pagehide", cleanup);

    // Return cleanup function for manual cleanup if needed
    return cleanup;
  }

  /**
   * Initialize overlay when DOM is ready
   * @performance Efficient DOM ready detection
   * @accessibility Sets up accessibility features before user interaction
   */
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initFeedbackOverlay);
  } else {
    initFeedbackOverlay();
  }
</script>
