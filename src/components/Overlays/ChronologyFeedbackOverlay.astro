---
/**
 * @component ChronologyFeedbackOverlay
 * @description A modal overlay that displays feedback after each round in the Chronology game mode.
 * This component implements WCAG AAA accessibility standards, optimized performance, and follows
 * all MelodyMind project coding standards.
 *
 * @features
 * - WCAG AAA compliant with focus management and screen reader support
 * - Performance-optimized animations with reduced motion support
 * - Session timeout management for user security
 * - Keyboard navigation with full focus trap implementation
 * - Responsive design with consistent theming via CSS custom properties
 * - Internationalization support with server-side translations
 *
 * @accessibility
 * - Focus trap for modal keyboard navigation
 * - Screen reader announcements via live regions
 * - High contrast support (7:1 color contrast ratio)
 * - Reduced motion support for vestibular disorders
 * - Semantic HTML with proper ARIA attributes
 * - Minimum 44px touch targets for mobile accessibility
 *
 * @performance
 * - GPU-accelerated animations using transform and opacity
 * - RequestAnimationFrame for smooth animation timing
 * - Memory leak prevention with proper cleanup
 * - Efficient DOM updates with minimal manipulation
 *
 * @usage
 * ```typescript
 * // Show feedback overlay
 * window.dispatchEvent(new CustomEvent("showChronologyFeedback", {
 *   detail: {
 *     isCorrect: true,
 *     isLastRound: false,
 *     correctOrder: ["Song 1", "Song 2", "Song 3"]
 *   }
 * }));
 * ```
 *
 * @see /src/pages/games/chronology.astro - Main game component that controls this overlay
 * @see /docs/components/ChronologyFeedbackOverlay.md - Detailed component documentation
 */
import { Icon } from "astro-icon/components";
import { getLangFromUrl, useTranslations } from "@utils/i18n";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

// Prepare translations for client-side usage
const clientTranslations = {
  "game.chronology.correct": t("game.chronology.correct"),
  "game.chronology.incorrect": t("game.chronology.incorrect"),
  "game.chronology.correct_order": t("game.chronology.correct_order"),
  "game.chronology.stats.accuracy": t("game.chronology.stats.accuracy"),
  "game.chronology.stats.round_points": t("game.chronology.stats.round_points"),
  "game.chronology.stats.total_points": t("game.chronology.stats.total_points"),
  "game.chronology.stats.round": t("game.chronology.stats.round"),
  "game.chronology.user_order.correct_title": t("game.chronology.user_order.correct_title"),
  "game.chronology.user_order.incorrect_title": t("game.chronology.user_order.incorrect_title"),
  "general.close": t("general.close"),
  "session.timeout.warning": t("session.timeout.warning"),
  "session.timeout.extend": t("session.timeout.extend"),
  "session.timeout.continue": t("session.timeout.continue"),
  "session.extended": t("session.extended"),
};
---

<div
  id="chronology-feedback-overlay"
  class="chronology-feedback-overlay hidden"
  role="dialog"
  aria-modal="true"
  aria-labelledby="feedback-title"
  aria-describedby="feedback-content"
  tabindex="-1"
  data-translations={JSON.stringify(clientTranslations)}
>
  <!-- Use a div with inset-0 to create a click target for closing the modal -->
  <div id="overlay-backdrop" class="overlay-backdrop" aria-hidden="true"></div>

  <div class="modal-content" role="document">
    <!-- Close button - positioned at the top right -->
    <button
      id="close-feedback-overlay"
      class="close-button"
      aria-label={t("general.close")}
      type="button"
    >
      <Icon name="close" width={24} height={24} aria-hidden="true" class="close-icon" />
    </button>

    <h2 id="feedback-title" class="modal-title">
      {t("game.chronology.result")}
    </h2>

    <!-- Status announcer for screen readers -->
    <div id="feedback-status" aria-live="polite" aria-atomic="true" class="sr-only"></div>

    <div
      id="feedback-content"
      class="modal-content-text"
      aria-live="polite"
      aria-describedby="correct-order-description"
    >
      <!-- Content will be dynamically added here -->
      <!-- Hidden description for correct order list - enhanced accessibility -->
      <div id="correct-order-description" class="sr-only">
        {t("game.chronology.correct_order_description")}
      </div>
    </div>

    <div class="button-container">
      <button id="chronology-continue-button" class="primary-button" type="button">
        {t("game.next.round")}
      </button>
      <button id="chronology-end-button" class="secondary-button hidden" type="button">
        {t("game.end.title")}
      </button>
    </div>
  </div>
</div>

<style is:inline>
  .chronology-feedback-overlay {
    position: fixed;
    inset: 0;
    z-index: var(--z-modal);
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--backdrop-overlay-medium);
  }

  .chronology-feedback-overlay.hidden {
    display: none;
  }

  .overlay-backdrop {
    position: absolute;
    inset: 0;
  }

  .modal-content {
    position: relative;
    margin: var(--space-md);
    width: 100%;
    max-width: var(--container-sm);
    max-height: calc(100vh - var(--space-2xl));
    border-radius: var(--radius-2xl);
    border: 2px solid var(--border-primary);
    background: var(--bg-secondary);
    padding: var(--space-2xl);
    box-shadow: var(--shadow-2xl);
    display: flex;
    flex-direction: column;
    backdrop-filter: blur(10px);
    position: relative;
    /* Enable proper scrolling by ensuring this container has fixed constraints */
    min-height: 0; /* Critical for flexbox scrolling */
  }

  .modal-content::before {
    display: none;
  }

  .close-button {
    position: absolute;
    top: var(--space-lg);
    right: var(--space-lg);
    display: flex;
    height: var(--min-touch-size);
    width: var(--min-touch-size);
    align-items: center;
    justify-content: center;
    border-radius: var(--radius-full);
    background: var(--bg-tertiary);
    border: 2px solid var(--border-primary);
    transition:
      background-color var(--transition-normal),
      transform var(--transition-fast),
      box-shadow var(--transition-normal);
    cursor: pointer;
    box-shadow: var(--shadow-md);
    z-index: 10;
  }

  .close-button:hover {
    background: var(--bg-primary);
    transform: scale(var(--scale-focus)) rotate(90deg);
    box-shadow: var(--shadow-lg);
  }

  .close-button:focus-visible {
    outline: var(--focus-outline);
    outline-offset: var(--focus-ring-offset);
  }

  .close-icon {
    height: var(--space-xl);
    width: var(--space-xl);
    color: var(--text-secondary);
  }

  .modal-title {
    margin-bottom: var(--space-lg);
    text-align: center;
    font-size: var(--text-xl);
    font-weight: var(--font-bold);
    color: var(--text-primary);
  }

  @media (min-width: var(--breakpoint-md)) {
    .modal-title {
      font-size: var(--text-2xl);
    }
  }

  .modal-content-text {
    /* Complete scrolling solution - simplified approach */
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: var(--space-md);
    /* Force explicit height constraints for scrolling */
    height: 0;
    min-height: 0;
    max-height: none;
    /* Layout properties */
    display: block;
    text-align: center;
    color: var(--text-secondary);
    /* Reset previous flexbox that might interfere */
    align-items: unset;
    justify-content: unset;
    gap: unset;
  }

  /* Ensure child elements don't break scrolling */
  .modal-content-text > * {
    margin-bottom: var(--space-lg);
    flex-shrink: 0;
  }

  .modal-content-text > *:last-child {
    margin-bottom: 0;
  }

  /* Custom scrollbar styling for webkit browsers */
  .modal-content-text::-webkit-scrollbar {
    width: var(--space-sm);
  }

  .modal-content-text::-webkit-scrollbar-track {
    background: var(--bg-tertiary);
    border-radius: var(--radius-md);
  }

  .modal-content-text::-webkit-scrollbar-thumb {
    background: var(--border-secondary);
    border-radius: var(--radius-md);
    transition: background var(--transition-normal);
  }

  .modal-content-text::-webkit-scrollbar-thumb:hover {
    background: var(--border-primary);
  }

  /* Firefox scrollbar styling */
  .modal-content-text {
    scrollbar-width: thin;
    scrollbar-color: var(--border-secondary) var(--bg-tertiary);
  }

  .button-container {
    margin-top: var(--space-xl);
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--space-md);
    flex-shrink: 0;
    position: sticky;
    bottom: 0;
    background: var(--bg-secondary);
    padding-top: var(--space-md);
    border-top: var(--border-width-thin) solid var(--border-secondary);
  }

  @media (min-width: var(--breakpoint-md)) {
    .button-container {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  /* Enhanced button styles with modern gradients */
  .primary-button,
  .secondary-button {
    min-height: var(--min-touch-size);
    border-radius: var(--radius-full);
    padding: var(--button-padding-standard);
    font-weight: var(--font-bold);
    border: none;
    cursor: pointer;
    transition:
      transform var(--transition-normal),
      background var(--transition-normal),
      box-shadow var(--transition-normal);
    font-size: var(--text-lg);
    position: relative;
    overflow: hidden;
  }

  .primary-button::before,
  .secondary-button::before {
    display: none;
  }

  /* Primary button specific styles */
  .primary-button {
    background: var(--btn-primary-bg);
    color: var(--btn-primary-text);
    box-shadow: var(--shadow-md);
  }

  .primary-button:hover {
    background: var(--btn-primary-hover);
    transform: scale(var(--scale-focus)) translateY(-2px);
    box-shadow: var(--shadow-xl);
  }

  .primary-button:hover::before {
    display: none;
  }

  .primary-button:focus-visible {
    outline: var(--focus-outline);
    outline-offset: var(--focus-ring-offset);
  }

  /* Secondary button using simple solid colors */
  .secondary-button {
    background: var(--btn-warning-bg);
    color: var(--color-white);
    border: 2px solid transparent;
    box-shadow: var(--shadow-md);
  }

  .secondary-button:hover {
    background: var(--btn-warning-hover);
    transform: scale(var(--scale-focus)) translateY(-2px);
    box-shadow: var(--shadow-xl);
  }

  .secondary-button:hover::before {
    display: none;
  }

  .secondary-button:focus-visible {
    outline: var(--focus-outline);
    outline-offset: var(--focus-ring-offset);
  }

  .hidden {
    display: none;
  }

  /* Simplified feedback messages - clear and readable! */
  .feedback-correct {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-md);
    color: var(--color-success-700);
    font-weight: var(--font-bold);
    font-size: var(--text-2xl);
    margin-bottom: var(--space-xl);
    padding: var(--space-xl) var(--space-2xl);
    background: var(--color-success-50);
    border: 2px solid var(--color-success-300);
    border-radius: var(--radius-xl);
    box-shadow: var(--shadow-lg);
    animation: successPulse 0.8s ease-out;
  }

  .feedback-incorrect {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-md);
    color: var(--color-error-700);
    font-weight: var(--font-bold);
    font-size: var(--text-2xl);
    margin-bottom: var(--space-xl);
    padding: var(--space-xl) var(--space-2xl);
    background: var(--color-error-50);
    border: 2px solid var(--color-error-300);
    border-radius: var(--radius-xl);
    box-shadow: var(--shadow-lg);
    animation: errorShake 0.8s ease-out;
  }

  /* Dark mode feedback adjustments - clean and readable */
  @media (prefers-color-scheme: dark) {
    .feedback-correct {
      background: var(--color-success-900);
      border-color: var(--color-success-500);
      color: var(--color-success-100);
      box-shadow: var(--shadow-lg);
    }

    .feedback-incorrect {
      background: var(--color-error-900);
      border-color: var(--color-error-500);
      color: var(--color-error-100);
      box-shadow: var(--shadow-lg);
    }
  }

  .correct-order-heading {
    font-size: var(--text-2xl);
    font-weight: var(--font-bold);
    margin-bottom: var(--space-lg);
    color: var(--text-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-md);
    text-align: center;
  }

  .correct-order-heading::before {
    content: "🎯";
    font-size: var(--text-3xl);
    animation: iconBounce 2s infinite;
  }

  .correct-order-container {
    width: 100%;
    max-width: 32rem;
    margin: var(--space-xl) auto 0;
    padding: var(--space-xl);
    background: var(--bg-tertiary);
    border: 2px solid var(--border-secondary);
    border-radius: var(--radius-xl);
    box-shadow: var(--shadow-lg);
    /* Ensure this doesn't interfere with scrolling */
    flex-shrink: 0;
  }

  .correct-order-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
  }

  .correct-order-list div {
    display: flex;
    align-items: center;
    gap: var(--space-lg);
    padding: var(--space-lg) var(--space-xl);
    background: var(--bg-primary);
    border: 2px solid var(--border-primary);
    border-radius: var(--radius-lg);
    color: var(--text-primary);
    font-weight: var(--font-semibold);
    transition: all var(--transition-normal);
    animation: slideUp 0.6s ease-out forwards;
    animation-delay: calc(0.15s * var(--item-index, 0));
    opacity: 0;
    transform: translateY(var(--space-lg));
    box-shadow: var(--shadow-md);
  }

  .correct-order-list div:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
    border-color: var(--interactive-primary);
  }

  .order-number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--space-3xl);
    height: var(--space-3xl);
    background: var(--interactive-primary);
    color: var(--btn-primary-text);
    border-radius: var(--radius-full);
    font-weight: var(--font-bold);
    font-size: var(--text-lg);
    flex-shrink: 0;
    box-shadow: var(--shadow-md);
  }

  .song-info {
    flex: 1;
    font-size: var(--text-lg);
    line-height: var(--leading-relaxed);
    font-weight: var(--font-medium);
  }

  /* Feedback message improvements */
  .feedback-message {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-lg);
    /* Ensure this doesn't interfere with scrolling */
    flex-shrink: 0;
  }

  .feedback-icon {
    font-size: var(--text-3xl);
    animation: iconBounce 0.8s ease-out;
  }

  .feedback-text {
    font-size: var(--text-xl);
    font-weight: var(--font-bold);
    text-align: center;
    line-height: var(--leading-relaxed);
  }

  /* Enhanced Game statistics display with clean card design */
  .game-stats {
    width: 100%;
    max-width: 28rem;
    margin: var(--space-xl) auto;
    padding: var(--space-xl);
    background: var(--bg-tertiary);
    border: 2px solid var(--border-secondary);
    border-radius: var(--radius-2xl);
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(8rem, 1fr));
    gap: var(--space-lg);
    box-shadow: var(--shadow-xl);
    position: relative;
    overflow: hidden;
  }

  .game-stats::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--interactive-primary);
    border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
  }

  .stat-item {
    text-align: center;
    padding: var(--space-md);
    background: var(--bg-primary);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-primary);
    transition: all var(--transition-normal);
    position: relative;
    overflow: hidden;
  }

  .stat-item::before {
    display: none;
  }

  .stat-item:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
    border-color: var(--interactive-primary);
  }

  .stat-item:hover::before {
    display: none;
  }

  .stat-label {
    display: block;
    font-size: var(--text-sm);
    color: var(--text-secondary);
    margin-bottom: var(--space-sm);
    font-weight: var(--font-semibold);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .stat-value {
    display: block;
    font-size: var(--text-2xl);
    color: var(--text-primary);
    font-weight: var(--font-bold);
    line-height: 1;
  }

  /* Animations */
  /* Add new shimmer animation for enhanced visual appeal */
  @keyframes shimmer {
    0% {
      left: -100%;
    }
    100% {
      left: 100%;
    }
  }

  @keyframes successPulse {
    0% {
      transform: scale(0.95);
      opacity: 0;
    }
    50% {
      transform: scale(1.05);
    }
    100% {
      transform: scale(1);
      opacity: 1;
    }
  }

  @keyframes errorShake {
    0%,
    100% {
      transform: translateX(0);
      opacity: 0;
    }
    10%,
    30%,
    50%,
    70%,
    90% {
      transform: translateX(-6px);
    }
    20%,
    40%,
    60%,
    80% {
      transform: translateX(6px);
    }
    100% {
      opacity: 1;
    }
  }

  @keyframes slideUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes iconBounce {
    0%,
    20%,
    53%,
    100% {
      animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
      transform: translate3d(0, 0, 0);
    }
    40%,
    43% {
      animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
      transform: translate3d(0, -20px, 0) scaleY(1.1);
    }
    70% {
      animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
      transform: translate3d(0, 0, 0) scaleY(0.95);
    }
    80% {
      transition-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
      transform: translate3d(0, 0, 0) scaleY(1.05);
    }
    90% {
      transform: translate3d(0, 0, 0) scaleY(0.95);
    }
  }

  /* Floating animation for enhanced visual appeal */
  @keyframes float {
    0%,
    100% {
      transform: translateY(0px);
    }
    50% {
      transform: translateY(-10px);
    }
  }

  /* Reduced motion support - using root variables for consistency */
  @media (prefers-reduced-motion: reduce) {
    .close-button,
    .primary-button,
    .secondary-button {
      transition: none;
    }

    .close-button:hover,
    .primary-button:hover,
    .secondary-button:hover {
      transform: none;
    }

    .feedback-correct,
    .feedback-incorrect,
    .correct-order-list div,
    .feedback-icon {
      animation: none;
    }

    .correct-order-list div:hover {
      transform: none;
    }
  }

  /* Responsive design improvements */
  @media (min-width: var(--breakpoint-md)) {
    .feedback-correct,
    .feedback-incorrect {
      font-size: var(--text-3xl);
      padding: var(--space-xl);
    }

    .correct-order-container {
      max-width: 32rem;
    }

    .correct-order-list div {
      padding: var(--space-lg);
    }

    .order-number {
      width: var(--space-3xl);
      height: var(--space-3xl);
      font-size: var(--text-base);
    }

    .song-info {
      font-size: var(--text-lg);
    }

    .game-stats {
      max-width: 28rem;
      grid-template-columns: repeat(4, 1fr);
    }

    .modal-content {
      max-height: calc(100vh - var(--space-3xl));
    }
  }

  /* Remove conflicting scrollbar styles from modal-content */
  .modal-content {
    /* Remove all scrollbar styling from here - it should only be on modal-content-text */
  }

  /* Enhanced Feedback Styles - using updated styles from above */

  .feedback-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: var(--space-sm);
    margin-top: var(--space-md);
    padding: var(--space-md);
    background: var(--bg-tertiary);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-secondary);
  }

  .stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-xs);
  }

  .stat-label {
    font-size: var(--text-sm);
    color: var(--text-secondary);
    font-weight: var(--font-medium);
  }

  .stat-value {
    font-size: var(--text-lg);
    color: var(--text-primary);
    font-weight: var(--font-bold);
  }

  /* User order container - clean design without gradients */
  .user-order-container {
    width: 100%;
    max-width: 32rem;
    margin: var(--space-xl) auto 0;
    padding: var(--space-xl);
    background: var(--bg-tertiary);
    border: 2px solid var(--border-secondary);
    border-radius: var(--radius-2xl);
    box-shadow: var(--shadow-xl);
    position: relative;
    overflow: hidden;
    /* Ensure this doesn't interfere with scrolling */
    flex-shrink: 0;
  }

  .user-order-container::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--color-error-500);
    border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
  }

  .user-order-heading {
    font-size: var(--text-2xl);
    font-weight: var(--font-bold);
    margin-bottom: var(--space-lg);
    color: var(--text-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-md);
    text-align: center;
  }

  .user-order-heading::before {
    content: "📝";
    font-size: var(--text-3xl);
    animation: iconBounce 2s infinite 0.5s;
  }

  .user-order-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
  }

  .user-order-list div {
    display: flex;
    align-items: center;
    gap: var(--space-lg);
    padding: var(--space-lg) var(--space-xl);
    background: var(--bg-primary);
    border: 2px solid var(--border-primary);
    border-radius: var(--radius-xl);
    color: var(--text-primary);
    font-weight: var(--font-semibold);
    transition: all var(--transition-normal);
    animation: slideUp 0.6s ease-out forwards;
    animation-delay: calc(0.15s * var(--item-index, 0));
    opacity: 0;
    transform: translateY(var(--space-lg));
    box-shadow: var(--shadow-md);
    position: relative;
    overflow: hidden;
  }

  .user-order-list div::before {
    display: none;
  }

  .user-order-list div:hover {
    transform: translateY(-4px) scale(1.02);
    box-shadow: var(--shadow-xl);
  }

  .user-order-list div:hover::before {
    display: none;
  }

  .user-order-list div.correct {
    border-color: var(--color-success-400);
    background: var(--color-success-100);
    box-shadow: var(--shadow-md);
  }

  .user-order-list div.incorrect {
    border-color: var(--color-error-400);
    background: var(--color-error-100);
    box-shadow: var(--shadow-md);
  }

  .user-order-list .order-number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--space-3xl);
    height: var(--space-3xl);
    border-radius: var(--radius-full);
    font-weight: var(--font-bold);
    font-size: var(--text-lg);
    flex-shrink: 0;
    box-shadow: var(--shadow-lg);
    position: relative;
    overflow: hidden;
  }

  .user-order-list .order-number::before {
    display: none;
  }

  .user-order-list div:hover .order-number::before {
    display: none;
  }

  .user-order-list .order-number.correct {
    background: var(--color-success-500);
    color: var(--color-white);
    box-shadow: var(--shadow-lg);
  }

  .user-order-list .order-number.incorrect {
    background: var(--color-error-500);
    color: var(--color-white);
    box-shadow: var(--shadow-lg);
  }

  .user-order-list .song-info {
    flex: 1;
    font-size: var(--text-lg);
    line-height: var(--leading-relaxed);
    font-weight: var(--font-medium);
  }

  .user-order-list .status-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--space-xl);
    height: var(--space-xl);
    border-radius: var(--radius-full);
    font-weight: var(--font-bold);
    font-size: var(--text-lg);
    flex-shrink: 0;
    transition: all var(--transition-fast);
  }

  .user-order-list .status-icon.correct {
    background: var(--color-success-200);
    color: var(--color-success-700);
  }

  .user-order-list .status-icon.incorrect {
    background: var(--color-error-200);
    color: var(--color-error-700);
  }

  /* Dark mode support for user order */
  @media (prefers-color-scheme: dark) {
    .user-order-list div.correct {
      background: var(--color-success-900);
      border-color: var(--color-success-600);
    }

    .user-order-list div.incorrect {
      background: var(--color-error-900);
      border-color: var(--color-error-600);
    }

    .user-order-list .status-icon.correct {
      background: var(--color-success-800);
      color: var(--color-success-200);
    }

    .user-order-list .status-icon.incorrect {
      background: var(--color-error-800);
      color: var(--color-error-200);
    }
  }

  .order-item,
  .user-order-item {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    padding: var(--space-sm) var(--space-md);
    background: var(--card-bg);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-secondary);
    transition: all var(--transition-normal);
  }

  .order-item:hover,
  .user-order-item:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
  }

  .user-order-item.correct {
    border-color: var(--color-secondary-300);
    background: linear-gradient(
      135deg,
      var(--color-secondary-50) 0%,
      var(--color-secondary-100) 100%
    );
  }

  .user-order-item.incorrect {
    border-color: var(--color-neutral-300);
    background: linear-gradient(135deg, var(--color-neutral-50) 0%, var(--color-neutral-100) 100%);
  }

  .order-position {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background: var(--interactive-primary);
    color: white;
    border-radius: var(--radius-full);
    font-weight: var(--font-bold);
    font-size: var(--text-sm);
    flex-shrink: 0;
  }

  .user-order-item.correct .order-position {
    background: var(--color-secondary-500);
  }

  .user-order-item.incorrect .order-position {
    background: var(--color-neutral-500);
  }

  .order-content {
    flex: 1;
    font-size: var(--text-base);
    color: var(--text-primary);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .check-icon {
    color: var(--color-secondary-600);
    font-weight: var(--font-bold);
    margin-left: var(--space-sm);
  }

  .x-icon {
    color: var(--color-neutral-600);
    font-weight: var(--font-bold);
    margin-left: var(--space-sm);
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .feedback-stats {
      grid-template-columns: 1fr;
    }

    .stat-item {
      flex-direction: row;
      justify-content: space-between;
    }

    .order-item,
    .user-order-item {
      flex-direction: column;
      text-align: center;
      gap: var(--space-sm);
    }

    .order-content {
      justify-content: center;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .feedback-correct,
    .feedback-incorrect,
    .order-item,
    .user-order-item {
      border-width: 3px;
    }
  }
</style>

<script>
  /**
   * Controller for the Chronology Feedback Overlay
   *
   * This script manages the accessibility and interaction for the feedback overlay
   * that appears after each round in the Chronology game mode. It follows all
   * MelodyMind project standards for TypeScript, accessibility, and performance.
   *
   * @features
   * - Focus trap for keyboard navigation with proper restoration
   * - Screen reader announcements with live regions
   * - Keyboard shortcuts (Escape to close) following WCAG AAA guidelines
   * - Focus management when opening/closing the modal
   * - Performance optimized animations with requestAnimationFrame
   * - Memory leak prevention with proper cleanup
   * - Reduced motion support for accessibility
   * - WCAG AAA compliant focus management
   * - Session timeout management using reusable utility
   * - Server-side rendered translations for proper i18n
   *
   * @typescript All functions include proper type annotations and JSDoc documentation
   * @accessibility WCAG AAA compliant with focus management and screen reader support
   * @performance Optimized with requestAnimationFrame and efficient DOM updates
   * @i18n Uses server-side rendered translations without client-side fallbacks
   */

  import { getGlobalSessionManager } from "@utils/auth/sessionTimeoutManager";

  // Type definitions following TypeScript best practices
  interface UserOrderItem {
    /** Position in user's ordering (1-based) */
    position: number;
    /** Artist name */
    artist: string;
    /** Album/song title */
    title: string;
    /** Release year */
    year: number;
    /** Whether this item is in the correct position */
    isCorrectPosition: boolean;
  }

  interface FeedbackEventDetail {
    /** Whether the user's chronology order was correct */
    isCorrect: boolean;
    /** Whether this is the final round of the game */
    isLastRound: boolean;
    /** Array of song titles in correct chronological order with years */
    correctOrder?: string[];
    /** User's ordering with position details */
    userOrder?: UserOrderItem[];
    /** Accuracy percentage (0-100) */
    accuracy?: number;
    /** Score gained this round */
    scoreGained?: number;
    /** Total accumulated score */
    totalScore?: number;
    /** Current round number */
    round?: number;
    /** Total number of rounds */
    totalRounds?: number;
    /** Game category */
    category?: string;
    /** Game difficulty */
    difficulty?: string;
  }

  interface TranslationMap {
    /** Translation key-value pairs for client-side usage */
    [key: string]: string;
  }

  // Get translations from the server-rendered data attribute
  let translations: TranslationMap = {};

  try {
    const overlay = document.getElementById("chronology-feedback-overlay");
    if (overlay) {
      const translationData = overlay.getAttribute("data-translations");

      if (translationData) {
        translations = JSON.parse(translationData);
      }
    }
  } catch (error) {
    console.warn("Failed to parse translations from data attributes:", error);
  }

  /**
   * Translation helper function - uses server-side rendered translations
   *
   * @param {string} key - Translation key to look up
   * @returns {string} Translated string or key as fallback
   * @example
   * const message = getTranslation("game.chronology.correct"); // Returns "Correct! 🎉"
   */
  function getTranslation(key: string): string {
    return translations[key] || key;
  }

  // State management with proper typing
  let previouslyFocused: Element | null = null;
  let animationFrameId: number | null = null;
  let timeoutId: number | null = null;

  /**
   * Initializes the feedback overlay functionality with comprehensive setup
   *
   * @returns {(() => void) | undefined} Cleanup function to remove all event listeners and reset state, or undefined if initialization fails
   * @throws {Error} Will log warning if required DOM elements are not found
   *
   * @example
   * ```typescript
   * const cleanup = initFeedbackOverlay();
   * // Later, when component is unmounted:
   * if (cleanup) cleanup();
   * ```
   *
   * @accessibility Implements WCAG AAA focus management and keyboard navigation
   * @performance Uses optimized event delegation and memory leak prevention
   */
  function initFeedbackOverlay(): (() => void) | undefined {
    // Get DOM elements with null checks and proper typing
    const overlay = document.getElementById("chronology-feedback-overlay") as HTMLElement | null;
    const closeButton = document.getElementById(
      "close-feedback-overlay"
    ) as HTMLButtonElement | null;
    const backdrop = document.getElementById("overlay-backdrop") as HTMLElement | null;
    const continueButton = document.getElementById(
      "chronology-continue-button"
    ) as HTMLButtonElement | null;
    const endButton = document.getElementById("chronology-end-button") as HTMLButtonElement | null;
    const statusAnnouncer = document.getElementById("feedback-status") as HTMLElement | null;
    const contentText = document.getElementById("feedback-content") as HTMLElement | null;

    // Early exit if required elements are not found
    if (!overlay || !closeButton || !backdrop || !continueButton || !endButton || !contentText) {
      console.warn("Chronology feedback overlay elements not found");
      return;
    }

    // Now TypeScript knows these elements are non-null within this scope
    const elements = {
      overlay,
      closeButton,
      backdrop,
      continueButton,
      endButton,
      statusAnnouncer,
      contentText,
    };

    // Initialize session timeout manager with custom callbacks
    const sessionManager = getGlobalSessionManager(
      {
        warningTime: 120, // 2 minutes warning (WCAG AAA requirement)
        totalTime: 1200, // 20 minutes total session time
        enabled: typeof window !== "undefined" && window.location.hostname !== "localhost",
      },
      {
        onWarning: (remainingSeconds: number) => {
          const warningMessage = getTranslation("session.timeout.warning").replace(
            "{0}",
            remainingSeconds.toString()
          );

          // Also announce through the feedback status if modal is open
          if (elements.statusAnnouncer && !elements.overlay.classList.contains("hidden")) {
            elements.statusAnnouncer.textContent = warningMessage;
          }
        },
        onExtend: (): void => {
          // Session extended successfully - informational only
        },
        onTimeout: (): void => {
          console.warn("User session timed out - redirecting to login");
          // Could redirect to login page or show timeout modal here
        },
      }
    );

    /**
     * Shows the feedback overlay with performance-optimized animations
     *
     * @accessibility
     * - Stores current focus for restoration
     * - Prevents background scrolling
     * - Respects reduced motion preferences
     * - Sets proper ARIA attributes for screen readers
     *
     * @performance
     * - Uses requestAnimationFrame for smooth animations
     * - Implements GPU acceleration with transform properties
     * - Handles reduced motion gracefully
     */
    function showOverlay(): void {
      // Store current focus for restoration
      previouslyFocused = document.activeElement;

      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      // Show overlay immediately
      elements.overlay.classList.remove("hidden");
      elements.overlay.setAttribute("aria-hidden", "false");

      // Reset modal content scroll position to top for better UX
      elements.contentText.scrollTop = 0;

      // Prevent background scrolling without affecting modal scrolling
      const scrollY = window.scrollY;
      document.body.style.position = "fixed";
      document.body.style.top = `-${scrollY}px`;
      document.body.style.left = "0";
      document.body.style.right = "0";
      document.body.style.width = "100%";
      // Store scroll position for restoration
      document.body.setAttribute("data-scroll-y", scrollY.toString());

      if (prefersReducedMotion) {
        // No animation for reduced motion users
        elements.overlay.style.opacity = "1";
        elements.overlay.style.transform = "none";
        focusFirstElement();
      } else {
        // Performance-optimized entrance animation
        elements.overlay.style.opacity = "0";
        elements.overlay.style.transform = "translateY(-20px) scale(0.95)";

        animationFrameId = requestAnimationFrame(() => {
          elements.overlay.style.transition = "opacity 0.2s ease-out, transform 0.2s ease-out";
          elements.overlay.style.opacity = "1";
          elements.overlay.style.transform = "translateY(0) scale(1)";

          // Focus management after animation
          timeoutId = window.setTimeout(focusFirstElement, 200);
        });
      }
    }

    /**
     * Hides the feedback overlay with cleanup and focus restoration
     *
     * @accessibility
     * - Restores focus to previously focused element
     * - Re-enables background scrolling
     * - Properly sets ARIA attributes
     *
     * @performance
     * - Cleans up pending animations and timeouts
     * - Uses efficient animation cleanup
     * - Prevents memory leaks
     */
    function hideOverlay(): void {
      const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      // Clear any pending animations
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }

      elements.overlay.setAttribute("aria-hidden", "true");

      if (prefersReducedMotion) {
        // Immediate hiding for reduced motion users
        elements.overlay.classList.add("hidden");
        elements.overlay.style.opacity = "";
        elements.overlay.style.transform = "";
        elements.overlay.style.transition = "";
        restoreFocusAndCleanup();
      } else {
        // Animate exit
        elements.overlay.style.opacity = "0";
        elements.overlay.style.transform = "translateY(-20px) scale(0.95)";

        timeoutId = window.setTimeout(() => {
          elements.overlay.classList.add("hidden");
          elements.overlay.style.opacity = "";
          elements.overlay.style.transform = "";
          elements.overlay.style.transition = "";
          restoreFocusAndCleanup();
        }, 200);
      }
    }

    /**
     * Focuses the first interactive element in the modal with delay
     *
     * @accessibility
     * - Ensures keyboard navigation starts at logical first element
     * - Uses timeout to avoid racing with animations
     * - Handles cleanup of existing timeouts
     *
     * @wcag WCAG AAA compliance for focus management
     */
    function focusFirstElement(): void {
      // Clear any existing timeout
      if (timeoutId) {
        clearTimeout(timeoutId);
      }

      timeoutId = window.setTimeout(() => {
        elements.closeButton.focus();
      }, 50);
    }

    /**
     * Restores focus and performs cleanup after modal closes
     *
     * @accessibility
     * - Restores focus to element that was focused before modal opened
     * - Re-enables body scrolling
     * - Handles cases where previously focused element is no longer available
     *
     * @performance Uses defensive programming with error handling
     */
    function restoreFocusAndCleanup(): void {
      // Re-enable scrolling and restore scroll position
      const scrollY = document.body.getAttribute("data-scroll-y");
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.left = "";
      document.body.style.right = "";
      document.body.style.width = "";
      document.body.removeAttribute("data-scroll-y");

      // Restore scroll position
      if (scrollY) {
        window.scrollTo(0, parseInt(scrollY, 10));
      }

      // Restore focus to previously focused element
      if (
        previouslyFocused &&
        "focus" in previouslyFocused &&
        typeof previouslyFocused.focus === "function"
      ) {
        timeoutId = window.setTimeout(() => {
          try {
            (previouslyFocused as HTMLElement).focus();
          } catch {
            // Focus restoration failed silently - not critical for user experience
          }
          previouslyFocused = null;
        }, 50);
      }
    }

    /**
     * Updates the feedback content based on the chronology game result
     *
     * @param {FeedbackEventDetail} detail - Complete feedback data from the game
     *
     * @accessibility
     * - Creates semantic HTML with proper roles and ARIA attributes
     * - Uses live regions for screen reader announcements
     * - Provides ordered list with proper structure for correct order
     *
     * @performance Uses efficient DOM manipulation with minimal reflows
     */
    function updateFeedbackContent(detail: FeedbackEventDetail): void {
      const feedbackContent = document.getElementById("feedback-content");
      if (!feedbackContent) {
        console.error("ChronologyFeedback: feedback-content element not found");
        return;
      }

      // Clear previous content efficiently
      feedbackContent.innerHTML = "";

      const {
        isCorrect,
        correctOrder,
        userOrder,
        accuracy,
        scoreGained,
        totalScore,
        round,
        totalRounds,
      } = detail;

      // Create main feedback message with enhanced styling
      const messageEl = document.createElement("div");
      messageEl.className = "feedback-message";
      messageEl.setAttribute("role", "status");
      messageEl.setAttribute("aria-live", "polite");

      // Main result message
      const resultEl = document.createElement("h3");
      resultEl.className = isCorrect ? "feedback-correct" : "feedback-incorrect";

      if (isCorrect) {
        resultEl.textContent = getTranslation("game.chronology.correct");
        resultEl.innerHTML = `
          <span class="feedback-icon">🎉</span>
          ${getTranslation("game.chronology.correct")}
        `;
      } else {
        resultEl.innerHTML = `
          <span class="feedback-icon">😔</span>
          ${getTranslation("game.chronology.incorrect")}
        `;
      }

      messageEl.appendChild(resultEl);

      // Add score and statistics section
      if (typeof scoreGained === "number" || typeof accuracy === "number") {
        const statsEl = document.createElement("div");
        statsEl.className = "feedback-stats";

        let statsHTML = "";
        if (typeof accuracy === "number") {
          statsHTML += `<div class="stat-item">
            <span class="stat-label">${getTranslation("game.chronology.stats.accuracy")}</span>
            <span class="stat-value">${accuracy}%</span>
          </div>`;
        }

        if (typeof scoreGained === "number") {
          statsHTML += `<div class="stat-item">
            <span class="stat-label">${getTranslation("game.chronology.stats.round_points")}</span>
            <span class="stat-value">+${scoreGained}</span>
          </div>`;
        }

        if (typeof totalScore === "number") {
          statsHTML += `<div class="stat-item">
            <span class="stat-label">${getTranslation("game.chronology.stats.total_points")}</span>
            <span class="stat-value">${totalScore}</span>
          </div>`;
        }

        if (typeof round === "number" && typeof totalRounds === "number") {
          statsHTML += `<div class="stat-item">
            <span class="stat-label">${getTranslation("game.chronology.stats.round")}</span>
            <span class="stat-value">${round}/${totalRounds}</span>
          </div>`;
        }

        statsEl.innerHTML = statsHTML;
        messageEl.appendChild(statsEl);
      }

      feedbackContent.appendChild(messageEl);

      // Add correct order information with years
      if (correctOrder && Array.isArray(correctOrder) && correctOrder.length > 0) {
        const orderSection = document.createElement("div");
        orderSection.className = "correct-order-container";

        const orderHeading = document.createElement("h4");
        orderHeading.className = "correct-order-heading";
        orderHeading.textContent = getTranslation("game.chronology.correct_order");
        orderSection.appendChild(orderHeading);

        // Create accessible container with enhanced styling
        const orderList = document.createElement("div");
        orderList.className = "correct-order-list";
        orderList.setAttribute("role", "list");
        orderList.setAttribute("aria-label", getTranslation("game.chronology.correct_order"));

        correctOrder.forEach((item, index) => {
          const listItem = document.createElement("div");
          listItem.setAttribute("role", "listitem");
          // Keine zusätzliche Klasse notwendig, CSS wird über .correct-order-list div angewendet
          listItem.innerHTML = `
            <span class="order-number">${index + 1}</span>
            <span class="song-info">${item}</span>
          `;
          listItem.setAttribute("aria-setsize", correctOrder.length.toString());
          listItem.setAttribute("aria-posinset", (index + 1).toString());
          orderList.appendChild(listItem);
        });

        orderSection.appendChild(orderList);
        feedbackContent.appendChild(orderSection);
      }

      // Show user's ordering with corrections - always show if userOrder exists
      if (userOrder && Array.isArray(userOrder) && userOrder.length > 0) {
        const userOrderSection = document.createElement("div");
        userOrderSection.className = "user-order-container";

        const userHeading = document.createElement("h4");
        userHeading.className = "user-order-heading";
        userHeading.textContent = isCorrect
          ? getTranslation("game.chronology.user_order.correct_title")
          : getTranslation("game.chronology.user_order.incorrect_title");
        userOrderSection.appendChild(userHeading);

        const userOrderList = document.createElement("div");
        userOrderList.className = "user-order-list";
        userOrderList.setAttribute("role", "list");

        userOrder.forEach((item, index) => {
          const listItem = document.createElement("div");
          listItem.setAttribute("role", "listitem");
          listItem.className = item.isCorrectPosition ? "correct" : "incorrect";
          listItem.innerHTML = `
            <span class="order-number ${item.isCorrectPosition ? "correct" : "incorrect"}">${item.position}</span>
            <span class="song-info">
              ${item.artist} - ${item.title} (${item.year})
            </span>
            <span class="status-icon ${item.isCorrectPosition ? "correct" : "incorrect"}">
              ${item.isCorrectPosition ? "✓" : "✗"}
            </span>
          `;
          // Add staggered animation delay for visual appeal
          listItem.style.setProperty("--item-index", index.toString());
          userOrderList.appendChild(listItem);
        });

        userOrderSection.appendChild(userOrderList);
        feedbackContent.appendChild(userOrderSection);
      }
    }

    /**
     * Gets all focusable elements within the modal for keyboard navigation
     *
     * @param {Element} container - The container element to search within
     * @returns {HTMLElement[]} Array of focusable HTML elements
     *
     * @accessibility
     * - Identifies all keyboard-navigable elements
     * - Filters out hidden or disabled elements
     * - Checks for proper visibility and accessibility
     * - Excludes elements with aria-hidden="true"
     *
     * @performance Uses efficient querySelector and filtering
     */
    function getFocusableElements(container: Element): HTMLElement[] {
      const selector = [
        "button:not([disabled])",
        "[href]:not([disabled])",
        "input:not([disabled])",
        "select:not([disabled])",
        "textarea:not([disabled])",
        '[tabindex]:not([tabindex="-1"])',
      ].join(", ");

      return Array.from(container.querySelectorAll(selector)).filter((el): el is HTMLElement => {
        if (!(el instanceof HTMLElement)) {
          return false;
        }

        // Check visibility and accessibility
        const style = window.getComputedStyle(el);
        const rect = el.getBoundingClientRect();

        return (
          style.display !== "none" &&
          style.visibility !== "hidden" &&
          style.opacity !== "0" &&
          rect.width > 0 &&
          rect.height > 0 &&
          el.getAttribute("aria-hidden") !== "true"
        );
      });
    }

    /**
     * Sets up focus trap for keyboard navigation within the modal
     *
     * @param {Element} element - The modal container element to trap focus within
     *
     * @accessibility
     * - Implements proper Tab key cycling through focusable elements
     * - Supports both forward (Tab) and backward (Shift+Tab) navigation
     * - Only activates when modal is visible
     * - Prevents focus from leaving the modal
     *
     * @wcag Meets WCAG AAA requirements for focus management
     */
    function setupFocusTrap(element: Element): void {
      element.addEventListener("keydown", (e: Event) => {
        const keyboardEvent = e as KeyboardEvent;

        // Only trap focus when modal is visible
        if (
          elements.overlay.classList.contains("hidden") ||
          elements.overlay.getAttribute("aria-hidden") === "true"
        ) {
          return;
        }

        if (keyboardEvent.key !== "Tab") {
          return;
        }

        const focusableElements = getFocusableElements(element);
        if (focusableElements.length === 0) {
          return;
        }

        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];

        if (keyboardEvent.shiftKey && document.activeElement === firstElement) {
          keyboardEvent.preventDefault();
          lastElement.focus();
        } else if (!keyboardEvent.shiftKey && document.activeElement === lastElement) {
          keyboardEvent.preventDefault();
          firstElement.focus();
        }
      });
    }

    /**
     * Event handler for keyboard navigation, specifically Escape key to close modal
     *
     * @param {KeyboardEvent} e - Keyboard event object
     *
     * @accessibility
     * - Provides keyboard escape mechanism as required by WCAG AAA
     * - Only responds when modal is visible
     * - Prevents default browser behavior for consistent UX
     *
     * @performance Uses efficient event delegation pattern
     */
    function handleKeydown(e: KeyboardEvent): void {
      if (e.key === "Escape" && !elements.overlay.classList.contains("hidden")) {
        e.preventDefault();
        hideOverlay();
      }
    }

    /**
     * Event handler for showing the chronology feedback overlay
     *
     * @param {CustomEvent} e - Custom event containing feedback details
     *
     * @accessibility
     * - Shows overlay with proper focus management
     * - Updates screen reader announcements via live regions
     * - Manages button visibility with proper ARIA attributes
     * - Announces result to assistive technologies
     *
     * @performance
     * - Efficiently updates DOM elements in batch
     * - Uses CSS classes for visibility management
     * - Minimal DOM queries through cached elements
     *
     * @wcag Meets WCAG AAA requirements for feedback and navigation
     */
    function handleShowFeedback(e: CustomEvent): void {
      const detail = e.detail as FeedbackEventDetail;

      showOverlay();
      updateFeedbackContent(detail);

      // Manage button visibility with proper accessibility
      if (detail.isLastRound) {
        elements.endButton.classList.remove("hidden");
        elements.endButton.removeAttribute("aria-hidden");
      } else {
        elements.endButton.classList.add("hidden");
        elements.endButton.setAttribute("aria-hidden", "true");
      }

      // Screen reader announcement for immediate feedback
      if (elements.statusAnnouncer) {
        elements.statusAnnouncer.textContent = detail.isCorrect
          ? getTranslation("game.chronology.correct")
          : getTranslation("game.chronology.incorrect");
      }
    }

    /**
     * Event handler for the continue button click
     *
     * @accessibility
     * - Properly hides overlay with focus restoration
     * - Dispatches semantic event for game continuation
     * - Maintains keyboard navigation flow
     *
     * @performance Uses efficient event dispatching pattern
     * @wcag Meets WCAG AAA requirements for user control
     */
    function handleContinue(): void {
      hideOverlay();
      window.dispatchEvent(new CustomEvent("chronologyContinue"));
    }

    /**
     * Event handler for the end game button click
     *
     * @accessibility
     * - Properly hides overlay with focus restoration
     * - Dispatches semantic event for game termination
     * - Maintains keyboard navigation flow
     *
     * @performance Uses efficient event dispatching pattern
     * @wcag Meets WCAG AAA requirements for user control
     */
    function handleEnd(): void {
      hideOverlay();
      window.dispatchEvent(new CustomEvent("chronologyEnd"));
    }

    /**
     * Sets up all event listeners for the chronology feedback overlay
     *
     * @accessibility
     * - Configures keyboard navigation and focus trap
     * - Sets up modal controls with proper event handling
     * - Enables escape key functionality for overlay dismissal
     * - Ensures all interactive elements are keyboard accessible
     *
     * @performance
     * - Uses efficient event delegation patterns
     * - Caches element references to avoid repeated DOM queries
     * - Optimizes event listener setup for minimal overhead
     *
     * @features
     * - Modal control events (close, continue, end)
     * - Global keyboard navigation (Escape key)
     * - Custom event listening for game state changes
     * - Session management integration
     * - Focus trap for accessibility compliance
     *
     * @wcag Meets WCAG AAA requirements for keyboard navigation and user control
     */
    function setupEventListeners(): void {
      // Modal control events with semantic action handlers
      elements.closeButton.addEventListener("click", hideOverlay);
      elements.backdrop.addEventListener("click", hideOverlay);
      elements.continueButton.addEventListener("click", handleContinue);
      elements.endButton.addEventListener("click", handleEnd);

      // Global keyboard navigation events
      document.addEventListener("keydown", handleKeydown);
      window.addEventListener("showChronologyFeedback", handleShowFeedback as EventListener);

      // Focus trap setup for accessibility compliance
      setupFocusTrap(elements.overlay);

      // Make session manager extend function available globally for future UI implementations
      (window as typeof window & { extendChronologySession: () => void }).extendChronologySession =
        (): void => {
          sessionManager.extend();
        };
    }

    /**
     * Cleanup function to remove event listeners and clear timeouts
     *
     * @accessibility
     * - Properly removes all accessibility-related event listeners
     * - Clears focus state and restores previous focus if needed
     * - Ensures no orphaned event handlers remain active
     *
     * @performance
     * - Cancels any pending animation frames or timeouts
     * - Stops session timeout monitoring to free resources
     * - Removes all event listeners to prevent memory leaks
     * - Resets component state for potential reuse
     *
     * @usage Called automatically on page unload or manually when component is destroyed
     * @wcag Ensures proper cleanup for assistive technology compatibility
     */
    function cleanup(): void {
      // Clear any pending animations or timeouts to prevent memory leaks
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }

      // Stop session timeout monitoring and free resources
      sessionManager.cleanup();

      // Remove event listeners - all elements are guaranteed to exist in this scope
      elements.closeButton.removeEventListener("click", hideOverlay);
      elements.backdrop.removeEventListener("click", hideOverlay);
      elements.continueButton.removeEventListener("click", handleContinue);
      elements.endButton.removeEventListener("click", handleEnd);
      document.removeEventListener("keydown", handleKeydown);
      window.removeEventListener("showChronologyFeedback", handleShowFeedback as EventListener);

      // Reset component state for potential reuse
      previouslyFocused = null;
    }

    // Initialize event listeners and component state
    setupEventListeners();

    // Start session timeout monitoring for WCAG AAA compliance
    sessionManager.start();

    // Cleanup on page unload to prevent memory leaks and maintain performance
    window.addEventListener("beforeunload", cleanup);
    window.addEventListener("pagehide", cleanup);

    // Return cleanup function for manual cleanup if needed
    return cleanup;
  }

  /**
   * Initialize the chronology feedback overlay when DOM is ready
   *
   * @performance Uses efficient DOM ready detection to minimize initialization delay
   * @accessibility Ensures all accessibility features are set up before user interaction
   */
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initFeedbackOverlay);
  } else {
    initFeedbackOverlay();
  }
</script>
