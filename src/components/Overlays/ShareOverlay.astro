---
/**
 * ShareOverlay Component
 *
 * A high-performance sharing component that provides multiple ways to share game results
 * with advanced multilingual support and accessibility features.
 *
 * Features responsive design, native Web Share API integration, platform-specific sharing,
 * and comprehensive error handling with fallback options.
 *
 * @component
 * @example
 * <ShareOverlay gameData={gameData} />
 * <ShareOverlay gameData={gameData} showTitle={false} />
 * <ShareOverlay shareGroupLabel="Custom share buttons" showFallback={false} />
 */

import { Icon } from "astro-icon/components";
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import type { ShareData } from "@utils/share/shareUtils";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

/**
 * Props for the ShareOverlay component
 * @interface Props
 * @property {ShareData} [gameData] - Game data to share (if not provided, component will attempt to extract from DOM)
 * @property {string} [shareGroupLabel] - Custom aria-label for the share buttons group
 * @property {boolean} [showFallback] - Whether to show fallback content when no game data is available
 * @property {boolean} [showTitle] - Whether to show the component title
 */
export interface Props {
  /** Game data to share - if not provided, component will attempt to extract from DOM */
  gameData?: ShareData;
  /** Custom aria-label for the share buttons group */
  shareGroupLabel?: string;
  /** Whether to show fallback content when no game data is available */
  showFallback?: boolean;
  /** Whether to show the title */
  showTitle?: boolean;
}

const {
  gameData,
  shareGroupLabel = t("share.buttons.group.label"),
  showFallback = true,
  showTitle = true,
} = Astro.props;
---

<div class="mt-8 text-center md:mt-12" data-game-data={gameData ? JSON.stringify(gameData) : ""}>
  {
    showTitle && (
      <Headline
        level="h3"
        textSize="lg"
        className="mb-6 text-xl font-semibold text-[var(--text-primary)] md:text-2xl md:mb-8 lg:text-3xl"
      >
        {t("share.title")}
      </Headline>
    )
  }

  <!-- Status announcer for screen readers -->
  <div id="share-status-announcer" aria-live="polite" aria-atomic="true" class="sr-only"></div>

  <div
    id="share-buttons-container"
    class="mt-6 flex max-w-full flex-wrap items-center justify-center gap-4 md:mx-auto md:mt-8 md:max-w-[600px] md:flex-row md:gap-6 lg:max-w-[700px] lg:gap-8"
    role="group"
    aria-label={shareGroupLabel}
  >
    <!-- Native Web Share API Button (hidden by default, shown when supported) -->
    <button
      id="native-share-button"
      class="share-overlay__button share-overlay__button--native share-overlay__button--hidden flex items-center gap-3 rounded-lg bg-[var(--color-primary-600)] px-6 py-3 font-medium text-white transition-all duration-200 hover:bg-[var(--color-primary-700)] focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-[var(--focus-outline)]"
      aria-label={t("share.native")}
      type="button"
    >
      <Icon
        name="share"
        width={24}
        height={24}
        class="h-6 w-6 flex-shrink-0 transition-transform duration-200 md:h-6 md:w-6"
        aria-hidden="true"
      />
      <span class="text-base md:text-sm">{t("share.native.label")}</span>
    </button>

    <!-- Twitter/X Share -->
    <button
      class="flex items-center gap-3 rounded-lg bg-[var(--color-gray-600)] px-6 py-3 font-medium text-white transition-all duration-200 hover:bg-[var(--color-gray-700)] focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-[var(--focus-outline)]"
      data-share="twitter"
      aria-label={t("share.twitter")}
      type="button"
    >
      <Icon
        name="twitter"
        width={24}
        height={24}
        class="h-6 w-6 flex-shrink-0 transition-transform duration-200 md:h-6 md:w-6"
        aria-hidden="true"
      />
      <span class="text-base md:text-sm">{t("share.twitter")}</span>
    </button>

    <!-- WhatsApp Share -->
    <button
      class="flex items-center gap-3 rounded-lg bg-[var(--color-green-600)] px-6 py-3 font-medium text-white transition-all duration-200 hover:bg-[var(--color-green-700)] focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-[var(--focus-outline)]"
      data-share="whatsapp"
      aria-label={t("share.whatsapp")}
      type="button"
    >
      <Icon
        name="whatsapp"
        width={24}
        height={24}
        class="h-6 w-6 flex-shrink-0 transition-transform duration-200 md:h-6 md:w-6"
        aria-hidden="true"
      />
      <span class="text-base md:text-sm">{t("share.whatsapp")}</span>
    </button>

    <!-- Email Share -->
    <button
      class="flex items-center gap-3 rounded-lg bg-[var(--color-orange-600)] px-6 py-3 font-medium text-white transition-all duration-200 hover:bg-[var(--color-orange-700)] focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-[var(--focus-outline)]"
      data-share="email"
      aria-label={t("share.email")}
      type="button"
    >
      <Icon
        name="mail"
        width={24}
        height={24}
        class="h-6 w-6 flex-shrink-0 transition-transform duration-200 md:h-6 md:w-6"
        aria-hidden="true"
      />
      <span class="text-base md:text-sm">{t("share.email.label")}</span>
    </button>
  </div>

  <!-- Copy to Clipboard Button -->
  <div class="mt-6 flex justify-center md:mt-8">
    <button
      id="copy-share-button"
      class="flex items-center gap-3 rounded-lg bg-[var(--color-pink-600)] px-6 py-3 font-medium text-white transition-all duration-200 hover:bg-[var(--color-pink-700)] focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-[var(--focus-outline)]"
      aria-label={t("share.copy")}
      type="button"
    >
      <Icon
        name="clipboard"
        width={20}
        height={20}
        class="h-5 w-5 flex-shrink-0 transition-transform duration-200"
        aria-hidden="true"
      />
      <span class="text-base md:text-sm" id="copy-button-text">{t("share.copy.label")}</span>
    </button>
  </div>

  <!-- Fallback Content when Game Data is Unavailable -->
  {
    showFallback && (
      <div
        id="share-fallback-content"
        class="mt-6 rounded-lg border border-[var(--border-subtle)] bg-[var(--bg-tertiary)] p-4"
        style="display: none;"
      >
        <div class="mb-4 flex items-center gap-3">
          <Icon
            name="alert-circle"
            width={24}
            height={24}
            class="flex-shrink-0 text-[var(--color-warning-500)]"
            aria-hidden="true"
          />
          <Paragraph className="text-[var(--text-secondary)]">
            {t("share.fallback.message")}
          </Paragraph>
        </div>
        <div class="flex justify-center gap-3">
          <button
            id="retry-share-button"
            class="flex items-center gap-2 rounded-lg bg-[var(--color-primary-600)] px-4 py-2 text-sm font-medium text-white transition-all duration-200 hover:bg-[var(--color-primary-700)] focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-[var(--focus-outline)]"
            type="button"
            aria-label={t("share.fallback.retry.label")}
          >
            <Icon name="refresh" width={16} height={16} class="flex-shrink-0" aria-hidden="true" />
            {t("share.fallback.retry.text")}
          </button>
          <button
            id="manual-copy-button"
            class="flex items-center gap-2 rounded-lg border border-[var(--border-primary)] bg-[var(--bg-secondary)] px-4 py-2 text-sm font-medium text-[var(--text-primary)] transition-all duration-200 hover:bg-[var(--bg-tertiary)] focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-[var(--focus-outline)]"
            type="button"
            aria-label={t("share.fallback.manual.label")}
          >
            <Icon
              name="clipboard"
              width={16}
              height={16}
              class="flex-shrink-0"
              aria-hidden="true"
            />
            {t("share.fallback.manual.text")}
          </button>
        </div>
      </div>
    )
  }
</div>

<script
  is:inline
  define:vars={{
    // Share accessibility translations
    shareAccessibilityDataUnavailable: t("share.accessibility.data_unavailable"),
    shareAccessibilityRetrying: t("share.accessibility.retrying"),
    shareAccessibilityDataFound: t("share.accessibility.data_found"),
    shareAccessibilityDataStillUnavailable: t("share.accessibility.data_still_unavailable"),
    shareAccessibilityRetryFailed: t("share.accessibility.retry_failed"),
    shareAccessibilityLinkCopiedFallback: t("share.accessibility.link_copied_fallback"),
    shareAccessibilityCopyFailedManual: t("share.accessibility.copy_failed_manual"),
    shareAccessibilityScoreShared: t("share.accessibility.score_shared"),
    shareAccessibilitySharingCancelled: t("share.accessibility.sharing_cancelled"),
    shareAccessibilityPlatformShareFailed: t("share.accessibility.platform_share_failed"),
    shareAccessibilityTryAlternativeMethods: t("share.accessibility.try_alternative_methods"),
    shareAccessibilityScoreCopied: t("share.accessibility.score_copied"),
    shareAccessibilityNativeShareFailed: t("share.accessibility.native_share_failed"),
    shareAccessibilityTryPlatformButtons: t("share.accessibility.try_platform_buttons"),
    shareAccessibilityPlatformOpened: t("share.accessibility.platform_opened"),

    // Additional localized strings for UI interactions (used by the inline script)
    // Use existing concise keys where appropriate and derive short labels locally.
    copyButtonOriginalText: t("share.copy.label"),
    // simple visual prefix for copied state (kept as a constant but can be localized if needed)
    copyButtonCopiedPrefix: "✓",
    // short fallback prompt for manual share/copy actions
    fallbackSharePrompt: t("share.title"),

    // Localized error & recovery strings used by getErrorMessage/getRecoveryMessage
    shareErrorNoData: t("share.accessibility.data_unavailable"),
    shareErrorClipboardFailed: t("share.accessibility.copy_failed_manual"),
    shareErrorPermissionDenied: t("share.accessibility.native_share_failed"),
    shareRecoveryAlternative: t("share.accessibility.try_alternative_methods"),
    shareRecoveryPlatformButtons: t("share.accessibility.try_platform_buttons"),
    shareErrorGeneric: t("share.accessibility.platform_share_failed"),

    // Localized snippets used for social share fallback text
    shareEmailSubject: t("share.email.subject"),
    // shareScoreLine was removed (unused) to satisfy linting. Use runtime helpers to format score lines when needed.
    shareChallenge: t("share.challenge"),

    // Achievement labels (localized when available)
    shareAchievementGenius: t("share.achievement.genius"),
    shareAchievementPro: t("share.achievement.pro"),
    shareAchievementEnthusiast: t("share.achievement.enthusiast"),
    shareAchievementLover: t("share.achievement.lover"),
    shareAchievementExplorer: t("share.achievement.explorer"),

    // Difficulty emoji (allow overriding via locales if desired)
    shareDifficultyEmojiEasy: t("share.difficulty_emoji.easy"),
    shareDifficultyEmojiMedium: t("share.difficulty_emoji.medium"),
    shareDifficultyEmojiHard: t("share.difficulty_emoji.hard"),
    shareDifficultyEmojiDefault: t("share.difficulty_emoji.default"),

    // Short challenge fallback text variable (script expects shareChallengeText)
    shareChallengeText: t("share.challenge"),
  }}
>
  /* eslint-disable @typescript-eslint/explicit-function-return-type */
  // The inline share script contains many small helper functions and DOM-oriented code.
  // Adding explicit return types everywhere would be noisy; we selectively disable the rule
  // for this file and keep focused refactors for complexity in future commits.

  /**
   * ShareOverlay Component Enhancement Script
   *
   * Provides comprehensive sharing functionality with accessibility features.
   * Supports native Web Share API, platform-specific sharing, and clipboard operations.
   */

  /**
   * Error types for comprehensive error handling
   * @enum {string}
   */
  const ShareErrorType = {
    NO_DATA: "NO_DATA",
    CLIPBOARD_FAILED: "CLIPBOARD_FAILED",
    NATIVE_SHARE_FAILED: "NATIVE_SHARE_FAILED",
    PLATFORM_SHARE_FAILED: "PLATFORM_SHARE_FAILED",
    NETWORK_ERROR: "NETWORK_ERROR",
    PERMISSION_DENIED: "PERMISSION_DENIED",
  };

  /**
   * Cached DOM element references for performance optimization
   * @type {Object}
   */
  const elements = {
    nativeShareButton: null,
    copyButton: null,
    copyButtonText: null,
    statusAnnouncer: null,
    shareButtons: null,
    fallbackContent: null,
    retryButton: null,
    manualCopyButton: null,
  };

  /**
   * UI interaction constants for consistent behavior
   * @type {Object}
   */
  const UI_CONSTANTS = {
    COPY_SUCCESS_DURATION: 2000,
    COPY_ORIGINAL_TEXT: "",
    ANIMATION_DURATION: 200,
  };

  function logShare(...args) {
    try {
      if (window.__mmDebug) {
        window.__mmDebug("shareOverlay", ...args);
      } else if (console && console.warn) {
        console.warn("[shareOverlay]", ...args);
      }
    } catch {
      /* silent */
    }
  }

  /**
   * getPopupElement
   * Returns the first matching end-game popup element from known selectors.
   * Isolated to allow future selector adjustments in one place.
   */
  function getPopupElement() {
    return (
      document.querySelector("#endgame-popup") ||
      document.querySelector("#end-overlay") ||
      document.querySelector(".popup[data-score]")
    );
  }

  /**
   * extractPopupScore
   * Attempts to parse the current score from DOM content or data attributes.
   * Returns null if no valid non-negative integer found.
   */
  function extractPopupScore(popup) {
    try {
      const scoreEl = popup.querySelector("#popup-score");
      if (scoreEl && scoreEl.textContent) {
        const val = parseInt(scoreEl.textContent, 10);
        if (!isNaN(val) && val >= 0) {
          return val;
        }
      }
      const attr = popup.getAttribute("data-score");
      if (attr) {
        const val2 = parseInt(attr, 10);
        if (!isNaN(val2) && val2 >= 0) {
          return val2;
        }
      }
    } catch {
      /* ignore */
    }
    return null;
  }

  function validateGameDataPrimitive(score, category, difficulty) {
    if (typeof score !== "number" || score < 0) {
      return false;
    }
    if (!category || typeof category !== "string" || !category.trim()) {
      return false;
    }
    if (!difficulty || typeof difficulty !== "string" || !difficulty.trim()) {
      return false;
    }
    if (!["easy", "medium", "hard", "mixed"].includes(difficulty.toLowerCase())) {
      return false;
    }
    return true;
  }

  // Helper: compute achievement label from numeric score
  /**
   * computeAchievementLabel
   * Maps a numeric score to a localized achievement label. Prefers centralized
   * resolver (window.__resolveAchievement) but falls back to resilient static
   * thresholds for robustness when the helper is missing.
   */
  const computeAchievementLabel = (numericScore) => {
    // Dynamic import to avoid bundling if unused elsewhere; cached after first call
    // We replicate minimal logic to map tier id to localized var to stay inline-friendly
    const mapTierToLabel = (id) => {
      switch (id) {
        case "genius":
          return shareAchievementGenius || "\ud83c\udfb5 Music Genius! \ud83c\udfb5";
        case "pro":
          return shareAchievementPro || "\ud83c\udfa7 Music Pro! \ud83c\udfa7";
        case "enthusiast":
          return shareAchievementEnthusiast || "\ud83c\udfb8 Music Enthusiast! \ud83c\udfb8";
        case "lover":
          return shareAchievementLover || "\ud83c\udfb9 Music Lover! \ud83c\udfb9";
        default:
          return shareAchievementExplorer || "\ud83c\udfbc Music Explorer! \ud83c\udfbc";
      }
    };

    try {
      // Attempt to use centralized utility if available
      if (window.__resolveAchievement) {
        const tier = window.__resolveAchievement(numericScore);
        if (tier && tier.id) {
          return mapTierToLabel(tier.id);
        }
      }
    } catch {
      // Silently fallback to local computation below
    }

    // Fallback to static thresholds (kept intentionally minimal) if utility not injected.
    // Intentional duplication of numeric ladder for resilience if global helper fails.
    if (numericScore >= 800) {
      return mapTierToLabel("genius");
    }
    if (numericScore >= 600) {
      return mapTierToLabel("pro");
    }
    if (numericScore >= 400) {
      return mapTierToLabel("enthusiast");
    }
    if (numericScore >= 200) {
      return mapTierToLabel("lover");
    }
    return mapTierToLabel("explorer");
  };

  // Helper: map difficulty to emoji (localized overrides supported)
  /**
   * getDifficultyEmoji
   * Returns a semantic emoji representation of difficulty (localized override
   * aware). Provides a neutral default if input is missing.
   */
  const getDifficultyEmoji = (diffText) => {
    if (!diffText || typeof diffText !== "string") {
      return shareDifficultyEmojiDefault || "\u26aa\ufe0f";
    }
    const d = diffText.toLowerCase();
    if (d === "easy") {
      return shareDifficultyEmojiEasy || "\ud83d\udfe2";
    }
    if (d === "medium") {
      return shareDifficultyEmojiMedium || "\ud83d\udfe1";
    }
    if (d === "hard") {
      return shareDifficultyEmojiHard || "\ud83d\udd34";
    }
    return shareDifficultyEmojiDefault || "\u26aa\ufe0f";
  };

  // Note: programmatic clipboard copy is handled inline where needed using
  // navigator.clipboard.writeText; legacy execCommand-based fallbacks were removed
  // to avoid deprecated API usage.

  // Initialize the sharing functionality
  /**
   * initializeSharing
   * Bootstraps all share overlay features (cache refs, feature detect, attach
   * event handlers, attempt game data resolution).
   */
  const initializeSharing = async () => {
    cacheElements();

    if (!elements.statusAnnouncer || !elements.copyButton) {
      logShare("Required elements not found");
      return;
    }

    UI_CONSTANTS.COPY_ORIGINAL_TEXT =
      elements.copyButtonText && elements.copyButtonText.textContent
        ? elements.copyButtonText.textContent
        : "";

    initializeNativeSharing();
    initializeClipboardCopy();
    initializePlatformSharing();
    initializeFallbackHandlers();

    // Try to validate game data with retries
    await validateGameDataWithRetries();
  };

  // Validate game data with retries
  /**
   * validateGameDataWithRetries
   * Repeatedly attempts to acquire valid share data (DOM may not be populated
   * on first pass). Falls back to showing the manual copy UI if acquisition
   * ultimately fails.
   */
  const validateGameDataWithRetries = async () => {
    const maxRetries = 5;
    const retryDelay = 500;

    for (let i = 0; i < maxRetries; i++) {
      const gameData = getGameDataFromProps() || getGameDataFromPopup();

      if (gameData && isValidShareData(gameData)) {
        try {
          if (typeof console !== "undefined" && typeof console.warn === "function") {
            logShare("Game data validation successful");
          }
        } catch {
          /* ignore logging errors */
        }
        return;
      }

      if (i < maxRetries - 1) {
        await new Promise((resolve) => setTimeout(resolve, retryDelay));
      }
    }

    logShare("Validation failed after retries");
    showFallbackContent();
  };

  // Get game data from component props
  /**
   * getGameDataFromProps
   * Parses any serialized share data passed via component props, then prefers
   * the live score extracted from the overlay (authoritative) if present.
   */
  const getGameDataFromProps = () => {
    const overlay = document.querySelector(".share-overlay");
    if (!overlay) {
      return null;
    }

    const propsData = overlay.getAttribute("data-game-data");
    if (!propsData) {
      return null;
    }

    try {
      const data = JSON.parse(propsData);

      // Always prefer the current score from DOM over props
      const popup =
        document.querySelector("#endgame-popup") ||
        document.querySelector("#end-overlay") ||
        document.querySelector(".popup[data-score]");
      if (popup) {
        const currentScore = popup.querySelector("#popup-score");
        if (currentScore && currentScore.textContent) {
          const score = parseInt(currentScore.textContent, 10);
          if (!isNaN(score)) {
            data.score = score;
          }
        }
        const scoreAttr = popup.getAttribute("data-score");
        if (scoreAttr) {
          const scoreFromAttr = parseInt(scoreAttr, 10);
          if (!isNaN(scoreFromAttr)) {
            data.score = scoreFromAttr;
          }
        }
      }
      return data;
    } catch (error) {
      logShare("Error parsing props data", error);
      return null;
    }
  };

  // Validate share data
  /**
   * isValidShareData
   * Structural validation for share payload to guard against malformed DOM
   * derived objects.
   */
  const isValidShareData = (data) => {
    if (!data || typeof data !== "object") {
      return false;
    }

    // Check score
    if (typeof data.score !== "number" || data.score < 0) {
      return false;
    }

    // Check category
    if (!data.category || typeof data.category !== "string" || data.category.trim().length === 0) {
      return false;
    }

    // Check difficulty
    if (
      !data.difficulty ||
      typeof data.difficulty !== "string" ||
      data.difficulty.trim().length === 0
    ) {
      return false;
    }

    const validDifficulties = ["easy", "medium", "hard", "mixed"];
    if (data.difficulty && !validDifficulties.includes(data.difficulty.toLowerCase())) {
      return false;
    }

    return true;
  };

  // Show fallback content
  /** Show fallback UI when valid game data cannot be resolved. */
  const showFallbackContent = () => {
    if (!elements.fallbackContent) {
      return;
    }

    const shareContainer = document.getElementById("share-buttons-container");
    const clipboardSection = document.querySelector(".share-overlay__clipboard-section");

    if (shareContainer) {
      shareContainer.style.display = "none";
    }
    if (clipboardSection) {
      clipboardSection.style.display = "none";
    }

    elements.fallbackContent.style.display = "block";
    announceToScreenReader(shareAccessibilityDataUnavailable);
  };

  // Hide fallback content
  /** Hide the fallback UI and reveal main sharing controls. */
  const hideFallbackContent = () => {
    if (!elements.fallbackContent) {
      return;
    }

    const shareContainer = document.getElementById("share-buttons-container");
    const clipboardSection = document.querySelector(".share-overlay__clipboard-section");

    if (shareContainer) {
      shareContainer.style.display = "flex";
    }
    if (clipboardSection) {
      clipboardSection.style.display = "block";
    }

    elements.fallbackContent.style.display = "none";
  };

  // Initialize fallback handlers
  /** Wire up retry & manual copy buttons inside the fallback block. */
  const initializeFallbackHandlers = () => {
    if (elements.retryButton) {
      elements.retryButton.addEventListener("click", handleRetryAction);
    }

    if (elements.manualCopyButton) {
      elements.manualCopyButton.addEventListener("click", handleManualCopyAction);
    }
  };

  // Handle retry action
  /** Attempt another pass at data extraction after a delay. */
  const handleRetryAction = async () => {
    if (!elements.retryButton) {
      return;
    }

    elements.retryButton.disabled = true;
    announceToScreenReader(shareAccessibilityRetrying);

    try {
      await new Promise((resolve) => setTimeout(resolve, 500));

      const gameData = getGameDataFromProps() || getGameDataFromPopup();

      if (gameData && isValidShareData(gameData)) {
        hideFallbackContent();
        announceToScreenReader(shareAccessibilityDataFound);
      } else {
        announceToScreenReader(shareAccessibilityDataStillUnavailable);
      }
    } catch (error) {
      logShare("Error during retry", error);
      announceToScreenReader(shareAccessibilityRetryFailed);
    } finally {
      elements.retryButton.disabled = false;
    }
  };

  // Handle manual copy action
  /** Manual copy fallback for environments lacking full share features. */
  const handleManualCopyAction = async () => {
    if (!elements.manualCopyButton) {
      return;
    }

    elements.manualCopyButton.disabled = true;

    try {
      // Use a localized short prompt for fallback copy text
      const fallbackText = `${fallbackSharePrompt} ${window.location.href}`;
      await copyTextFallback(fallbackText);
      announceToScreenReader(shareAccessibilityLinkCopiedFallback);

      // Update button text temporarily with a localized original text prefixed by a visual indicator
      const originalText = elements.manualCopyButton.textContent;
      elements.manualCopyButton.textContent = `${copyButtonCopiedPrefix} ${originalText || copyButtonOriginalText}`;
      setTimeout(() => {
        if (elements.manualCopyButton && originalText) {
          elements.manualCopyButton.textContent = originalText;
        }
      }, 2000);
    } catch (error) {
      logShare("Manual copy failed", error);
      announceToScreenReader(shareAccessibilityCopyFailedManual);
    } finally {
      elements.manualCopyButton.disabled = false;
    }
  };

  // Fallback copy method
  /** Copy text via Clipboard API or report failure (no execCommand fallback). */
  const copyTextFallback = async (text) => {
    if (navigator.clipboard && window.isSecureContext) {
      try {
        await navigator.clipboard.writeText(text);
        return;
      } catch (error) {
        logShare("Clipboard API failed, fallback", error);
        throw error; // Let callers show manual fallback UI
      }
    }

    // No reliable programmatic fallback available without document.execCommand;
    // signal failure so callers can show manual copy instructions/UI.
    throw new Error("Clipboard API unavailable");
  };

  // Cache DOM elements
  /** Cache frequently accessed DOM elements (single traversal). */
  const cacheElements = () => {
    elements.nativeShareButton = document.getElementById("native-share-button");
    elements.copyButton = document.getElementById("copy-share-button");
    elements.copyButtonText = document.getElementById("copy-button-text");
    elements.statusAnnouncer = document.getElementById("share-status-announcer");
    elements.shareButtons = document.querySelectorAll("[data-share]");
    elements.fallbackContent = document.getElementById("share-fallback-content");
    elements.retryButton = document.getElementById("retry-share-button");
    elements.manualCopyButton = document.getElementById("manual-copy-button");
  };

  // Initialize native sharing
  /** Setup native Web Share API button when available. */
  const initializeNativeSharing = () => {
    const nativeShareSupported = "share" in navigator;

    if (!nativeShareSupported || !elements.nativeShareButton) {
      return;
    }

    elements.nativeShareButton.classList.remove("share-overlay__button--hidden");
    elements.nativeShareButton.classList.add("share-overlay__button--visible");

    elements.nativeShareButton.addEventListener("click", async (event) => {
      const button = event.currentTarget;

      if (button.hasAttribute("disabled")) {
        return;
      }

      button.setAttribute("disabled", "disabled");

      try {
        const gameData = getGameDataFromProps() || getGameDataFromPopup();
        if (!gameData || !isValidShareData(gameData)) {
          await handleNativeShareError(ShareErrorType.NO_DATA, button);
          return;
        }

        const shareText = await generateAdvancedShareText(gameData);
        const shareData = {
          title: "Melody Mind Music Quiz",
          text: shareText,
          url: window.location.href,
        };

        if (navigator.canShare && !navigator.canShare(shareData)) {
          throw new Error("Share data not supported by this device");
        }

        await navigator.share(shareData);
        announceToScreenReader(shareAccessibilityScoreShared);
      } catch (err) {
        if (err.name === "AbortError") {
          announceToScreenReader(shareAccessibilitySharingCancelled);
        } else if (err.name === "NotAllowedError") {
          await handleNativeShareError(ShareErrorType.PERMISSION_DENIED, button, err);
        } else {
          await handleNativeShareError(ShareErrorType.NATIVE_SHARE_FAILED, button, err);
        }
      } finally {
        button.removeAttribute("disabled");
      }
    });
  };

  // Handle native share errors
  /** Announce & react to native share errors; may trigger fallback UI. */
  const handleNativeShareError = async (errorType, _button, error) => {
    console.warn(`Native share error (${errorType}):`, error);

    const errorMessage = getErrorMessage(errorType);
    const recoveryMessage = getRecoveryMessage(errorType);

    announceToScreenReader(
      shareAccessibilityNativeShareFailed
        .replace("{errorMessage}", errorMessage)
        .replace("{recoveryMessage}", recoveryMessage)
    );

    if (errorType === ShareErrorType.NO_DATA) {
      setTimeout(() => {
        showFallbackContent();
      }, 1000);
    } else if (
      errorType === ShareErrorType.PERMISSION_DENIED ||
      errorType === ShareErrorType.NATIVE_SHARE_FAILED
    ) {
      announceToScreenReader(shareAccessibilityTryPlatformButtons);

      if (elements.copyButton) {
        elements.copyButton.style.border = "2px solid var(--color-warning-400)";
        setTimeout(() => {
          if (elements.copyButton) {
            elements.copyButton.style.border = "";
          }
        }, 3000);
      }
    }
  };

  // Initialize platform sharing
  /** Attach unified click delegation for platform-specific share buttons. */
  const initializePlatformSharing = () => {
    if (!elements.shareButtons || !elements.shareButtons.length) {
      return;
    }

    document.addEventListener("click", async (event) => {
      const target = event.target;
      const button = target.closest("[data-share]");

      if (!button) {
        return;
      }

      event.preventDefault();

      if (button.hasAttribute("disabled")) {
        return;
      }

      const platform = button.getAttribute("data-share");
      if (!platform) {
        return;
      }

      button.setAttribute("disabled", "disabled");

      try {
        const gameData = getGameDataFromProps() || getGameDataFromPopup();
        if (!gameData || !isValidShareData(gameData)) {
          await handlePlatformShareError(ShareErrorType.NO_DATA, platform, button);
          return;
        }

        const shareText = await generateAdvancedShareText(gameData);
        const shareUrl = createShareUrl(platform, shareText);

        if (shareUrl) {
          window.open(shareUrl, "_blank", "width=600,height=400");
          announceToScreenReader(shareAccessibilityPlatformOpened.replace("{platform}", platform));
        } else {
          throw new Error(`Unsupported platform: ${platform}`);
        }
      } catch (err) {
        await handlePlatformShareError(ShareErrorType.PLATFORM_SHARE_FAILED, platform, button, err);
      } finally {
        setTimeout(() => {
          button.removeAttribute("disabled");
        }, 1000);
      }
    });
  };

  // Create platform-specific share URLs
  /** Build a platform-specific outbound share URL (Twitter / WhatsApp / Email). */
  const createShareUrl = (platform, text) => {
    const encodedText = encodeURIComponent(text);
    const encodedUrl = encodeURIComponent(window.location.href);

    switch (platform) {
      case "twitter":
        return `https://twitter.com/intent/tweet?text=${encodedText}&url=${encodedUrl}`;
      case "whatsapp":
        return `https://wa.me/?text=${encodedText}%20${encodedUrl}`;
      case "email":
        return `mailto:?subject=${encodeURIComponent(shareEmailSubject)}&body=${encodedText}%0A%0A${encodedUrl}`;
      default:
        return null;
    }
  };

  // Generate advanced multilingual share text using shareUtils

  /**
   * generateAdvancedShareText
   * Attempts dynamic import of advanced share text builder; falls back to a
   * compact inline implementation if unavailable (resilience-first design).
   */
  const generateAdvancedShareText = async (data) => {
    const { score, category, difficulty } = data || {};
    const currentLang = document.documentElement.lang || "en";

    try {
      // Import the generateShareTextForLanguage function from shareUtils
      const { generateShareTextForLanguage } = await import("/src/utils/share/shareUtils.ts");
      return generateShareTextForLanguage(data, currentLang);
    } catch (error) {
      logShare("Import shareUtils failed, fallback", error);

      // Fallback implementation for compatibility — use compact helpers to keep complexity low
      const numericScore = typeof score === "number" ? score : 0;
      const catText = typeof category === "string" ? category : "Unknown";
      const diffText = typeof difficulty === "string" ? difficulty : "mixed";

      const achievement = computeAchievementLabel(numericScore);
      const difficultyEmoji = getDifficultyEmoji(diffText);

      const scoreText = `I scored ${numericScore} points in Melody Mind's ${catText} quiz (${difficultyEmoji} ${diffText})!`;
      const challenge =
        typeof shareChallengeText !== "undefined" && shareChallengeText
          ? shareChallengeText
          : typeof shareChallenge !== "undefined"
            ? shareChallenge
            : "";

      return `${achievement}\n\n${scoreText}\n\n${challenge}`;
    }
  };

  // Handle platform share errors
  /** Announce & react to platform share errors (non-native path). */
  const handlePlatformShareError = async (errorType, platform, _button, error) => {
    console.warn(`Platform share error for ${platform} (${errorType}):`, error);

    const errorMessage = getErrorMessage(errorType);
    const recoveryMessage = getRecoveryMessage(errorType);

    announceToScreenReader(
      shareAccessibilityPlatformShareFailed
        .replace("{platform}", platform)
        .replace("{errorMessage}", errorMessage)
        .replace("{recoveryMessage}", recoveryMessage)
    );

    if (errorType === ShareErrorType.NO_DATA) {
      setTimeout(() => {
        showFallbackContent();
      }, 1000);
    } else {
      announceToScreenReader(shareAccessibilityTryAlternativeMethods);
    }

    if (elements.copyButton) {
      const originalBorder = elements.copyButton.style.border;
      elements.copyButton.style.border = "2px solid var(--color-info-400)";
      setTimeout(() => {
        if (elements.copyButton) {
          elements.copyButton.style.border = originalBorder;
        }
      }, 3000);
    }
  };

  // Initialize clipboard copy
  /** Setup clipboard copy logic (primary quick-share path). */
  const initializeClipboardCopy = () => {
    if (!elements.copyButton || !elements.copyButtonText) {
      return;
    }

    const originalCopyText = UI_CONSTANTS.COPY_ORIGINAL_TEXT;
    if (!originalCopyText) {
      return;
    }

    elements.copyButton.addEventListener("click", async (event) => {
      const button = event.currentTarget;

      if (button.hasAttribute("disabled")) {
        return;
      }

      button.setAttribute("disabled", "disabled");

      try {
        const gameData = getGameDataFromProps() || getGameDataFromPopup();
        if (!gameData || !isValidShareData(gameData)) {
          await handleClipboardError(ShareErrorType.NO_DATA, button, originalCopyText);
          return;
        }

        const shareText = await generateAdvancedShareText(gameData);
        const shareUrl = window.location.href;
        const fullText = `${shareText}\n\n${shareUrl}`;

        if (navigator.clipboard && navigator.clipboard.writeText) {
          try {
            await navigator.clipboard.writeText(fullText);
          } catch (clipboardError) {
            console.warn("Modern clipboard failed, trying fallback:", clipboardError);
            await copyTextFallback(fullText);
          }
        } else {
          await copyTextFallback(fullText);
        }

        if (elements.copyButtonText) {
          // Use the original localized text stored earlier and prefix it with a concise visual indicator
          elements.copyButtonText.textContent = `${copyButtonCopiedPrefix} ${originalCopyText}`;
        }
        button.classList.add("share-overlay__clipboard-button--success");

        announceToScreenReader(shareAccessibilityScoreCopied);

        setTimeout(() => {
          if (elements.copyButtonText) {
            elements.copyButtonText.textContent = originalCopyText;
          }
          button.classList.remove("share-overlay__clipboard-button--success");
          button.removeAttribute("disabled");
        }, UI_CONSTANTS.COPY_SUCCESS_DURATION);
      } catch (err) {
        await handleClipboardError(ShareErrorType.CLIPBOARD_FAILED, button, originalCopyText, err);
      }
    });
  };

  // Handle clipboard errors
  /** Provide user feedback and recovery guidance for clipboard failures. */
  const handleClipboardError = async (errorType, button, originalText, error) => {
    console.warn(`Clipboard error (${errorType}):`, error);

    if (elements.copyButtonText) {
      elements.copyButtonText.textContent = getErrorMessage(errorType);
    }
    button.classList.add("share-overlay__clipboard-button--error");

    const errorMessage = getErrorMessage(errorType);
    const recoveryMessage = getRecoveryMessage(errorType);
    announceToScreenReader(
      shareAccessibilityNativeShareFailed
        .replace("{errorMessage}", errorMessage)
        .replace("{recoveryMessage}", recoveryMessage)
    );

    if (errorType === ShareErrorType.NO_DATA) {
      setTimeout(() => {
        showFallbackContent();
      }, 1000);
    }

    setTimeout(() => {
      if (elements.copyButtonText) {
        elements.copyButtonText.textContent = originalText;
      }
      button.classList.remove("share-overlay__clipboard-button--error");
      button.removeAttribute("disabled");
    }, UI_CONSTANTS.COPY_SUCCESS_DURATION / 2);
  };

  // Get user-friendly error messages (localized)
  /** Map internal error type to localized user-friendly string. */
  const getErrorMessage = (errorType) => {
    switch (errorType) {
      case ShareErrorType.NO_DATA:
        return shareErrorNoData;
      case ShareErrorType.CLIPBOARD_FAILED:
        return shareErrorClipboardFailed;
      case ShareErrorType.PERMISSION_DENIED:
        // This key may include placeholders in some locales; it is used here as a best-effort localized message.
        return shareErrorPermissionDenied || shareErrorNoData;
      default:
        return shareErrorGeneric || shareErrorClipboardFailed;
    }
  };

  // Get recovery guidance messages (localized)
  /** Map error type to a localized recovery suggestion. */
  const getRecoveryMessage = (errorType) => {
    switch (errorType) {
      case ShareErrorType.NO_DATA:
        return shareRecoveryAlternative;
      case ShareErrorType.CLIPBOARD_FAILED:
        return shareRecoveryAlternative;
      case ShareErrorType.PERMISSION_DENIED:
        return shareRecoveryPlatformButtons;
      default:
        return shareRecoveryAlternative;
    }
  };

  // Announce messages to screen readers (prefer global #app-live-region, fallback to local)
  /** Announce a status message using global or local polite live region. */
  const announceToScreenReader = (message) => {
    if (!message) {
      return;
    }
    const region = document.getElementById("app-live-region") || elements.statusAnnouncer;
    if (!region) {
      return;
    }
    try {
      region.textContent = "";
      try {
        if (typeof window !== "undefined") {
          const w = window; // plain JS context
          // optional runtime helper injected elsewhere
          if (w && typeof w.mmForceReflow === "function") {
            w.mmForceReflow(region);
          } else {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            region.offsetHeight; // fallback direct reflow trigger
          }
        }
      } catch {
        /* silent */
      }
      region.textContent = message;
      setTimeout(() => {
        try {
          if (region.dataset.fallbackLiveRegion !== undefined) {
            region.textContent = "";
          }
        } catch {
          /* ignore */
        }
      }, 5000);
    } catch {
      /* ignore */
    }
  };

  // Extract game data from popup element (refactored to helpers to reduce complexity)
  /** Extract structured share data directly from the end overlay popup. */
  const getGameDataFromPopup = () => {
    const popup = getPopupElement();
    if (!popup) {
      return null;
    }
    try {
      const score = extractPopupScore(popup);
      const categoryAttr = popup.getAttribute("data-category");
      const difficultyAttr = popup.getAttribute("data-difficulty");
      if (!categoryAttr || !difficultyAttr) {
        logShare("Missing data attrs on popup");
        return null;
      }
      if (score === null) {
        logShare("Invalid score value", score);
        return null;
      }
      if (!categoryAttr.trim() || !difficultyAttr.trim()) {
        logShare("Empty category/difficulty");
        return null;
      }
      const gameData = { score, category: categoryAttr.trim(), difficulty: difficultyAttr.trim() };
      if (!validateGameDataPrimitive(gameData.score, gameData.category, gameData.difficulty)) {
        logShare("Game data failed validation", gameData);
        return null;
      }
      return gameData;
    } catch (error) {
      logShare("Error extracting game data", error);
      return null;
    }
  };

  // Initialize sharing features when the EndOverlay is actually shown
  /** Lazy initialize sharing only after end overlay becomes visible. */
  const initializeOnEndOverlayShow = () => {
    // Wait for the EndOverlay to be visible before initializing
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "attributes" && mutation.attributeName === "class") {
          const popup = mutation.target;
          if (popup && popup.classList && !popup.classList.contains("hidden")) {
            try {
              logShare("EndOverlay visible - init ShareOverlay");
            } catch {
              /* ignore */
            }
            initializeSharing().catch(function (e) {
              try {
                logShare("Initialization error", e);
              } catch (err) {
                void err;
              }
            });
            observer.disconnect(); // Stop observing once initialized
          }
        }
      });
    });

    // Find the EndOverlay element to observe
    const endOverlay =
      document.querySelector("#endgame-popup") ||
      document.querySelector("#end-overlay") ||
      document.querySelector(".popup[data-score]");

    if (endOverlay) {
      observer.observe(endOverlay, {
        attributes: true,
        attributeFilter: ["class"],
      });
    } else {
      // Fallback: initialize after a short delay if no popup found
      setTimeout(() => {
        initializeSharing().catch(function (e) {
          logShare("Delayed init error", e);
        });
      }, 1000);
    }
  };

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeOnEndOverlayShow);
  } else {
    initializeOnEndOverlayShow();
  }
</script>
