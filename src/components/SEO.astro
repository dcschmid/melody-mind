---
/**
 * SEO Component for MelodyMind
 *
 * This component manages all SEO-related meta tags, structured data,
 * and accessibility improvements for better page indexing and user experience.
 * It follows WCAG AAA standards for content and provides proper language support.
 *
 * @component
 * @example
 * ```astro
 * <SEO
 *   title="Rock Music Quiz"
 *   description="Test your knowledge of classic rock hits"
 *   type="game"
 * />
 * ```
 */
import { getLangFromUrl } from "@utils/i18n";
import { languages } from "../i18n/ui"; // Direct relative path instead of alias
import type { StructuredData } from "@utils/seo/buildPageSeo";

interface Props {
  /** Page title - will be appended with site name */
  title: string;
  /** Page description - important for SEO and accessibility */
  description?: string;
  /** Keywords for search engines */
  keywords?: string;
  /** Path to OpenGraph/social share image (absolute or relative) */
  image?: string;
  /** Content type classification */
  type?: "website" | "article" | "music" | "game" | "podcastEpisode";
  /** Explicit width of OpenGraph image (optional) */
  imageWidth?: number;
  /** Explicit height of OpenGraph image (optional) */
  imageHeight?: number;
  /** Publication date - important for articles/content */
  publishDate?: Date;
  /** Last modification date - helps with SEO freshness signals */
  modifiedDate?: Date;
  /** Path to audio content - used for music schema */
  audioSrc?: string;
  /** Content section category - used for article schema */
  section?: string;
  /** Music-specific OpenGraph meta tags */
  ogMusic?: {
    creator?: string;
    album?: string;
    musician?: string;
  };
  /** Episode number for podcast episodes (1-based) */
  episodeNumber?: number;
  /** Name of the podcast series the episode belongs to */
  seriesName?: string;
  /** URL of the podcast series landing page */
  seriesUrl?: string;
  /** Approximate audio duration in seconds (optional) */
  /** Optional custom canonical URL override */
  canonical?: string;
  /** Provide breadcrumb trail */
  breadcrumbs?: Array<{ name: string; url: string }>;
  /** Robots noindex flag */
  noIndex?: boolean;
  /** Robots nofollow flag */
  noFollow?: boolean;
  /** Pagination previous rel */
  prevUrl?: string;
  /** Pagination next rel */
  nextUrl?: string;
  /** Disable alternate language generation */
  disableAlternateLanguages?: boolean;
  /** Additional structured data object(s) */
  structuredDataExtra?: StructuredData | StructuredData[];
  /** Override author/publisher name */
  authorName?: string;
}

const {
  title,
  description = "Melody Mind - The Musical Quiz Game",
  keywords = "Music, Quiz, Game, Cover, Entertainment",
  image = "/social-share.jpg",
  imageWidth,
  imageHeight,
  type = "website",
  publishDate,
  modifiedDate,
  audioSrc,
  section = "game",
  ogMusic,
  episodeNumber,
  seriesName = "MelodyMind Podcast",
  seriesUrl,
  canonical,
  breadcrumbs,
  noIndex = false,
  noFollow = false,
  prevUrl,
  nextUrl,
  disableAlternateLanguages = false,
  structuredDataExtra,
  authorName = "Melody Mind Team",
} = Astro.props as Props;

// Defensive date validation – ensure we never call toISOString on an invalid Date
const isValidDate = (d: unknown): d is Date => d instanceof Date && !isNaN(d.getTime());
const safePublishDate = isValidDate(publishDate) ? publishDate : undefined;
const safeModifiedDate = isValidDate(modifiedDate) ? modifiedDate : undefined;

const lang = String(getLangFromUrl(Astro.url));
const canonicalURL = canonical
  ? new URL(canonical, Astro.site || "https://melody-mind.de")
  : new URL(Astro.url.pathname, Astro.site);
const imageURL = new URL(image, Astro.site);
const siteUrl = Astro.site?.toString() || "https://melody-mind.de";

// Improved URL handling for hreflang tags
const alternateLanguages = disableAlternateLanguages
  ? []
  : Object.keys(languages).map((langCode) => {
      // Safer method to replace language in URL path
      let path = Astro.url.pathname;

      // If current path starts with /{lang}/, replace only that part
      const langPathRegex = new RegExp(`^/${String(lang)}/`);
      if (langPathRegex.test(path)) {
        path = path.replace(langPathRegex, `/${langCode}/`);
      } else {
        // Fallback for different URL structures
        path = `/${langCode}${path.startsWith("/") ? path : `/${path}`}`;
      }

      const url = new URL(path, Astro.site || siteUrl);
      return { langCode, url: url.toString() };
    });

/**
 * JSON-LD structured data with TypeScript type safety
 * Follows schema.org standards for better search engine interpretation
 */
// Reuse global StructuredData type from SEO builder for consistency

// Base website schema
let structuredData: StructuredData = {
  "@context": "https://schema.org",
  "@type": "WebSite",
  name: "Melody Mind",
  url: siteUrl,
  description: description,
  potentialAction: {
    "@type": "SearchAction",
    target: {
      "@type": "EntryPoint",
      urlTemplate: `${siteUrl}${String(lang)}/search?q={search_term_string}`,
    },
    "query-input": "required name=search_term_string",
  },
  inLanguage: String(lang),
  author: {
    "@type": "Organization",
    name: "Melody Mind Team",
  },
  accessibilityControl: ["fullKeyboardControl", "fullMouseControl", "fullTouchControl"],
  accessibilityFeature: ["alternativeText", "highContrast", "structuralNavigation"],
};

// Enhanced structured data based on page type
if (type === "article") {
  structuredData = {
    "@context": "https://schema.org",
    "@type": "Article",
    headline: title, // Use headline for Article schema (not name)
    description: description,
    image: imageURL.toString(),
    // Only include dates if valid; fallback to build date only if neither provided
    ...(safePublishDate && { datePublished: safePublishDate.toISOString() }),
    ...(safeModifiedDate && { dateModified: safeModifiedDate.toISOString() }),
    ...(!safePublishDate &&
      !safeModifiedDate && {
        datePublished: new Date().toISOString(),
        dateModified: new Date().toISOString(),
      }),
    author: {
      "@type": "Organization",
      name: "Melody Mind Team",
    },
    publisher: {
      "@type": "Organization",
      name: "Melody Mind",
      logo: {
        "@type": "ImageObject",
        url: new URL("/melody-mind.png", Astro.site || siteUrl).toString(),
        width: 192,
        height: 192,
      },
    },
    mainEntityOfPage: {
      "@type": "WebPage",
      "@id": canonicalURL.toString(),
    },
    inLanguage: String(lang),
    articleSection: section,
    accessibilityControl: ["fullKeyboardControl", "fullMouseControl", "fullTouchControl"],
    accessibilityFeature: ["alternativeText", "highContrast", "structuralNavigation"],
  };
} else if (type === "music") {
  structuredData = {
    "@context": "https://schema.org",
    "@type": "MusicGroup",
    name: title,
    description: description,
    image: imageURL.toString(),
    url: canonicalURL.toString(),
    audio: audioSrc ? new URL(audioSrc, Astro.site || siteUrl).toString() : null,
    inLanguage: String(lang),
    accessibilityControl: ["fullKeyboardControl", "fullMouseControl", "fullTouchControl"],
    accessibilityFeature: ["alternativeText", "highContrast", "structuralNavigation"],
  };
} else if (type === "game") {
  structuredData = {
    "@context": "https://schema.org",
    "@type": "Game",
    name: "Melody Mind",
    description: description,
    genre: "Music Quiz",
    audience: {
      "@type": "Audience",
      audienceType: "Music lovers",
    },
    inLanguage: String(lang),
    accessibilityControl: ["fullKeyboardControl", "fullMouseControl", "fullTouchControl"],
    accessibilityFeature: ["alternativeText", "highContrast", "structuralNavigation"],
  };
} else if (type === "podcastEpisode") {
  // Podcast Episode structured data (centralized – replaces per-page schema scripts)
  structuredData = {
    "@context": "https://schema.org",
    "@type": "PodcastEpisode",
    name: title,
    headline: title,
    description,
    url: canonicalURL.toString(),
    isAccessibleForFree: true,
    inLanguage: String(lang),
    datePublished: safePublishDate ? safePublishDate.toISOString() : undefined,
    dateModified: safeModifiedDate ? safeModifiedDate.toISOString() : undefined,
    episodeNumber: episodeNumber ?? undefined,
    image: imageURL.toString(),
    partOfSeries: {
      "@type": "PodcastSeries",
      name: seriesName,
      url: seriesUrl || `https://podcasts.melody-mind.de/${String(lang)}`,
    },
    author: {
      "@type": "Organization",
      name: "Melody Mind Team",
    },
    publisher: {
      "@type": "Organization",
      name: "Melody Mind",
      logo: {
        "@type": "ImageObject",
        url: new URL("/melody-mind.png", Astro.site || siteUrl).toString(),
        width: 192,
        height: 192,
      },
    },
    ...(audioSrc && {
      audio: {
        "@type": "AudioObject",
        url: new URL(audioSrc, Astro.site || siteUrl).toString(),
        encodingFormat: "audio/mpeg",
        // duration intentionally omitted (feature removed)
      },
    }),
    accessibilityControl: ["fullKeyboardControl", "fullMouseControl", "fullTouchControl"],
    accessibilityFeature: ["alternativeText", "highContrast", "structuralNavigation"],
  } as StructuredData;
}

// ---------------------------------------------------------------------------
// Global persistent Organization & WebSite entities
// Always injected so Google / Knowledge Graph can consistently associate
// page-level entities (Article, PodcastEpisode, Game, etc.) with the brand.
// We skip adding the global WebSite if the primary structuredData already is
// a WebSite instance to avoid duplication.
// ---------------------------------------------------------------------------
const globalOrganizationSchema: StructuredData = {
  "@context": "https://schema.org",
  "@type": "Organization",
  name: "Melody Mind",
  url: siteUrl,
  logo: {
    "@type": "ImageObject",
    url: new URL("/melody-mind.png", Astro.site || siteUrl).toString(),
    width: 192,
    height: 192,
  },
  sameAs: ["https://twitter.com/melodymindgame", "https://github.com/dcschmid/melody-mind"],
};

const globalWebsiteSchema: StructuredData = {
  "@context": "https://schema.org",
  "@type": "WebSite",
  name: "Melody Mind",
  url: siteUrl,
  description: description,
  inLanguage: String(lang),
  potentialAction: {
    "@type": "SearchAction",
    target: {
      "@type": "EntryPoint",
      urlTemplate: `${siteUrl}${String(lang)}/search?q={search_term_string}`,
    },
    "query-input": "required name=search_term_string",
  },
};

// Generate concise page title with site name (prefix podcast episodes for clarity)
const siteName = "Melody Mind";
const pageTitle =
  type === "podcastEpisode" ? `${title} | Podcast | ${siteName}` : `${title} | ${siteName}`;

// Breadcrumb structured data
let breadcrumbSchema: StructuredData | undefined;
if (Array.isArray(breadcrumbs) && breadcrumbs.length) {
  const safeItems = breadcrumbs
    .filter((b) => b && b.name && b.url)
    .map((b, i) => ({ "@type": "ListItem", position: i + 1, name: b.name, item: b.url }));
  if (safeItems.length) {
    breadcrumbSchema = {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: safeItems,
    };
  }
}

// Merge extra structured data
const extraSchemas: StructuredData[] = Array.isArray(structuredDataExtra)
  ? structuredDataExtra
  : structuredDataExtra
    ? [structuredDataExtra]
    : [];
const structuredGraph = [structuredData]
  // Add global WebSite if current primary node is not a WebSite itself
  .concat(structuredData["@type"] !== "WebSite" ? [globalWebsiteSchema] : [])
  // Always add Organization (brand entity)
  .concat([globalOrganizationSchema])
  .concat(breadcrumbSchema ? [breadcrumbSchema] : [])
  .concat(extraSchemas);

// Calculate critical resources for preloading
type CriticalResource = { as: string; href: string; type: string; crossorigin?: boolean };
const criticalResources: CriticalResource[] = [
  { as: "image", href: "/favicon.svg", type: "image/svg+xml", crossorigin: true },
];
---

<!-- Primary Meta Tags -->
<title>{pageTitle}</title>
<meta name="title" content={pageTitle} />
<meta name="description" content={description} />
<meta name="keywords" content={keywords} />
<meta name="author" content={authorName} />
<meta
  name="robots"
  content={`${noIndex ? "noindex" : "index"}, ${noFollow ? "nofollow" : "follow"}`}
/>
<meta name="language" content={String(lang)} />

<!-- Canonical URL -->
<link rel="canonical" href={canonicalURL} />
{prevUrl && <link rel="prev" href={prevUrl} />}
{nextUrl && <link rel="next" href={nextUrl} />}

<!-- Hreflang Tags for Internationalization -->
{
  !disableAlternateLanguages &&
    alternateLanguages.map(({ langCode, url }) => (
      <link rel="alternate" href={url} hreflang={langCode} />
    ))
}
{!disableAlternateLanguages && <link rel="alternate" href={canonicalURL} hreflang="x-default" />}

<!-- Open Graph / Facebook -->
<meta
  property="og:type"
  content={type === "article" ? "article" : type === "podcastEpisode" ? "article" : "website"}
/>
<meta property="og:url" content={canonicalURL} />
<meta property="og:title" content={pageTitle} />
<meta property="og:description" content={description} />
<meta property="og:image" content={imageURL} />
{imageWidth && <meta property="og:image:width" content={String(imageWidth)} />}
{imageHeight && <meta property="og:image:height" content={String(imageHeight)} />}
<meta property="og:image:alt" content={`Melody Mind - ${title}`} />
<meta property="og:locale" content={String(lang).replace("-", "_")} />
{
  alternateLanguages
    .filter(({ langCode }) => langCode !== String(lang))
    .map(({ langCode }) => (
      <meta property="og:locale:alternate" content={String(langCode).replace("-", "_")} />
    ))
}
<meta property="og:site_name" content="Melody Mind" />
{
  safePublishDate && (
    <meta property="article:published_time" content={safePublishDate.toISOString()} />
  )
}
{
  safeModifiedDate && (
    <meta property="article:modified_time" content={safeModifiedDate.toISOString()} />
  )
}
{section && <meta property="article:section" content={section} />}
{
  type === "podcastEpisode" && audioSrc && (
    <meta property="og:audio" content={new URL(audioSrc, Astro.site || siteUrl).toString()} />
  )
}
{type === "podcastEpisode" && audioSrc && <meta property="og:audio:type" content="audio/mpeg" />}
{
  type === "podcastEpisode" && episodeNumber && (
    <meta name="podcast:episode_number" content={String(episodeNumber)} />
  )
}
{type === "podcastEpisode" && <meta name="podcast:series" content={seriesName} />}
{
  // podcast:duration meta removed
}

<!-- Music-specific OpenGraph tags -->
{ogMusic?.creator && <meta property="og:music:creator" content={ogMusic.creator} />}
{ogMusic?.album && <meta property="og:music:album" content={ogMusic.album} />}
{ogMusic?.musician && <meta property="og:music:musician" content={ogMusic.musician} />}

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={canonicalURL} />
<meta property="twitter:title" content={pageTitle} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={imageURL} />
<meta name="twitter:image:alt" content={`Melody Mind - ${title}`} />
<meta name="twitter:site" content="@melodymindgame" />
<meta name="twitter:creator" content="@melodymindgame" />

<!-- Performance: Resource Hints -->
<link rel="preconnect" href={new URL(imageURL).origin} crossorigin />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link rel="dns-prefetch" href="https://fonts.gstatic.com" />

<!-- Performance: Preload Critical Resources -->
{
  criticalResources.map((resource) => (
    <link
      rel="preload"
      as={resource.as}
      href={resource.href}
      type={resource.type}
      crossorigin={resource.crossorigin ? "anonymous" : undefined}
    />
  ))
}

<!-- Mobile App Integration -->
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="application-name" content="Melody Mind" />
<meta name="theme-color" content="#18181b" />

<!-- Structured Data / JSON-LD - Compressed for performance -->
<script
  is:inline
  type="application/ld+json"
  set:html={JSON.stringify(structuredGraph.length === 1 ? structuredGraph[0] : structuredGraph)}
/>

<!-- Favicons with explicit sizes for better performance -->
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<link rel="manifest" href="/site.webmanifest" />

<!-- Generator -->
<meta name="generator" content={Astro.generator} />
