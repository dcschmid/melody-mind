---
import { getLangFromUrl, useTranslations } from "@utils/i18n";

interface Props {
  size?: "small" | "medium" | "large";
  label?: string;
  id?: string;
}

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

const {
  size = "large",
  label = t("loading.content"),
  id = "loading-spinner",
} = Astro.props;

const sizeClasses = {
  small: "w-6 h-6 border-2",
  medium: "w-12 h-12 border-3",
  large: "w-16 h-16 border-4",
};
---

<div
  class="hidden flex items-center justify-center min-h-12 p-4 spinnerContainer"
  id={id}
  role="status"
  aria-live="polite"
  aria-busy="false"
  data-testid="loading-spinner"
>
  <div
    class={`relative rounded-full border-zinc-700 border-t-sky-500 animate-spin motion-reduce:animate-none ${sizeClasses[size]}`}
    aria-hidden="true"
    data-size={size}
  >
    <span
      class="absolute inset-0 rounded-full border-t-sky-500 border-transparent opacity-50 -m-[2px]"
    ></span>
  </div>
  <span class="sr-only">{label}</span>
</div>

<style>
  /* Kompatibilitätsklasse für JS */
  .spinnerContainer.hidden {
    display: none;
  }

  [data-size] {
    animation: custom-spin 1s linear infinite;
  }

  [data-size] span {
    animation: custom-spin 2s linear infinite;
  }

  /* Feinere Animation-Kontrolle */
  @keyframes custom-spin {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }
</style>

<script>
  /**
   * LoadingSpinner - A class to manage loading spinner visibility and state
   * 
   * This utility class provides methods to show/hide loading spinners and properly
   * manage their ARIA attributes for accessibility. It implements a singleton pattern
   * per spinner ID to ensure consistent state management across the application.
   * 
   * @example
   * // Show a spinner
   * LoadingSpinner.getInstance().show();
   * 
   * // Hide the same spinner
   * LoadingSpinner.getInstance().hide();
   * 
   * // Use a specific spinner by ID
   * LoadingSpinner.getInstance('custom-spinner').show();
   */
  class LoadingSpinner {
    /** Reference to the spinner DOM element */
    private readonly spinner: HTMLElement | null;
    
    /** Store of all spinner instances by ID for singleton pattern */
    private static instances: Map<string, LoadingSpinner> = new Map();
    
    /**
     * Creates a new LoadingSpinner instance
     * 
     * @param {string} id - The ID of the spinner element to control
     */
    constructor(id: string = "loading-spinner") {
      this.spinner = document.getElementById(id);
      
      // Register this instance
      LoadingSpinner.instances.set(id, this);
      
      // Log an error if spinner not found, but don't block execution
      if (!this.spinner) {
        console.warn(`LoadingSpinner: Element with ID "${id}" not found in DOM`);
      }
    }

    /**
     * Gets a singleton instance of LoadingSpinner for the specified ID
     * 
     * @param {string} id - The ID of the spinner to control
     * @returns {LoadingSpinner} A spinner instance for the specified ID
     */
    static getInstance(id: string = "loading-spinner"): LoadingSpinner {
      return this.instances.get(id) || new LoadingSpinner(id);
    }

    /**
     * Shows the spinner and updates its accessibility attributes
     * 
     * @returns {boolean} True if successful, false if spinner element not found
     */
    show(): boolean {
      if (!this.spinner) return false;
      
      // Make visible and update accessibility
      this.spinner.classList.remove("hidden");
      this.spinner.setAttribute("aria-busy", "true");
      
      return true;
    }

    /**
     * Hides the spinner and updates its accessibility attributes
     * 
     * @returns {boolean} True if successful, false if spinner element not found
     */
    hide(): boolean {
      if (!this.spinner) return false;
      
      // Hide and update accessibility
      this.spinner.classList.add("hidden");
      this.spinner.setAttribute("aria-busy", "false");
      
      return true;
    }

    /**
     * Toggles the spinner visibility based on current state
     * 
     * @returns {boolean} New visibility state (true = shown, false = hidden)
     */
    toggle(): boolean {
      if (!this.spinner) return false;
      
      const isCurrentlyHidden = this.spinner.classList.contains("hidden");
      return isCurrentlyHidden ? this.show() : this.hide();
    }
    
    /**
     * Checks if the spinner is currently visible
     * 
     * @returns {boolean} True if the spinner is visible, false otherwise
     */
    isVisible(): boolean {
      return this.spinner ? !this.spinner.classList.contains("hidden") : false;
    }
    
    /**
     * Shows the spinner for a specific duration, then hides it
     * 
     * @param {number} durationMs - Duration in milliseconds to show the spinner
     * @returns {Promise<void>} Promise that resolves when spinner is hidden
     */
    async showFor(durationMs: number): Promise<void> {
      this.show();
      
      return new Promise(resolve => {
        setTimeout(() => {
          this.hide();
          resolve();
        }, durationMs);
      });
    }
  }

  // Expose the LoadingSpinner to the global scope for use in other scripts
  declare global {
    interface Window {
      LoadingSpinner: typeof LoadingSpinner;
    }
  }

  window.LoadingSpinner = LoadingSpinner;
</script>
