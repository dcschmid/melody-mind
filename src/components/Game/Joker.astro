---
/**
 * Joker Component
 *
 * A fully accessible component for the 50:50 joker feature in MelodyMind.
 * Allows users to eliminate two wrong answers during gameplay.
 * Uses CSS custom properties for consistent styling and WCAG AAA compliance.
 *
 * Features:
 * - WCAG AAA compliant accessibility
 * - Responsive design with mobile-first approach
 * - Screen reader announcements
 * - Visual feedback with animations
 * - Internationalization support
 */
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import { Icon } from "astro-icon/components";
import Headline from "@components/Headline.astro";

interface Props {
  initialCount?: number;
  disabled?: boolean;
}

const { initialCount = 0, disabled = false } = Astro.props;

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

const jokerButtonAriaLabel = t("game.joker.use");
const jokerTitle = t("game.joker.options");
const jokerText = t("game.joker");
const jokerDescription = t("game.joker.description");
const remainingText = t("game.remaining");

const dataAttributes = {
  initialCount: initialCount.toString(),
  initialDisabled: disabled.toString(),
  langCode: lang,
};
---

<div
  class="relative p-8 flex flex-col items-center gap-6 rounded-[var(--radius-xl)] border-[var(--border-width-thick)] border-[var(--border-primary)] bg-[var(--card-bg)] shadow-[var(--shadow-lg)] transition-all duration-300 hover:shadow-[var(--shadow-xl)] hover:border-[var(--border-secondary)]"
  role="group"
  aria-labelledby="joker-title"
  data-testid="joker-container"
  {...dataAttributes}
>
  <Headline level="h2" textSize="lg">
    {jokerTitle}
  </Headline>

  <div class="relative" data-joker-button-wrapper>
    <button
      id="joker-button"
      type="button"
      class="inline-flex items-center justify-center border-none rounded-[var(--radius-lg)] font-bold no-underline cursor-pointer relative min-w-[var(--min-touch-size)] min-h-[var(--min-touch-size)] leading-[var(--leading-normal)] tracking-[var(--letter-spacing-base)] font-[var(--font-family-primary)] px-4 py-3 text-base bg-gradient-to-r from-purple-600 to-purple-700 text-white border border-transparent shadow-lg transition-all duration-300 hover:from-purple-700 hover:to-purple-800 hover:shadow-xl focus-visible:outline focus-visible:outline-2 focus-visible:outline-purple-500 focus-visible:outline-offset-2 disabled:opacity-50 disabled:cursor-not-allowed disabled:pointer-events-none disabled:filter-grayscale"
      aria-label={jokerButtonAriaLabel}
      aria-describedby="joker-description joker-count"
      data-joker-type="fifty-fifty"
      {disabled}
    >
      <Icon
        name="star"
        class="w-[var(--icon-size-sm)] h-[var(--icon-size-sm)] flex-shrink-0 mr-4 text-yellow-300"
        aria-hidden="true"
      />
      {jokerText}
    </button>
  </div>

  <div id="joker-count-container" class="flex items-center gap-3">
    <span
      id="joker-count"
      class="font-medium leading-[var(--leading-normal)] min-w-[var(--touch-target-enhanced)] min-h-[var(--touch-target-enhanced)] rounded-full border-2 border-purple-500 bg-gradient-to-r from-purple-900 to-purple-800 px-3 py-3 text-center text-[var(--text-xl)] text-white font-tabular-nums transition-all duration-300 hover:from-purple-800 hover:to-purple-700 hover:border-purple-400 hover:shadow-lg"
      aria-live="polite"
      aria-atomic="true"
    >
      {initialCount}
      {remainingText}
    </span>
  </div>

  <div
    id="joker-description"
    class="mt-6 max-w-[var(--grid-min-width-md)] text-center text-[var(--text-lg)] text-[var(--text-tertiary)] leading-[var(--leading-relaxed)] tracking-[var(--letter-spacing-base)]"
  >
    {jokerDescription}
  </div>

  <div id="joker-announcement" class="sr-only" aria-live="assertive" aria-atomic="true"></div>
</div>

<script is:inline>
  const createAnnouncementTexts = (lang, currentCount) => {
    const announcements = {
      de: `50:50 Joker verwendet. Noch ${currentCount} Joker verfügbar.`,
      en: `50:50 Joker used. ${currentCount} jokers remaining.`,
      es: `Comodín 50:50 utilizado. Quedan ${currentCount} comodines.`,
      fr: `Joker 50:50 utilisé. ${currentCount} jokers restants.`,
      it: `Jolly 50:50 utilizzato. ${currentCount} jolly rimanenti.`,
      pt: `Curinga 50:50 usado. ${currentCount} curingas restantes.`,
      da: `50:50 joker brugt. ${currentCount} jokere tilbage.`,
      nl: `50:50 joker gebruikt. ${currentCount} jokers resterend.`,
      sv: `50:50 joker använd. ${currentCount} jokrar kvar.`,
      fi: `50:50-jokeri käytetty. ${currentCount} jokeria jäljellä.`,
    };
    return announcements[lang] || announcements.en;
  };

  const initJoker = () => {
    const container = document.querySelector('[data-testid="joker-container"]');
    if (!container) {
      return;
    }

    const initialCount = parseInt(container.getAttribute("data-initial-count") || "0", 10);
    const initialDisabled = container.getAttribute("data-initial-disabled") === "true";
    const lang = container.getAttribute("data-lang-code") || "en";

    const elements = {
      button: document.getElementById("joker-button"),
      counter: document.getElementById("joker-count"),
      container: container,
      announcement: document.getElementById("joker-announcement"),
    };

    if (!elements.button || !elements.counter) {
      console.warn("Joker component: Required elements not found");
      return;
    }

    if (initialDisabled) {
      elements.button.disabled = true;
    }

    if (initialCount > 0) {
      elements.counter.textContent = initialCount.toString();
    }

    setupButtonEvents(elements, lang);
    setupCounterObserver(elements);
  };

  const setupButtonEvents = (elements, lang) => {
    if (!elements.button) {
      return;
    }

    let clickTimeout = null;
    let canTrigger = true;

    const handleJokerClick = (_e) => {
      if (elements.button?.disabled || !canTrigger || clickTimeout) {
        return;
      }

      canTrigger = false;

      dispatchJokerEvent(elements, lang);

      if (elements.button) {
        elements.button.disabled = true;
      }

      clickTimeout = setTimeout(() => {
        if (elements.button && !elements.button.hasAttribute("data-permanently-disabled")) {
          elements.button.disabled = false;
        }
        clickTimeout = null;
        canTrigger = true;
      }, 800);
    };

    elements.button.addEventListener("click", handleJokerClick);

    elements.button.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        handleJokerClick(e);
      }
    });
  };

  const dispatchJokerEvent = (elements, lang) => {
    const { button } = elements;
    if (!button) {
      return;
    }

    try {
      const jokerEvent = new CustomEvent("jokerUsed", {
        bubbles: true,
        detail: {
          jokerType: button.dataset.jokerType || "fifty-fifty",
          timestamp: Date.now(),
        },
      });

      document.dispatchEvent(jokerEvent);
      announceJokerUsage(elements, lang);
    } catch (error) {
      console.warn("Error dispatching jokerUsed event:", error);
    }
  };

  const setupCounterObserver = (elements) => {
    const { counter } = elements;
    if (!counter) {
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          setupMutation();
        }
      },
      { threshold: 0.1 }
    );

    observer.observe(counter);

    const setupMutation = () => {
      const mutationObs = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "childList" && counter) {
            counter.classList.remove("updated");
            void counter.offsetWidth;
            counter.classList.add("updated");
          }
        });
      });

      if (counter) {
        mutationObs.observe(counter, { childList: true });
      }
    };
  };

  const announceJokerUsage = (elements, lang) => {
    const { counter, announcement } = elements;

    const announcementEl =
      announcement ||
      (() => {
        const el = document.createElement("div");
        el.id = "joker-announcement";
        el.setAttribute("aria-live", "assertive");
        el.setAttribute("aria-atomic", "true");
        el.className = "sr-only";
        document.body.appendChild(el);
        return el;
      })();

    const currentCount = counter?.textContent?.trim() || "0";

    announcementEl.textContent = createAnnouncementTexts(lang, currentCount);

    setTimeout(() => {
      announcementEl.textContent = "";
    }, 3000);
  };

  const updateJokerCount = (count, disable = false) => {
    const counter = document.getElementById("joker-count");
    const button = document.getElementById("joker-button");

    if (counter) {
      counter.textContent = count.toString();
    }

    if (button) {
      if (disable || count <= 0) {
        button.disabled = true;
        if (count <= 0) {
          button.setAttribute("data-permanently-disabled", "true");
        }
      } else {
        button.disabled = false;
        button.removeAttribute("data-permanently-disabled");
      }
    }
  };

  window.MelodyMind = window.MelodyMind || {};
  window.MelodyMind.updateJokerCount = updateJokerCount;

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initJoker);
  } else {
    initJoker();
  }
</script>
