---
/**
 * @component AchievementBadge
 * @description Displays a badge for new achievements in the navigation.
 * Appears when new achievements are unlocked and shows a count.
 * @accessibility
 * - Uses high contrast colors meeting WCAG AAA standards (7:1 ratio)
 * - Supports reduced motion preferences
 * - Implements proper ARIA attributes for screen readers
 * - Touch target size of 44x44px (1.5rem) for mobile accessibility
 * @performance
 * - Uses specific property transitions instead of "all"
 * - Implements requestAnimationFrame for DOM updates
 * - Includes print media query to hide non-essential content
 * @i18n Uses translation keys for all user-facing text
 */

// 1. Imports
import { useTranslations } from "../../utils/i18n.ts";

// 2. Props definition
interface Props {
  /** Language code for translations */
  lang: string;
}

// 3. Props processing
const { lang } = Astro.props;
const t = useTranslations(lang);

// 4. Additional variables for client-side script
const newLabel = t("achievements.badge.new");
const newLabelWithCount = t("achievements.badge.new_with_count");
const fallbackLabel = t("achievements.badge.fallback_text");
---

<!-- 4. Component template with semantic HTML -->
<span
  id="achievement-badge"
  class="achievement-badge"
  aria-label={newLabel}
  role="status"
  aria-live="polite"
  data-new-label={newLabel}
  data-new-label-with-count={newLabelWithCount}
  data-fallback-label={fallbackLabel}
>
  <span class="achievement-badge__count">0</span>
</span>

<!-- 5. Component styles with CSS -->
<style>
  .achievement-badge {
    /* Use global CSS variables from global.css */
    position: absolute;
    inset-block-start: var(--badge-position-offset); /* logical property */
    inset-inline-end: var(--badge-position-offset); /* logical property */
    display: flex;
    height: var(--badge-size);
    width: var(--badge-size);
    padding: var(--spacing-xs);
    align-items: center;
    justify-content: center;
    border-radius: var(--border-radius-full);
    background-color: var(--color-pink-700);
    color: var(--color-white);
    font-size: var(--font-size-sm);
    font-weight: 700;
    opacity: 0;
    transform: scale(0);
    transition-property: opacity, transform;
    transition-duration: var(--transition-duration-normal);
    transition-timing-function: var(--transition-timing-ease);
    pointer-events: none;
    text-align: center;
    min-width: var(--badge-min-width);
    box-sizing: border-box;
  }

  /* Badge visible state */
  .achievement-badge.visible {
    opacity: 1;
    transform: scale(1);
  }

  /* Counter text */
  .achievement-badge__count {
    line-height: 1;
    display: block;
    width: 100%;
  }

  /* Light mode adjustment with enhanced contrast */
  @media (prefers-color-scheme: light) {
    .achievement-badge {
      background-color: var(--color-pink-800);
      box-shadow: var(--shadow-sm);
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .achievement-badge {
      transition-duration: var(--reduced-motion-duration);
      transform: scale(1);
    }
  }

  /* Print styles - hide badge when printing */
  @media print {
    .achievement-badge {
      display: none;
    }
  }

  /* High contrast mode support */
  @media (forced-colors: active) {
    .achievement-badge {
      border: 2px solid CanvasText;
      background-color: Highlight;
      color: HighlightText;
      forced-color-adjust: none;
    }
  }
</style>

<!-- 6. Client-side interactivity -->
<script>
  import type { AchievementEvent } from "../../types/achievement.ts";
  import { subscribeToAchievementEvents } from "../../utils/achievements/achievementEvents.ts";

  // DOM elements
  const badgeElement = document.getElementById("achievement-badge");

  // Get translation strings from data attributes
  const newLabelText = badgeElement?.getAttribute("data-new-label") || "";
  const newLabelWithCountText = badgeElement?.getAttribute("data-new-label-with-count") || "";
  const fallbackLabelText = badgeElement?.getAttribute("data-fallback-label") || "New achievements";

  // Retrieve number of new achievements from localStorage
  let newAchievementsCount = 0;

  try {
    newAchievementsCount = parseInt(localStorage.getItem("new-achievements-count") || "0", 10);
    // Handle NaN case
    if (isNaN(newAchievementsCount)) {
      newAchievementsCount = 0;
    }
  } catch (error) {
    console.error("Error accessing localStorage:", error);
    // Fallback to zero if localStorage is unavailable
    newAchievementsCount = 0;
  }

  /**
   * Updates the achievement badge display based on current count
   * Controls visibility, content and accessibility attributes
   */
  function updateBadge(): void {
    if (!badgeElement) {
      return;
    }

    // Use requestAnimationFrame for visual updates
    requestAnimationFrame(() => {
      const countElement = badgeElement.querySelector(".achievement-badge__count");
      if (countElement) {
        countElement.textContent = newAchievementsCount.toString();
      }

      // Show or hide badge
      if (newAchievementsCount > 0) {
        badgeElement.classList.add("visible");
        badgeElement.setAttribute("aria-hidden", "false");

        // Format aria-label with count for screen readers
        // Use translation with placeholders if available, fallback to simple concatenation
        const formattedLabel = newLabelWithCountText
          ? newLabelWithCountText.replace("{count}", newAchievementsCount.toString())
          : `${newLabelText || fallbackLabelText}: ${newAchievementsCount}`;

        badgeElement.setAttribute("aria-label", formattedLabel);

        // When new achievements are unlocked, also add an alert role temporarily
        if (newAchievementsCount === 1) {
          // Only add alert role for the first achievement to avoid repeated announcements
          badgeElement.setAttribute("role", "alert");
          // Reset back to status role after announcement
          setTimeout(() => {
            badgeElement.setAttribute("role", "status");
          }, 3000);
        }
      } else {
        badgeElement.classList.remove("visible");
        badgeElement.setAttribute("aria-hidden", "true");
        badgeElement.setAttribute("aria-label", newLabelText || fallbackLabelText);
        badgeElement.setAttribute("role", "status");
      }
    });
  }

  // Event listener for achievement events
  const unsubscribe = subscribeToAchievementEvents((event: AchievementEvent): void => {
    if (event.type === "achievement_unlocked") {
      // Increase count of new achievements
      newAchievementsCount++;

      // Save to localStorage safely
      try {
        localStorage.setItem("new-achievements-count", newAchievementsCount.toString());
      } catch (error) {
        console.error("Error saving to localStorage:", error);
      }

      // Update badge
      updateBadge();
    }
  });

  // Reset badge when achievement page is visited
  document.addEventListener("DOMContentLoaded", (): void => {
    // Check if we're on the achievements page
    const isAchievementPage = window.location.pathname.includes("/achievements");

    if (isAchievementPage) {
      // Reset badge
      newAchievementsCount = 0;

      // Save to localStorage safely
      try {
        localStorage.setItem("new-achievements-count", "0");
      } catch (error) {
        console.error("Error saving to localStorage:", error);
      }
    }

    // Initially update badge
    updateBadge();
  });

  // Remove event listener when unloading the page
  document.addEventListener("beforeunload", (): void => {
    unsubscribe();
  });
</script>
