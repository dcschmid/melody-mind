---
/**
 * @component AchievementFilter
 * @description Enables filtering of achievements by status and category with optimized performance
 * and WCAG AAA compliance.
 */

import { useTranslations } from "../../utils/i18n.ts";
import Headline from "../Headline.astro";
import ButtonLink from "../ButtonLink.astro";

interface Props {
  /** Language code for translations */
  lang: string;
}

const { lang } = Astro.props;
const t = useTranslations(lang);

// Filter options
const statusOptions = [
  { value: "all", label: t("achievements.filter.all") },
  { value: "unlocked", label: t("achievements.status.unlocked") },
  { value: "in-progress", label: t("achievements.status.in_progress") },
  { value: "locked", label: t("achievements.status.locked") },
];

const categoryOptions = [
  { value: "all", label: t("achievements.filter.all_categories") },
  { value: "bronze", label: t("achievements.category.bronze") },
  { value: "silver", label: t("achievements.category.silver") },
  { value: "gold", label: t("achievements.category.gold") },
  { value: "platinum", label: t("achievements.category.platinum") },
  { value: "diamond", label: t("achievements.category.diamond") },
  { value: "time", label: t("achievements.category.time") },
];
---

<div
  class="achievement-filter"
  data-testid="achievement-filter"
  role="region"
  aria-labelledby="filter-heading"
  data-announcement-changed={t("achievements.filter.announcement.changed")}
  data-announcement-no-results={t("achievements.filter.announcement.no_results")}
  data-announcement-results={t("achievements.filter.announcement.results")}
  data-announcement-reset={t("achievements.filter.announcement.reset")}
  data-count-all={t("achievements.filter.count.all")}
  data-count-category-all={t("achievements.filter.count.category_all")}
  data-count-generic={t("achievements.filter.count.generic")}
>
  <Headline
    level="h2"
    id="filter-heading"
    title={t("achievements.filter.title")}
    size="xl"
    variant="default"
    className="achievement-filter__title"
  />

  <div class="achievement-filter__container">
    <div class="achievement-filter__field">
      <label for="status-filter" class="achievement-filter__label" id="status-filter-label"
        >{t("achievements.filter.status")}</label
      >
      <select
        id="status-filter"
        class="achievement-filter__select"
        aria-labelledby="filter-heading status-filter-label"
        aria-controls="achievement-list"
      >
        {statusOptions.map((option) => <option value={option.value}>{option.label}</option>)}
      </select>
      <span class="achievement-filter__count" id="status-count" aria-live="polite"></span>
    </div>

    <div class="achievement-filter__field">
      <label for="category-filter" class="achievement-filter__label" id="category-filter-label"
        >{t("achievements.filter.category")}</label
      >
      <select
        id="category-filter"
        class="achievement-filter__select"
        aria-labelledby="filter-heading category-filter-label"
        aria-controls="achievement-list"
      >
        {categoryOptions.map((option) => <option value={option.value}>{option.label}</option>)}
      </select>
      <span class="achievement-filter__count" id="category-count" aria-live="polite"></span>
    </div>
  </div>

  <div class="achievement-filter__actions">
    <ButtonLink
      type="button"
      className="achievement-filter__reset"
      ariaLabel={t("achievements.filter.reset_aria")}
    >
      {t("achievements.filter.reset")}
    </ButtonLink>

    <ButtonLink
      type="button"
      className="achievement-filter__help-button"
      ariaLabel={t("achievements.filter.keyboard_shortcuts")}
    >
      {t("achievements.filter.keyboard_shortcuts")}
    </ButtonLink>
  </div>

  <div
    class="achievement-filter__keyboard-shortcuts"
    id="keyboard-shortcuts-panel"
    aria-labelledby="help-button-label"
    hidden
  >
    <Headline
      level="h3"
      title={t("achievements.filter.available_shortcuts")}
      size="sm"
      variant="default"
      className="achievement-filter__shortcuts-title"
    />
    <dl class="achievement-filter__shortcuts-list">
      <div class="achievement-filter__shortcut-item">
        <dt class="achievement-filter__shortcut-key"><kbd>Alt</kbd> + <kbd>R</kbd></dt>
        <dd class="achievement-filter__shortcut-description">
          {t("achievements.filter.reset_filters")}
        </dd>
      </div>
      <div class="achievement-filter__shortcut-item">
        <dt class="achievement-filter__shortcut-key"><kbd>Alt</kbd> + <kbd>S</kbd></dt>
        <dd class="achievement-filter__shortcut-description">
          {t("achievements.filter.focus_status")}
        </dd>
      </div>
      <div class="achievement-filter__shortcut-item">
        <dt class="achievement-filter__shortcut-key"><kbd>Alt</kbd> + <kbd>C</kbd></dt>
        <dd class="achievement-filter__shortcut-description">
          {t("achievements.filter.focus_category")}
        </dd>
      </div>
      <div class="achievement-filter__shortcut-item">
        <dt class="achievement-filter__shortcut-key"><kbd>Alt</kbd> + <kbd>K</kbd></dt>
        <dd class="achievement-filter__shortcut-description">
          {t("achievements.filter.toggle_keyboard_help")}
        </dd>
      </div>
    </dl>
  </div>

  <!-- ARIA live region for announcing filter changes -->
  <div id="filter-announcements" aria-live="polite" aria-atomic="true" class="sr-only"></div>
</div>

<style lang="scss">
  /**
   * AchievementFilter Component Styles
   * 
   * FULLY OPTIMIZED: Maximum usage of CSS root variables from global.css
   * DRY principles applied with SCSS mixins and nesting for better maintainability
   * WCAG AAA 2.2 compliant with semantic color variables
   * BEM methodology for consistent class naming
   * Performance optimized with efficient SCSS organization
   */

  /* ============================================================================
   * SCSS MIXINS FOR DRY OPTIMIZATION
   * Consolidated common patterns using SCSS mixins for better maintainability
   * ============================================================================ */

  @mixin interactive-base {
    /* Typography using semantic variables */
    font-size: var(--text-lg);
    font-weight: var(--font-medium);
    line-height: var(--leading-normal);
    letter-spacing: var(--letter-spacing-base);

    /* Layout and sizing using semantic variables */
    border-radius: var(--radius-md);
    min-height: var(--min-touch-size);
    min-width: var(--min-touch-size);
    cursor: pointer;

    /* Unified smooth transitions using system variables */
    transition:
      border-color var(--transition-normal),
      background-color var(--transition-normal),
      box-shadow var(--transition-normal),
      color var(--transition-normal),
      transform var(--transition-fast);
  }

  @mixin focus-styles {
    &:focus {
      outline: none;
      box-shadow: var(--focus-ring);
    }

    &:focus-visible {
      outline: var(--focus-outline);
      outline-offset: var(--focus-ring-offset);
    }
  }

  @mixin hover-transform {
    &:hover {
      transform: translateY(calc(-1 * var(--space-xs)));
      box-shadow: var(--shadow-md);
    }

    &:active {
      transform: translateY(0);
    }
  }

  @mixin text-base {
    color: var(--text-primary);
    letter-spacing: var(--letter-spacing-base);
    text-wrap: balance;
    margin: 0;
  }

  /* ============================================================================
   * MAIN COMPONENT STYLES WITH SCSS NESTING
   * Using SCSS nesting and mixins for better organization and maintainability
   * ============================================================================ */

  .achievement-filter {
    background-color: var(--card-bg);
    border: var(--border-width-thin) solid var(--card-border);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    margin-bottom: var(--space-xl);
    box-shadow: var(--card-shadow);
    transition: box-shadow var(--transition-normal);

    /* Performance optimization */
    contain: layout style;
    will-change: auto;

    &:hover {
      box-shadow: var(--card-shadow-hover);
    }

    /* Title styling with SCSS nesting */
    &__title {
      margin-bottom: var(--space-lg);
      text-align: center;

      @media (min-width: 48em) {
        text-align: left;
      }
    }

    /* Container layout with SCSS organization */
    &__container {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-lg);
      margin-bottom: var(--space-lg);

      @media (min-width: 48em) {
        grid-template-columns: 1fr 1fr;
        gap: var(--space-xl);
      }
    }

    /* Form field styling with SCSS nesting */
    &__field {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      position: relative;
    }

    /* Label styling using SCSS mixins */
    &__label {
      @include text-base;
      font-size: var(--text-lg);
      font-weight: var(--font-medium);
      line-height: var(--leading-normal);
      margin-bottom: var(--space-xs);
      display: block;
    }

    /* Select dropdown styling with SCSS mixins and nesting */
    &__select {
      @include interactive-base;
      @include focus-styles;

      appearance: none;
      background-color: var(--form-bg);
      border: var(--border-width-thick) solid var(--form-border);
      color: var(--form-text);
      padding: var(--space-md) var(--space-lg);
      width: 100%;
      min-width: var(--min-touch-size);

      /* Custom dropdown arrow using semantic colors and CSS variables */
      background-image: var(--icon-dropdown-arrow);
      filter: opacity(var(--opacity-medium)) brightness(var(--filter-brightness-high));
      background-position: right var(--space-md) center;
      background-repeat: no-repeat;
      background-size: var(--space-lg) var(--space-lg);
      padding-right: var(--select-padding-right);

      &:hover:not(:focus) {
        border-color: var(--border-secondary);
        background-color: var(--bg-glass);
      }

      &:focus {
        border-color: var(--form-border-focus);
        background-color: var(--bg-glass);
      }
    }

    /* Count display styling with SCSS mixins and nesting */
    &__count {
      @include text-base;
      font-size: var(--text-sm);
      color: var(--text-secondary);
      font-weight: var(--font-medium);
      margin-top: var(--space-xs);
      line-height: var(--leading-normal);

      &:empty {
        display: none;
      }
    }

    /* Actions container styling with SCSS nesting */
    &__actions {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-md);
      align-items: center;
      justify-content: flex-start;
      margin-top: var(--space-lg);
      padding-top: var(--space-lg);
      border-top: var(--border-width-thin) solid var(--border-primary);

      @media (max-width: calc(48em - 1px)) {
        flex-direction: column;
        align-items: stretch;
        gap: var(--space-lg);
      }
    }

    /* Button styling with SCSS mixins and nesting */
    &__reset,
    &__help-button {
      @include interactive-base;
      @include focus-styles;
      @include hover-transform;

      background: var(--btn-primary-bg);
      border: none;
      color: var(--btn-primary-text);
      cursor: pointer;
      padding: var(--button-padding-standard);
      min-width: var(--min-touch-size);

      /* Enhanced interaction transitions using CSS variables */
      transition:
        background var(--transition-normal),
        transform var(--transition-fast),
        box-shadow var(--transition-normal);

      @media (max-width: calc(48em - 1px)) {
        width: 100%;
        text-align: center;
        min-height: var(--enhanced-touch-target);
        padding: var(--button-padding-enhanced);
      }
    }

    &__reset {
      &:hover {
        background: var(--btn-primary-hover);
      }
    }

    &__help-button {
      background: var(--btn-secondary-bg);
      border: var(--border-width-thick) solid var(--btn-secondary-border);
      color: var(--btn-secondary-text);

      &:hover {
        background: var(--btn-secondary-hover);
        border-color: var(--border-focus);
      }
    }

    /* Keyboard shortcuts panel with SCSS nesting */
    &__keyboard-shortcuts {
      background-color: var(--bg-tertiary);
      border: var(--border-width-thin) solid var(--border-primary);
      border-radius: var(--radius-md);
      margin-top: var(--space-lg);
      padding: var(--space-lg);
      overflow: hidden;

      /* Smooth transitions using system variables */
      transition:
        max-height var(--transition-normal),
        opacity var(--transition-normal),
        padding var(--transition-normal);

      &[hidden] {
        display: none;
      }
    }

    &__shortcuts-title {
      margin-bottom: var(--space-md);
    }

    &__shortcuts-list {
      margin: 0;
      display: grid;
      gap: var(--space-sm);
      font-size: var(--text-base);
      line-height: var(--leading-relaxed);

      @media (min-width: 48em) {
        grid-template-columns: repeat(2, 1fr);
        gap: var(--space-lg);
      }
    }

    &__shortcut-item {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: var(--space-md);
      align-items: baseline;

      @media (max-width: calc(32em - 1px)) {
        grid-template-columns: 1fr;
        gap: var(--space-xs);
      }
    }

    &__shortcut-key {
      font-weight: var(--font-medium);
      color: var(--text-primary);

      kbd {
        background-color: var(--bg-secondary);
        border: var(--border-width-thin) solid var(--border-primary);
        border-radius: var(--radius-sm);
        padding: var(--space-xs) var(--space-sm);
        font-size: var(--text-sm);
        font-weight: var(--font-medium);
        color: var(--text-primary);
        margin: 0 var(--space-xs);
      }
    }

    &__shortcut-description {
      margin: 0;
      color: var(--text-secondary);
      margin-bottom: var(--space-sm);
    }
  }

  /* ============================================================================
   * FILTER UTILITIES - Gap-free grid layout optimization with SCSS
   * ============================================================================ */

  /* 
   * OPTIMIZED: Complete removal from layout flow instead of display: none
   * This prevents grid gaps by removing filtered items from the layout entirely
   */
  .filtered-hidden {
    /* Remove from layout flow completely - no gaps! */
    position: absolute !important;
    left: -10000px !important;
    width: 1px !important;
    height: 1px !important;
    overflow: hidden !important;
    clip: rect(1px, 1px, 1px, 1px) !important;
    clip-path: inset(50%) !important;
    white-space: nowrap !important;

    /* Accessibility: Hidden from screen readers */
    visibility: hidden;
    opacity: 0;
    pointer-events: none;
  }

  /* 
   * Enhanced CSS Grid Layout - Auto-collapse for filtered content
   * Uses CSS Grid's auto-fit with optimized minmax for seamless filtering
   */
  .achievements__grid {
    /* Base responsive grid with automatic gap elimination */
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(min(var(--grid-min-width-sm), 100%), 1fr));
    gap: var(--space-lg);
    width: 100%;

    /* OPTIMIZATION: Only visible children participate in grid layout */
    grid-auto-flow: row dense; /* Dense packing eliminates gaps */
    align-items: start;
    justify-items: stretch;

    /* Smooth transitions for layout changes */
    transition:
      grid-template-columns var(--transition-normal),
      gap var(--transition-normal);

    /* Performance: Contain layout changes for better rendering */
    contain: layout style;

    /* Target only visible achievement cards to prevent gaps */
    > *:not(.filtered-hidden) {
      /* Only visible items participate in grid flow */
      position: relative;
      display: block;
    }

    /* Enhanced visual feedback when filtering is active */
    &:has(.filtered-hidden) {
      /* Subtle highlight when filtering is active */
      filter: var(--filter-enhanced-visibility);
    }

    /* Responsive grid behavior */
    @media (min-width: var(--breakpoint-md)) {
      /* Tablet and up: Allow up to 2 columns */
      grid-template-columns: repeat(auto-fit, minmax(min(var(--grid-min-width-md), 45%), 1fr));
      gap: var(--space-xl);
    }

    @media (min-width: var(--breakpoint-lg)) {
      /* Desktop: Allow up to 3 columns */
      grid-template-columns: repeat(auto-fit, minmax(min(var(--grid-min-width-sm), 30%), 1fr));
      gap: var(--space-xl);
    }

    @media (min-width: var(--breakpoint-xl)) {
      /* Large desktop: Allow optimal spacing */
      grid-template-columns: repeat(auto-fit, minmax(min(var(--grid-min-width-md), 28%), 1fr));
      gap: var(--enhanced-gap-mobile);
    }
  }

  /* 
   * Auto-hide empty category sections when all achievements are filtered
   * Uses modern CSS :has() selector with fallback
   */
  .achievements__category {
    transition:
      opacity var(--transition-normal),
      margin var(--transition-normal),
      padding var(--transition-normal);

    /* Prevent layout shift when content changes */
    contain: layout style;

    /* Hide empty sections using modern CSS */
    &:has(.achievements__grid:empty),
    &:has(.achievements__grid > *:not(.filtered-hidden):empty) {
      display: none;
      margin: 0;
      padding: 0;
    }

    &:has(.achievements__grid:not(:has(*:not(.filtered-hidden)))) {
      display: none;
    }

    /* Section animations for empty state */
    &.section-empty {
      opacity: 0;
      transform: translateY(calc(-1 * var(--space-lg)));
      margin: 0;
      padding: 0;
      max-height: 0;
      overflow: hidden;
    }

    /* Fallback for browsers without :has() support */
    @supports not selector(:has(*)) {
      /* JavaScript will handle section hiding in applyFilters() method */
      &.all-filtered {
        display: none;
      }

      /* Keep visible by default, JavaScript will handle hiding */
      display: block;
    }
  }

  /* ============================================================================
   * KEYFRAME ANIMATIONS WITH SCSS ORGANIZATION
   * Reusable animations using CSS variables for timing
   * ============================================================================ */

  /*
   * Animation for smooth insertion/removal of achievement cards
   * Provides smooth transitions when cards are added or removed from DOM
   */
  .achievement-card-entering {
    animation: cardEnter var(--transition-slow) ease-out forwards;
  }

  .achievement-card-leaving {
    animation: cardLeave var(--transition-normal) ease-in forwards;
  }

  @keyframes cardEnter {
    from {
      opacity: 0;
      transform: translateY(var(--space-lg)) scale(var(--scale-hover));
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  @keyframes cardLeave {
    from {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    to {
      opacity: 0;
      transform: translateY(calc(-1 * var(--space-sm))) scale(var(--scale-hover));
    }
  }

  /* ============================================================================
   * RESPONSIVE DESIGN WITH SCSS NESTING
   * Using SCSS nesting for better organization of media queries
   * ============================================================================ */

  /* Responsive design optimized with filter effects for better visual hierarchy */
  @media (min-width: var(--breakpoint-md)) {
    .achievement-filter {
      box-shadow: var(--card-shadow-hover); /* Enhanced shadow on larger screens */
      filter: brightness(
        var(--filter-brightness-high)
      ); /* Subtle brightness boost for better visibility */

      &__container {
        grid-template-columns: 1fr 1fr;
        gap: var(--space-xl); /* Increased gap for better breathing space */
      }
    }
  }

  /* Mobile optimization with enhanced touch accessibility and visual effects */
  @media (max-width: calc(var(--breakpoint-md) - var(--breakpoint-offset))) {
    .achievement-filter {
      padding: var(--space-md);
      margin-bottom: var(--space-lg);
      /* Enhanced visual hierarchy for mobile using filter effects */
      filter: var(--filter-enhanced-mobile);

      &__actions {
        flex-direction: column;
        align-items: stretch;
        gap: var(--space-lg); /* Increased gap for better touch accessibility */
      }

      &__reset,
      &__help-button {
        width: 100%;
        text-align: center;
        min-height: var(--enhanced-touch-target); /* Enhanced touch target for mobile */
        padding: var(
          --button-padding-enhanced
        ); /* Increased padding for better touch accessibility */
      }
    }
  }

  /* ============================================================================
   * ENHANCED ACCESSIBILITY SUPPORT (WCAG AAA) WITH SCSS
   * ============================================================================ */

  /* High contrast mode support - OPTIMIZED: Using additional CSS variables for enhanced accessibility */
  @media (prefers-contrast: high) {
    .achievement-filter {
      border-width: var(--border-width-thick);
      border-color: var(--text-primary);
      filter: contrast(2) saturate(var(--filter-saturate-high)); /* Enhanced contrast using filter variables */

      &__select {
        border-width: var(--border-width-enhanced);
        filter: var(--filter-high-contrast-select); /* Better visibility in high contrast */
      }

      &__reset,
      &__help-button {
        border-width: var(--border-width-enhanced); /* Consistent enhanced borders */
        filter: var(--filter-high-contrast-button); /* Improved button visibility */
      }
    }
  }

  /* Reduced motion support - OPTIMIZED: Using CSS variables for consistent disabled states */
  @media (prefers-reduced-motion: reduce) {
    /* Apply to all elements that use transitions using semantic CSS variables */
    .achievement-filter {
      transition: none;
      will-change: auto; /* Reset will-change for performance */

      &__select,
      &__reset,
      &__help-button,
      &__keyboard-shortcuts {
        transition: none;
        will-change: auto;
      }

      &__reset:hover,
      &__help-button:hover {
        transform: none;
        /* Provide alternative visual feedback without motion */
        filter: var(--filter-enhanced-visibility);
      }
    }

    @keyframes cardEnter,
    @keyframes cardLeave {
      from,
      to {
        opacity: 1;
        transform: none;
      }
    }
  }

  /* Enhanced text spacing support (WCAG 2.2) - OPTIMIZED: Using more CSS variables */
  @supports (letter-spacing: var(--letter-spacing-enhanced)) {
    .enhanced-text-spacing {
      .achievement-filter__label,
      .achievement-filter__select {
        letter-spacing: var(--letter-spacing-enhanced);
        word-spacing: var(--word-spacing-enhanced);
        line-height: var(--line-height-enhanced);
      }

      /* Additional enhanced spacing for better readability */
      .achievement-filter__shortcut-description {
        letter-spacing: var(--letter-spacing-enhanced);
        word-spacing: var(--word-spacing-enhanced);
        line-height: var(--line-height-enhanced);
      }
    }
  }

  /* Forced colors mode support (Windows High Contrast) */
  @media (forced-colors: active) {
    .achievement-filter {
      border-color: ButtonBorder;
      background-color: ButtonFace;

      &__select {
        border-color: ButtonBorder;
        background-color: Field;
        color: FieldText;
      }

      &__reset {
        background-color: ButtonFace;
        border: var(--border-width-thin) solid ButtonBorder;
        color: ButtonText;
      }

      &__help-button {
        background-color: ButtonFace;
        border-color: ButtonBorder;
        color: ButtonText;
      }
    }
  }

  /* ============================================================================
   * PRINT STYLES - WCAG AAA Print Accessibility (Fully Optimized with CSS Variables)
   * ============================================================================ */
  @media print {
    .achievement-filter {
      background-color: var(--print-bg);
      border: var(--print-border);
      box-shadow: none;
      color: var(--print-text);
      page-break-inside: avoid;
      /* Enhanced print optimization using CSS variables */
      filter: contrast(var(--filter-contrast)) brightness(var(--filter-brightness-high));

      &__label {
        color: var(--print-text);
        /* Enhanced text rendering for print */
        text-rendering: optimizeLegibility;
        -webkit-print-color-adjust: exact;
      }

      &__select {
        background-color: var(--print-bg);
        border: var(--print-border);
        color: var(--print-text);
        padding: var(--space-sm) var(--space-md);
      }

      &__reset,
      &__help-button {
        background-color: var(--print-bg);
        border: var(--print-border);
        color: var(--print-text);
        box-shadow: none;
        padding: var(--space-sm) var(--space-md);
      }

      &__keyboard-shortcuts {
        background-color: var(--print-bg);
        border: var(--print-border);
        color: var(--print-text);
        margin-top: var(--space-md);
        padding: var(--space-md);
      }

      &__shortcut-key {
        color: var(--print-text);
        font-weight: var(--font-bold);
      }

      &__shortcut-description {
        color: var(--print-text);
        font-size: var(--text-sm);
      }
    }
  }
</style>

<script>
  /**
   * AchievementFilter JavaScript Enhancement
   * Progressive enhancement for the filter functionality
   */

  interface FilterState {
    status: string;
    category: string;
  }

  class AchievementFilter {
    private statusSelect: HTMLSelectElement | null = null;
    private categorySelect: HTMLSelectElement | null = null;
    private resetButton: HTMLButtonElement | null = null;
    private helpButton: HTMLButtonElement | null = null;
    private keyboardPanel: HTMLElement | null = null;
    private announcements: HTMLElement | null = null;
    private statusCount: HTMLElement | null = null;
    private categoryCount: HTMLElement | null = null;
    private currentVisibleCount: number = 0;
    private originalCards: Map<
      string,
      Array<{ element: HTMLElement; status: string; category: string }>
    > = new Map();

    // Übersetzungen für Screen Reader Announcements
    private translations: {
      changed: string;
      noResults: string;
      results: string;
      reset: string;
      countAll: string;
      countCategoryAll: string;
      countGeneric: string;
    } = {
      changed: "",
      noResults: "",
      results: "",
      reset: "",
      countAll: "",
      countCategoryAll: "",
      countGeneric: "",
    };

    constructor() {
      this.initializeElements();
      this.initializeOriginalCards();
      this.bindEvents();
      this.setupKeyboardShortcuts();

      // Apply initial filters to show all achievements
      this.applyFilters();
    }

    private initializeElements(): void {
      this.statusSelect = document.getElementById("status-filter") as HTMLSelectElement;
      this.categorySelect = document.getElementById("category-filter") as HTMLSelectElement;
      this.resetButton = document.querySelector(".achievement-filter__reset") as HTMLButtonElement;
      this.helpButton = document.querySelector(
        ".achievement-filter__help-button"
      ) as HTMLButtonElement;
      this.keyboardPanel = document.getElementById("keyboard-shortcuts-panel") as HTMLElement;
      this.announcements = document.getElementById("filter-announcements") as HTMLElement;
      this.statusCount = document.getElementById("status-count") as HTMLElement;
      this.categoryCount = document.getElementById("category-count") as HTMLElement;

      // Initialize ARIA attributes for ButtonLink components
      if (this.helpButton) {
        this.helpButton.setAttribute("aria-expanded", "false");
        this.helpButton.setAttribute("aria-controls", "keyboard-shortcuts-panel");
        this.helpButton.setAttribute("id", "help-button-label");
      }

      // Lade Übersetzungen aus Datenattributen
      const filterContainer = document.querySelector(".achievement-filter") as HTMLElement;
      if (filterContainer) {
        this.translations = {
          changed: filterContainer.dataset.announcementChanged || "",
          noResults: filterContainer.dataset.announcementNoResults || "",
          results: filterContainer.dataset.announcementResults || "",
          reset: filterContainer.dataset.announcementReset || "",
          countAll: filterContainer.dataset.countAll || "",
          countCategoryAll: filterContainer.dataset.countCategoryAll || "",
          countGeneric: filterContainer.dataset.countGeneric || "",
        };
      }
    }

    /**
     * Initialize and store original cards from all sections
     * This method captures the initial state of all achievement cards
     */
    private initializeOriginalCards(): void {
      const achievementSections = document.querySelectorAll(".achievements__category");

      achievementSections.forEach((section: Element) => {
        const sectionElement = section as HTMLElement;
        const grid = section.querySelector(".achievements__grid");

        if (!grid) {
          return;
        }

        // Create a unique identifier for this section
        const sectionId =
          sectionElement.dataset.sectionId ||
          sectionElement.querySelector("h2, h3")?.textContent?.trim() ||
          section.classList[0] ||
          `section-${Array.from(achievementSections).indexOf(section)}`;

        // Store section ID for later reference
        sectionElement.dataset.sectionId = sectionId;

        // Capture all cards in this section
        const cards = Array.from(grid.querySelectorAll('[data-testid^="achievement-card-"]')).map(
          (card) => {
            const cardElement = card as HTMLElement;
            return {
              element: cardElement.cloneNode(true) as HTMLElement,
              status: cardElement.dataset.status || "",
              category: cardElement.dataset.category || "",
            };
          }
        );

        this.originalCards.set(sectionId, cards);
      });
    }

    private bindEvents(): void {
      if (this.statusSelect) {
        this.statusSelect.addEventListener("change", () => this.handleFilterChange("status"));
      }

      if (this.categorySelect) {
        this.categorySelect.addEventListener("change", () => this.handleFilterChange("category"));
      }

      if (this.resetButton) {
        this.resetButton.addEventListener("click", () => this.resetFilters());
      }

      if (this.helpButton) {
        this.helpButton.addEventListener("click", () => this.toggleKeyboardHelp());
      }
    }

    private handleFilterChange(filterType: string): void {
      const filterValue =
        filterType === "status"
          ? this.statusSelect?.value || "all"
          : this.categorySelect?.value || "all";

      // Apply filters immediately
      this.applyFilters();

      // Update counts
      this.updateFilterCounts();

      // Announce change to screen readers
      this.announceFilterChange(filterType, filterValue);
    }

    private resetFilters(): void {
      if (this.statusSelect) {
        this.statusSelect.value = "all";
      }
      if (this.categorySelect) {
        this.categorySelect.value = "all";
      }

      // Apply reset filters immediately
      this.applyFilters();

      this.updateFilterCounts();
      this.announceFilterReset();

      // Dispatch reset event
      const event = new CustomEvent("achievementFilterReset");
      document.dispatchEvent(event);
    }

    /**
     * Applies filters to achievement cards in the DOM
     * Uses DOM manipulation to completely remove/add elements for gap-free layout
     * This approach eliminates layout issues by working with actual DOM structure
     */
    private applyFilters(): void {
      const statusFilter = this.statusSelect?.value || "all";
      const categoryFilter = this.categorySelect?.value || "all";

      // Find all achievement sections in the DOM
      const achievementSections = document.querySelectorAll(".achievements__category");

      let visibleCards = 0;
      let visibleSections = 0;

      achievementSections.forEach((section: Element) => {
        const sectionElement = section as HTMLElement;
        const grid = section.querySelector(".achievements__grid");

        if (!grid) {
          return;
        }

        // Get all cards (both visible and hidden)
        const allCards = this.getAllCardsInSection(section);
        let visibleCardsInSection = 0;

        // Clear the grid
        grid.innerHTML = "";

        // Filter and re-add cards that match the criteria
        allCards.forEach((cardData) => {
          const { element: cardElement, status: cardStatus, category: cardCategory } = cardData;

          // Check if card matches filters
          const statusMatch = statusFilter === "all" || cardStatus === statusFilter;
          const categoryMatch = categoryFilter === "all" || cardCategory === categoryFilter;

          if (statusMatch && categoryMatch) {
            // Add card back to grid with enter animation
            cardElement.classList.add("achievement-card-entering");
            cardElement.setAttribute("aria-hidden", "false");
            cardElement.removeAttribute("tabindex");

            grid.appendChild(cardElement);
            visibleCards++;
            visibleCardsInSection++;

            // Remove animation class after animation completes using CSS variable
            setTimeout(
              () => {
                cardElement.classList.remove("achievement-card-entering");
              },
              parseInt(
                getComputedStyle(document.documentElement).getPropertyValue("--timeout-animation")
              ) || 300
            );
          }
        });

        // Show/hide section based on whether it has visible cards
        if (visibleCardsInSection > 0) {
          sectionElement.classList.remove("section-empty");
          sectionElement.setAttribute("aria-hidden", "false");
          visibleSections++;
        } else {
          sectionElement.classList.add("section-empty");
          sectionElement.setAttribute("aria-hidden", "true");
        }
      });

      // Update the achievements list container's aria-live region
      this.updateFilterResultsAnnouncement(visibleCards, visibleSections);

      // Store the current filter state for count updates
      this.currentVisibleCount = visibleCards;
    }

    /**
     * Gets all cards in a section, including currently hidden ones
     * Stores them in memory for filtering operations
     */
    private getAllCardsInSection(
      section: Element
    ): Array<{ element: HTMLElement; status: string; category: string }> {
      const grid = section.querySelector(".achievements__grid");
      if (!grid) {
        return [];
      }

      // If we haven't stored the original cards for this section, do it now
      const sectionId = (section as HTMLElement).dataset.sectionId || section.classList[0];

      if (!this.originalCards.has(sectionId)) {
        const cards = Array.from(grid.querySelectorAll('[data-testid^="achievement-card-"]')).map(
          (card) => {
            const cardElement = card as HTMLElement;
            return {
              element: cardElement.cloneNode(true) as HTMLElement,
              status: cardElement.dataset.status || "",
              category: cardElement.dataset.category || "",
            };
          }
        );
        this.originalCards.set(sectionId, cards);
      }

      return this.originalCards.get(sectionId) || [];
    }

    /**
     * Updates the filter results announcement for screen readers
     */
    private updateFilterResultsAnnouncement(visibleCards: number, visibleSections: number): void {
      if (this.announcements) {
        let message: string;

        if (visibleCards === 0) {
          message = this.translations.noResults;
        } else {
          // Handle pluralization for cards and sections
          const cardPlural = visibleCards !== 1 ? "s" : "";
          const sectionPlural = visibleSections !== 1 ? "n" : "";

          message = this.translations.results
            .replace("{visibleCards}", visibleCards.toString())
            .replace("{cardPlural}", cardPlural)
            .replace("{visibleSections}", visibleSections.toString())
            .replace("{sectionPlural}", sectionPlural);
        }

        this.announcements.textContent = message;

        // Clear announcement after 3 seconds
        setTimeout(
          () => {
            if (this.announcements) {
              this.announcements.textContent = "";
            }
          },
          parseInt(
            getComputedStyle(document.documentElement).getPropertyValue("--timeout-announcement")
          ) || 3000
        );
      }
    }

    /**
     * CSS-only layout optimization is handled via CSS Grid with auto-fit and minmax
     * No JavaScript manipulation of grid layout needed
     */

    private toggleKeyboardHelp(): void {
      if (!this.keyboardPanel || !this.helpButton) {
        return;
      }

      const isHidden = this.keyboardPanel.hasAttribute("hidden");

      if (isHidden) {
        this.keyboardPanel.removeAttribute("hidden");
        this.helpButton.setAttribute("aria-expanded", "true");
      } else {
        this.keyboardPanel.setAttribute("hidden", "");
        this.helpButton.setAttribute("aria-expanded", "false");
      }
    }

    private setupKeyboardShortcuts(): void {
      document.addEventListener("keydown", (event) => {
        // Alt + R: Reset filters
        if (event.altKey && event.key === "r") {
          event.preventDefault();
          this.resetFilters();
          this.resetButton?.focus();
        }

        // Alt + H: Toggle keyboard help
        if (event.altKey && event.key === "h") {
          event.preventDefault();
          this.toggleKeyboardHelp();
        }

        // Alt + S: Focus status filter
        if (event.altKey && event.key === "s") {
          event.preventDefault();
          this.statusSelect?.focus();
        }

        // Alt + C: Focus category filter
        if (event.altKey && event.key === "c") {
          event.preventDefault();
          this.categorySelect?.focus();
        }
      });
    }

    private updateFilterCounts(): void {
      // This would normally calculate based on actual data
      // For now, we'll use the visible count from filtering
      const statusValue = this.statusSelect?.value || "all";
      const categoryValue = this.categorySelect?.value || "all";

      // Use the current visible count if available, otherwise show placeholder
      const currentCount = this.currentVisibleCount !== undefined ? this.currentVisibleCount : 0;

      // Update status count display
      if (this.statusCount) {
        const statusText =
          statusValue === "all"
            ? this.translations.countAll.replace("{count}", currentCount.toString())
            : this.translations.countGeneric
                .replace("{value}", statusValue)
                .replace("{count}", currentCount.toString());
        this.statusCount.textContent = statusText;
      }

      // Update category count display
      if (this.categoryCount) {
        const categoryText =
          categoryValue === "all"
            ? this.translations.countCategoryAll.replace("{count}", currentCount.toString())
            : this.translations.countGeneric
                .replace("{value}", categoryValue)
                .replace("{count}", currentCount.toString());
        this.categoryCount.textContent = categoryText;
      }
    }

    private announceFilterChange(filterType: string, filterValue: string): void {
      if (this.announcements && this.translations.changed) {
        const message = this.translations.changed
          .replace("{filterType}", filterType)
          .replace("{filterValue}", filterValue);
        this.announcements.textContent = message;

        // Clear announcement after 3 seconds
        setTimeout(
          () => {
            if (this.announcements) {
              this.announcements.textContent = "";
            }
          },
          parseInt(
            getComputedStyle(document.documentElement).getPropertyValue("--timeout-announcement")
          ) || 3000
        );
      }
    }

    private announceFilterReset(): void {
      if (this.announcements && this.translations.reset) {
        this.announcements.textContent = this.translations.reset;

        setTimeout(
          () => {
            if (this.announcements) {
              this.announcements.textContent = "";
            }
          },
          parseInt(
            getComputedStyle(document.documentElement).getPropertyValue("--timeout-announcement")
          ) || 3000
        );
      }
    }

    private getCurrentState(): FilterState {
      return {
        status: this.statusSelect?.value || "all",
        category: this.categorySelect?.value || "all",
      };
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => new AchievementFilter());
  } else {
    new AchievementFilter();
  }
</script>
