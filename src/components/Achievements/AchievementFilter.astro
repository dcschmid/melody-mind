---
/**
 * @component AchievementFilter
 * @description Enables filtering of achievements by status and category with optimized performance
 * and WCAG AAA compliance.
 */

import { useTranslations } from "../../utils/i18n.ts";

interface Props {
  /** Language code for translations */
  lang: string;
}

const { lang } = Astro.props;
const t = useTranslations(lang);

// Filter options
const statusOptions = [
  { value: "all", label: t("achievements.filter.all") },
  { value: "unlocked", label: t("achievements.status.unlocked") },
  { value: "in-progress", label: t("achievements.status.in_progress") },
  { value: "locked", label: t("achievements.status.locked") },
];

const categoryOptions = [
  { value: "all", label: t("achievements.filter.all_categories") },
  { value: "bronze", label: t("achievements.category.bronze") },
  { value: "silver", label: t("achievements.category.silver") },
  { value: "gold", label: t("achievements.category.gold") },
  { value: "platinum", label: t("achievements.category.platinum") },
  { value: "diamond", label: t("achievements.category.diamond") },
  { value: "time", label: t("achievements.category.time") },
];
---

<div
  class="achievement-filter"
  data-testid="achievement-filter"
  role="region"
  aria-labelledby="filter-heading"
  data-announcement-changed={t("achievements.filter.announcement.changed")}
  data-announcement-no-results={t("achievements.filter.announcement.no_results")}
  data-announcement-results={t("achievements.filter.announcement.results")}
  data-announcement-reset={t("achievements.filter.announcement.reset")}
  data-count-all={t("achievements.filter.count.all")}
  data-count-category-all={t("achievements.filter.count.category_all")}
  data-count-generic={t("achievements.filter.count.generic")}
>
  <h2 class="achievement-filter__title" id="filter-heading">{t("achievements.filter.title")}</h2>

  <div class="achievement-filter__container">
    <div class="achievement-filter__field">
      <label for="status-filter" class="achievement-filter__label" id="status-filter-label"
        >{t("achievements.filter.status")}</label
      >
      <select
        id="status-filter"
        class="achievement-filter__select"
        aria-labelledby="filter-heading status-filter-label"
        aria-controls="achievement-list"
      >
        {statusOptions.map((option) => <option value={option.value}>{option.label}</option>)}
      </select>
      <span class="achievement-filter__count" id="status-count" aria-live="polite"></span>
    </div>

    <div class="achievement-filter__field">
      <label for="category-filter" class="achievement-filter__label" id="category-filter-label"
        >{t("achievements.filter.category")}</label
      >
      <select
        id="category-filter"
        class="achievement-filter__select"
        aria-labelledby="filter-heading category-filter-label"
        aria-controls="achievement-list"
      >
        {categoryOptions.map((option) => <option value={option.value}>{option.label}</option>)}
      </select>
      <span class="achievement-filter__count" id="category-count" aria-live="polite"></span>
    </div>
  </div>

  <div class="achievement-filter__actions">
    <button
      type="button"
      class="achievement-filter__reset"
      id="reset-filters"
      aria-label={t("achievements.filter.reset_aria")}
    >
      {t("achievements.filter.reset")}
    </button>

    <button
      type="button"
      class="achievement-filter__help-button"
      id="keyboard-help-toggle"
      aria-expanded="false"
      aria-controls="keyboard-shortcuts-panel"
    >
      {t("achievements.filter.keyboard_shortcuts")}
    </button>
  </div>

  <div
    class="achievement-filter__keyboard-shortcuts"
    id="keyboard-shortcuts-panel"
    aria-labelledby="keyboard-help-toggle"
    hidden
  >
    <h3 class="achievement-filter__shortcuts-title">
      {t("achievements.filter.available_shortcuts")}
    </h3>
    <dl class="achievement-filter__shortcuts-list">
      <div class="achievement-filter__shortcut-item">
        <dt class="achievement-filter__shortcut-key"><kbd>Alt</kbd> + <kbd>R</kbd></dt>
        <dd class="achievement-filter__shortcut-description">
          {t("achievements.filter.reset_filters")}
        </dd>
      </div>
      <div class="achievement-filter__shortcut-item">
        <dt class="achievement-filter__shortcut-key"><kbd>Alt</kbd> + <kbd>S</kbd></dt>
        <dd class="achievement-filter__shortcut-description">
          {t("achievements.filter.focus_status")}
        </dd>
      </div>
      <div class="achievement-filter__shortcut-item">
        <dt class="achievement-filter__shortcut-key"><kbd>Alt</kbd> + <kbd>C</kbd></dt>
        <dd class="achievement-filter__shortcut-description">
          {t("achievements.filter.focus_category")}
        </dd>
      </div>
      <div class="achievement-filter__shortcut-item">
        <dt class="achievement-filter__shortcut-key"><kbd>Alt</kbd> + <kbd>K</kbd></dt>
        <dd class="achievement-filter__shortcut-description">
          {t("achievements.filter.toggle_keyboard_help")}
        </dd>
      </div>
    </dl>
  </div>

  <!-- ARIA live region for announcing filter changes -->
  <div id="filter-announcements" aria-live="polite" aria-atomic="true" class="sr-only"></div>
</div>

<style>
  /**
   * AchievementFilter Component Styles
   * 
   * FULLY OPTIMIZED: Maximum usage of CSS root variables from global.css
   * DRY principles applied - consolidated repetitive patterns into shared selectors
   * WCAG AAA 2.2 compliant with semantic color variables
   * BEM methodology for consistent class naming
   * Performance optimized with efficient CSS organization
   */

  /* ============================================================================
   * SHARED INTERACTIVE ELEMENT STYLES (DRY Optimization)
   * Consolidated common patterns used across all interactive elements
   * ============================================================================ */

  /* Shared base styles for all interactive elements */
  .achievement-filter__select,
  .achievement-filter__reset,
  .achievement-filter__help-button {
    /* Typography using semantic variables */
    font-size: var(--text-lg);
    font-weight: var(--font-medium);
    line-height: var(--leading-normal);
    letter-spacing: var(--letter-spacing-base);

    /* Layout and sizing using semantic variables */
    border-radius: var(--radius-md);
    min-height: var(--min-touch-size);
    min-width: var(--min-touch-size);
    cursor: pointer;

    /* Unified smooth transitions using system variables */
    transition:
      border-color var(--transition-normal),
      background-color var(--transition-normal),
      box-shadow var(--transition-normal),
      color var(--transition-normal),
      transform var(--transition-fast);
  }

  /* Unified focus styles for all interactive elements (WCAG AAA) */
  .achievement-filter__select:focus,
  .achievement-filter__reset:focus,
  .achievement-filter__help-button:focus {
    outline: none;
    box-shadow: var(--focus-ring);
  }

  .achievement-filter__select:focus-visible,
  .achievement-filter__reset:focus-visible,
  .achievement-filter__help-button:focus-visible {
    outline: var(--focus-outline);
    outline-offset: var(--focus-ring-offset);
  }

  /* Shared hover interactions with transform */
  .achievement-filter__reset:hover,
  .achievement-filter__help-button:hover {
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
  }

  .achievement-filter__reset:active,
  .achievement-filter__help-button:active {
    transform: translateY(0);
  }

  /* ============================================================================
   * SHARED TEXT ELEMENTS (DRY Typography)
   * Consolidated typography styles for all text elements
   * ============================================================================ */

  .achievement-filter__title,
  .achievement-filter__label,
  .achievement-filter__shortcuts-title,
  .achievement-filter__count {
    color: var(--text-primary);
    letter-spacing: var(--letter-spacing-base);
    text-wrap: balance;
    margin: 0; /* Reset margins to use consistent spacing variables */
  }

  /* Text hierarchy using semantic size scale */
  .achievement-filter__title {
    font-size: var(--text-xl);
    font-weight: var(--font-bold);
    line-height: var(--leading-tight);
    margin-bottom: var(--space-lg);
  }

  .achievement-filter__label {
    font-size: var(--text-lg);
    font-weight: var(--font-medium);
    line-height: var(--leading-normal);
    margin-bottom: var(--space-xs);
    display: block;
  }

  .achievement-filter__shortcuts-title {
    font-size: var(--text-lg);
    font-weight: var(--font-bold);
    line-height: var(--leading-tight);
    margin-bottom: var(--space-md);
  }

  .achievement-filter__count {
    font-size: var(--text-sm);
    color: var(--text-secondary);
    font-weight: var(--font-medium);
    margin-top: var(--space-xs);
    line-height: var(--leading-normal);
  }

  /* ============================================================================
   * BASE COMPONENT CONTAINER (Semantic Variables)
   * ============================================================================ */
  .achievement-filter {
    background-color: var(--card-bg);
    border: var(--border-width-thin) solid var(--card-border);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    margin-bottom: var(--space-xl);
    box-shadow: var(--card-shadow);
    transition: box-shadow var(--transition-normal);

    /* Performance optimization */
    contain: layout style;
    will-change: auto;
  }

  .achievement-filter:hover {
    box-shadow: var(--card-shadow-hover);
  }

  /* ============================================================================
   * LAYOUT SYSTEM (Grid with semantic spacing)
   * ============================================================================ */
  .achievement-filter__container {
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--space-lg);
    margin-bottom: var(--space-lg);
  }

  .achievement-filter__field {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
    position: relative;
  }

  .achievement-filter__actions {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-md);
    align-items: center;
    justify-content: flex-start;
    margin-top: var(--space-lg);
    padding-top: var(--space-lg);
    border-top: var(--border-width-thin) solid var(--border-primary);
  }

  /* ============================================================================
   * FORM ELEMENTS (Using form system variables)
   * ============================================================================ */
  .achievement-filter__select {
    appearance: none;
    background-color: var(--form-bg);
    border: var(--border-width-thick) solid var(--form-border);
    color: var(--form-text);
    padding: var(--space-md) var(--space-lg);
    width: 100%;
    min-width: var(--min-touch-size);

    /* Custom dropdown arrow using semantic colors - FULLY OPTIMIZED: Using CSS filter for dynamic color */
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
    filter: opacity(var(--opacity-medium)) brightness(var(--filter-brightness-high));
    background-position: right var(--space-md) center;
    background-repeat: no-repeat;
    background-size: 1.5em 1.5em;
    padding-right: calc(var(--space-lg) + 2rem);
  }

  .achievement-filter__select:focus {
    border-color: var(--form-border-focus);
    background-color: var(--bg-glass);
  }

  .achievement-filter__select:hover:not(:focus) {
    border-color: var(--border-secondary);
    background-color: var(--bg-glass);
  }

  /* ============================================================================
   * BUTTON SYSTEM (Using button system variables)
   * ============================================================================ */
  .achievement-filter__reset {
    background: var(--btn-primary-bg);
    border: none;
    color: var(--btn-primary-text);
    cursor: pointer;
    padding: var(--space-md) var(--space-xl);
    min-width: var(--min-touch-size);

    /* Enhanced interaction with transform using CSS variables */
    transition:
      background var(--transition-normal),
      transform var(--transition-fast),
      box-shadow var(--transition-normal);
  }

  .achievement-filter__reset:hover {
    background: var(--btn-primary-hover);
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
  }

  .achievement-filter__reset:active {
    transform: translateY(0);
  }

  .achievement-filter__help-button {
    background: var(--btn-secondary-bg);
    border: var(--border-width-thick) solid var(--btn-secondary-border);
    color: var(--btn-secondary-text);
    cursor: pointer;
    padding: var(--space-md) var(--space-xl);
    min-width: var(--min-touch-size);
  }

  .achievement-filter__help-button:hover {
    background: var(--btn-secondary-hover);
    border-color: var(--border-focus);
  }

  /* ============================================================================
   * KEYBOARD SHORTCUTS PANEL (Collapsible content system)
   * ============================================================================ */
  .achievement-filter__keyboard-shortcuts {
    background-color: var(--bg-tertiary);
    border: var(--border-width-thin) solid var(--border-primary);
    border-radius: var(--radius-md);
    margin-top: var(--space-lg);
    padding: var(--space-lg);
    overflow: hidden;

    /* Smooth transitions using system variables */
    transition:
      max-height var(--transition-normal),
      opacity var(--transition-normal),
      padding var(--transition-normal);
  }

  .achievement-filter__keyboard-shortcuts[hidden] {
    display: none;
  }

  .achievement-filter__shortcuts-list {
    margin: 0;
    display: grid;
    gap: var(--space-sm);
    font-size: var(--text-base);
    line-height: var(--leading-relaxed);
  }

  .achievement-filter__shortcut-item {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: var(--space-md);
    align-items: baseline;
  }

  .achievement-filter__shortcut-key {
    font-weight: var(--font-medium);
    color: var(--text-primary);
  }

  .achievement-filter__shortcut-key kbd {
    background-color: var(--bg-secondary);
    border: var(--border-width-thin) solid var(--border-primary);
    border-radius: var(--radius-sm);
    padding: var(--space-xs) var(--space-sm);
    font-size: var(--text-sm);
    font-weight: var(--font-medium);
    color: var(--text-primary);
    margin: 0 var(--space-xs);
  }

  .achievement-filter__shortcut-description {
    margin: 0;
    color: var(--text-secondary);
    margin-bottom: var(--space-sm);
  }

  /* ============================================================================
   * ACCESSIBILITY UTILITIES
   * ============================================================================ */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* ============================================================================
   * FILTER UTILITIES - Pure CSS gap-free grid layout optimization
   * ============================================================================ */

  /* Class for elements hidden by filtering */
  .filtered-hidden {
    display: none !important;
    visibility: hidden;
    opacity: 0;
  }

  /* 
   * Pure CSS Grid Layout Optimization
   * Uses CSS Grid's auto-fit to automatically eliminate gaps without JavaScript
   */
  .achievements__grid {
    /* Base responsive grid with automatic gap elimination */
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(min(280px, 100%), 1fr));
    gap: var(--space-lg);
    width: 100%;

    /* Smooth transitions for layout changes */
    transition: gap var(--transition-normal);

    /* CSS Grid will automatically adjust columns when items are hidden */
    grid-auto-flow: row;
    align-items: start;
    justify-items: stretch;
  }

  /* 
   * Enhanced responsive grid behavior 
   * Automatically adapts to screen size and available content
   */
  @media (min-width: 48em) {
    /* Tablet and up: Allow up to 2 columns */
    .achievements__grid {
      grid-template-columns: repeat(auto-fit, minmax(min(320px, 45%), 1fr));
      gap: var(--space-xl);
    }
  }

  @media (min-width: 64em) {
    /* Desktop: Allow up to 3 columns */
    .achievements__grid {
      grid-template-columns: repeat(auto-fit, minmax(min(280px, 30%), 1fr));
      gap: var(--space-xl);
    }
  }

  @media (min-width: 80em) {
    /* Large desktop: Allow optimal spacing */
    .achievements__grid {
      grid-template-columns: repeat(auto-fit, minmax(min(320px, 28%), 1fr));
      gap: calc(var(--space-xl) + var(--space-sm));
    }
  }

  /*
   * Hide empty category sections automatically
   * Uses CSS :empty selector and advanced :has() selector
   */
  .achievements__category:has(.achievements__grid:not(:has(*:not(.filtered-hidden)))) {
    display: none;
  }

  /* Fallback for browsers without :has() support */
  @supports not selector(:has(*)) {
    .achievements__category {
      /* Keep visible by default, JavaScript will handle hiding */
      display: block;
    }
  }

  /*
   * Optimize layout when sections become empty
   * Ensures smooth visual transitions
   */
  .achievements__category {
    transition:
      opacity var(--transition-normal),
      margin var(--transition-normal),
      padding var(--transition-normal);

    /* Prevent layout shift when content changes */
    contain: layout style;
  }

  /*
   * Enhanced visual feedback for filtered states
   * Provides subtle visual cues during filtering
   */
  .achievements__grid:has(.filtered-hidden) {
    /* Subtle highlight when filtering is active */
    filter: brightness(var(--filter-brightness-high)) saturate(var(--filter-saturate-medium));
  }

  /*
   * Improved accessibility for filtered content
   * Ensures screen readers handle hidden content correctly
   */
  .filtered-hidden {
    /* Enhanced hiding that works across all browsers */
    position: absolute !important;
    left: -10000px !important;
    width: 1px !important;
    height: 1px !important;
    overflow: hidden !important;
    clip: rect(1px, 1px, 1px, 1px) !important;
    clip-path: inset(50%) !important;
    white-space: nowrap !important;
  }

  /* ============================================================================
   * RESPONSIVE DESIGN (Using breakpoint variables)
   * ============================================================================ */
  /* Responsive design optimized with filter effects for better visual hierarchy */
  @media (min-width: 48em) {
    /* var(--breakpoint-md) equivalent - 768px */
    .achievement-filter__container {
      grid-template-columns: 1fr 1fr;
      gap: var(--space-xl); /* Increased gap for better breathing space */
    }

    .achievement-filter {
      box-shadow: var(--card-shadow-hover); /* Enhanced shadow on larger screens */
      filter: brightness(
        var(--filter-brightness-high)
      ); /* Subtle brightness boost for better visibility */
    }
  }

  /* Mobile optimization with enhanced touch accessibility and visual effects */
  @media (max-width: 47.9375em) {
    /* Below md breakpoint - using semantic spacing variables */
    .achievement-filter {
      padding: var(--space-md);
      margin-bottom: var(--space-lg);
      /* Enhanced visual hierarchy for mobile using filter effects */
      filter: saturate(var(--filter-saturate-high)) brightness(var(--filter-brightness-high));
    }

    .achievement-filter__actions {
      flex-direction: column;
      align-items: stretch;
      gap: var(--space-lg); /* Increased gap for better touch accessibility */
    }

    .achievement-filter__reset,
    .achievement-filter__help-button {
      width: 100%;
      text-align: center;
      min-height: calc(
        var(--min-touch-size) + var(--space-sm)
      ); /* Enhanced touch target for mobile */
      padding: var(--space-lg) var(--space-xl); /* Increased padding for better touch accessibility */
    }
  }

  /* ============================================================================
   * ENHANCED ACCESSIBILITY SUPPORT (WCAG AAA)
   * ============================================================================ */

  /* High contrast mode support - OPTIMIZED: Using additional CSS variables for enhanced accessibility */
  @media (prefers-contrast: high) {
    .achievement-filter {
      border-width: var(--border-width-thick);
      border-color: var(--text-primary);
      filter: contrast(2) saturate(var(--filter-saturate-high)); /* Enhanced contrast using filter variables */
    }

    .achievement-filter__select {
      border-width: calc(
        var(--border-width-thick) + 1px
      ); /* Enhanced border using calc with CSS variables */
      filter: contrast(1.5) brightness(var(--filter-brightness-high)); /* Better visibility in high contrast */
    }

    .achievement-filter__reset,
    .achievement-filter__help-button {
      border-width: calc(var(--border-width-thick) + 1px); /* Consistent enhanced borders */
      filter: contrast(1.2) saturate(var(--filter-saturate-high)); /* Improved button visibility */
    }
  }

  /* Reduced motion support - OPTIMIZED: Using CSS variables for consistent disabled states */
  @media (prefers-reduced-motion: reduce) {
    /* Apply to all elements that use transitions using semantic CSS variables */
    .achievement-filter,
    .achievement-filter__select,
    .achievement-filter__reset,
    .achievement-filter__help-button,
    .achievement-filter__keyboard-shortcuts {
      transition: none;
      will-change: auto; /* Reset will-change for performance */
    }

    .achievement-filter__reset:hover,
    .achievement-filter__help-button:hover {
      transform: none;
      /* Provide alternative visual feedback without motion */
      filter: brightness(var(--filter-brightness-high)) saturate(var(--filter-saturate-high));
    }
  }

  /* Enhanced text spacing support (WCAG 2.2) - OPTIMIZED: Using more CSS variables */
  @supports (letter-spacing: var(--letter-spacing-enhanced)) {
    .enhanced-text-spacing .achievement-filter__title,
    .enhanced-text-spacing .achievement-filter__label,
    .enhanced-text-spacing .achievement-filter__select {
      letter-spacing: var(--letter-spacing-enhanced);
      word-spacing: var(--word-spacing-enhanced);
      line-height: var(--line-height-enhanced);
    }

    /* Additional enhanced spacing for better readability */
    .enhanced-text-spacing .achievement-filter__shortcuts-title,
    .enhanced-text-spacing .achievement-filter__shortcut-description {
      letter-spacing: var(--letter-spacing-enhanced);
      word-spacing: var(--word-spacing-enhanced);
      line-height: var(--line-height-enhanced);
    }
  }

  /* Forced colors mode support (Windows High Contrast) */
  @media (forced-colors: active) {
    .achievement-filter {
      border-color: ButtonBorder;
      background-color: ButtonFace;
    }

    .achievement-filter__select {
      border-color: ButtonBorder;
      background-color: Field;
      color: FieldText;
    }

    .achievement-filter__reset {
      background-color: ButtonFace;
      border: var(--border-width-thin) solid ButtonBorder;
      color: ButtonText;
    }

    .achievement-filter__help-button {
      background-color: ButtonFace;
      border-color: ButtonBorder;
      color: ButtonText;
    }
  }

  /* ============================================================================
   * PRINT STYLES - WCAG AAA Print Accessibility - OPTIMIZED: Using more semantic variables
   * ============================================================================ */
  @media print {
    .achievement-filter {
      background-color: var(--color-white);
      border: var(--border-width-thin) solid var(--color-black);
      box-shadow: none;
      color: var(--color-black);
      page-break-inside: avoid;
      /* Enhanced print optimization using filter variables */
      filter: contrast(1.2) brightness(var(--filter-brightness-high));
    }

    .achievement-filter__title,
    .achievement-filter__label {
      color: var(--color-black);
      /* Enhanced text rendering for print */
      text-rendering: optimizeLegibility;
      -webkit-print-color-adjust: exact; /* Preserve text styling in print */
    }

    .achievement-filter__select {
      background-color: var(--color-white);
      border: var(--border-width-thin) solid var(--color-black);
      color: var(--color-black);
      /* Remove custom background image for print */
      background-image: none;
    }

    .achievement-filter__reset,
    .achievement-filter__help-button {
      background-color: var(--color-white);
      border: var(--border-width-thin) solid var(--color-black);
      color: var(--color-black);
    }

    .achievement-filter__keyboard-shortcuts {
      background-color: var(--color-white);
      border: var(--border-width-thin) solid var(--color-black);
    }
  }
</style>

<script>
  /**
   * AchievementFilter JavaScript Enhancement
   * Progressive enhancement for the filter functionality
   */

  interface FilterState {
    status: string;
    category: string;
  }

  class AchievementFilter {
    private statusSelect: HTMLSelectElement | null = null;
    private categorySelect: HTMLSelectElement | null = null;
    private resetButton: HTMLButtonElement | null = null;
    private helpButton: HTMLButtonElement | null = null;
    private keyboardPanel: HTMLElement | null = null;
    private announcements: HTMLElement | null = null;
    private statusCount: HTMLElement | null = null;
    private categoryCount: HTMLElement | null = null;
    private currentVisibleCount: number = 0;

    // Übersetzungen für Screen Reader Announcements
    private translations: {
      changed: string;
      noResults: string;
      results: string;
      reset: string;
      countAll: string;
      countCategoryAll: string;
      countGeneric: string;
    } = {
      changed: "",
      noResults: "",
      results: "",
      reset: "",
      countAll: "",
      countCategoryAll: "",
      countGeneric: "",
    };

    constructor() {
      this.initializeElements();
      this.bindEvents();
      this.setupKeyboardShortcuts();

      // Apply initial filters to show all achievements
      this.applyFilters();
    }

    private initializeElements(): void {
      this.statusSelect = document.getElementById("status-filter") as HTMLSelectElement;
      this.categorySelect = document.getElementById("category-filter") as HTMLSelectElement;
      this.resetButton = document.getElementById("reset-filters") as HTMLButtonElement;
      this.helpButton = document.getElementById("keyboard-help-toggle") as HTMLButtonElement;
      this.keyboardPanel = document.getElementById("keyboard-shortcuts-panel") as HTMLElement;
      this.announcements = document.getElementById("filter-announcements") as HTMLElement;
      this.statusCount = document.getElementById("status-count") as HTMLElement;
      this.categoryCount = document.getElementById("category-count") as HTMLElement;

      // Lade Übersetzungen aus Datenattributen
      const filterContainer = document.querySelector(".achievement-filter") as HTMLElement;
      if (filterContainer) {
        this.translations = {
          changed: filterContainer.dataset.announcementChanged || "",
          noResults: filterContainer.dataset.announcementNoResults || "",
          results: filterContainer.dataset.announcementResults || "",
          reset: filterContainer.dataset.announcementReset || "",
          countAll: filterContainer.dataset.countAll || "",
          countCategoryAll: filterContainer.dataset.countCategoryAll || "",
          countGeneric: filterContainer.dataset.countGeneric || "",
        };
      }
    }

    private bindEvents(): void {
      if (this.statusSelect) {
        this.statusSelect.addEventListener("change", () => this.handleFilterChange("status"));
      }

      if (this.categorySelect) {
        this.categorySelect.addEventListener("change", () => this.handleFilterChange("category"));
      }

      if (this.resetButton) {
        this.resetButton.addEventListener("click", () => this.resetFilters());
      }

      if (this.helpButton) {
        this.helpButton.addEventListener("click", () => this.toggleKeyboardHelp());
      }
    }

    private handleFilterChange(filterType: string): void {
      const filterValue =
        filterType === "status"
          ? this.statusSelect?.value || "all"
          : this.categorySelect?.value || "all";

      // Apply filters immediately
      this.applyFilters();

      // Update counts
      this.updateFilterCounts();

      // Announce change to screen readers
      this.announceFilterChange(filterType, filterValue);
    }

    private resetFilters(): void {
      if (this.statusSelect) {
        this.statusSelect.value = "all";
      }
      if (this.categorySelect) {
        this.categorySelect.value = "all";
      }

      // Apply reset filters immediately
      this.applyFilters();

      this.updateFilterCounts();
      this.announceFilterReset();

      // Dispatch reset event
      const event = new CustomEvent("achievementFilterReset");
      document.dispatchEvent(event);
    }

    /**
     * Applies filters to achievement cards in the DOM
     * This method filters achievement cards based on status and category
     * Uses optimized CSS classes for gap-free grid layout
     */
    private applyFilters(): void {
      const statusFilter = this.statusSelect?.value || "all";
      const categoryFilter = this.categorySelect?.value || "all";

      // Find all achievement sections in the DOM
      const achievementSections = document.querySelectorAll(".achievements__category");

      let visibleCards = 0;
      let visibleSections = 0;

      achievementSections.forEach((section: Element) => {
        const sectionElement = section as HTMLElement;
        const cardsInSection = section.querySelectorAll('[data-testid^="achievement-card-"]');
        let visibleCardsInSection = 0;

        cardsInSection.forEach((card: Element) => {
          const cardElement = card as HTMLElement;
          const cardStatus = cardElement.dataset.status || "";
          const cardCategory = cardElement.dataset.category || "";

          // Check if card matches status filter
          const statusMatch = statusFilter === "all" || cardStatus === statusFilter;

          // Check if card matches category filter
          const categoryMatch = categoryFilter === "all" || cardCategory === categoryFilter;

          // Show/hide card based on filter criteria
          // Use CSS class toggle for better grid behavior
          if (statusMatch && categoryMatch) {
            cardElement.style.display = "";
            cardElement.classList.remove("filtered-hidden");
            cardElement.setAttribute("aria-hidden", "false");
            visibleCards++;
            visibleCardsInSection++;
          } else {
            cardElement.style.display = "none";
            cardElement.classList.add("filtered-hidden");
            cardElement.setAttribute("aria-hidden", "true");
          }
        });

        // Show/hide section based on whether it has visible cards
        if (visibleCardsInSection > 0) {
          sectionElement.style.display = "";
          sectionElement.classList.remove("filtered-hidden");
          sectionElement.setAttribute("aria-hidden", "false");
          visibleSections++;
        } else {
          sectionElement.style.display = "none";
          sectionElement.classList.add("filtered-hidden");
          sectionElement.setAttribute("aria-hidden", "true");
        }
      });

      // Update the achievements list container's aria-live region
      this.updateFilterResultsAnnouncement(visibleCards, visibleSections);

      // Store the current filter state for count updates
      this.currentVisibleCount = visibleCards;
    }

    /**
     * Updates the filter results announcement for screen readers
     */
    private updateFilterResultsAnnouncement(visibleCards: number, visibleSections: number): void {
      if (this.announcements) {
        let message: string;

        if (visibleCards === 0) {
          message = this.translations.noResults;
        } else {
          // Handle pluralization for cards and sections
          const cardPlural = visibleCards !== 1 ? "s" : "";
          const sectionPlural = visibleSections !== 1 ? "n" : "";

          message = this.translations.results
            .replace("{visibleCards}", visibleCards.toString())
            .replace("{cardPlural}", cardPlural)
            .replace("{visibleSections}", visibleSections.toString())
            .replace("{sectionPlural}", sectionPlural);
        }

        this.announcements.textContent = message;

        // Clear announcement after 3 seconds
        setTimeout(() => {
          if (this.announcements) {
            this.announcements.textContent = "";
          }
        }, 3000);
      }
    }

    /**
     * CSS-only layout optimization is handled via CSS Grid with auto-fit and minmax
     * No JavaScript manipulation of grid layout needed
     */

    private toggleKeyboardHelp(): void {
      if (!this.keyboardPanel || !this.helpButton) {
        return;
      }

      const isHidden = this.keyboardPanel.hasAttribute("hidden");

      if (isHidden) {
        this.keyboardPanel.removeAttribute("hidden");
        this.helpButton.setAttribute("aria-expanded", "true");
      } else {
        this.keyboardPanel.setAttribute("hidden", "");
        this.helpButton.setAttribute("aria-expanded", "false");
      }
    }

    private setupKeyboardShortcuts(): void {
      document.addEventListener("keydown", (event) => {
        // Alt + R: Reset filters
        if (event.altKey && event.key === "r") {
          event.preventDefault();
          this.resetFilters();
          this.resetButton?.focus();
        }

        // Alt + H: Toggle keyboard help
        if (event.altKey && event.key === "h") {
          event.preventDefault();
          this.toggleKeyboardHelp();
        }

        // Alt + S: Focus status filter
        if (event.altKey && event.key === "s") {
          event.preventDefault();
          this.statusSelect?.focus();
        }

        // Alt + C: Focus category filter
        if (event.altKey && event.key === "c") {
          event.preventDefault();
          this.categorySelect?.focus();
        }
      });
    }

    private updateFilterCounts(): void {
      // This would normally calculate based on actual data
      // For now, we'll use the visible count from filtering
      const statusValue = this.statusSelect?.value || "all";
      const categoryValue = this.categorySelect?.value || "all";

      // Use the current visible count if available, otherwise show placeholder
      const currentCount = this.currentVisibleCount !== undefined ? this.currentVisibleCount : 0;

      // Update status count display
      if (this.statusCount) {
        const statusText =
          statusValue === "all"
            ? this.translations.countAll.replace("{count}", currentCount.toString())
            : this.translations.countGeneric
                .replace("{value}", statusValue)
                .replace("{count}", currentCount.toString());
        this.statusCount.textContent = statusText;
      }

      // Update category count display
      if (this.categoryCount) {
        const categoryText =
          categoryValue === "all"
            ? this.translations.countCategoryAll.replace("{count}", currentCount.toString())
            : this.translations.countGeneric
                .replace("{value}", categoryValue)
                .replace("{count}", currentCount.toString());
        this.categoryCount.textContent = categoryText;
      }
    }

    private announceFilterChange(filterType: string, filterValue: string): void {
      if (this.announcements && this.translations.changed) {
        const message = this.translations.changed
          .replace("{filterType}", filterType)
          .replace("{filterValue}", filterValue);
        this.announcements.textContent = message;

        // Clear announcement after 3 seconds
        setTimeout(() => {
          if (this.announcements) {
            this.announcements.textContent = "";
          }
        }, 3000);
      }
    }

    private announceFilterReset(): void {
      if (this.announcements && this.translations.reset) {
        this.announcements.textContent = this.translations.reset;

        setTimeout(() => {
          if (this.announcements) {
            this.announcements.textContent = "";
          }
        }, 3000);
      }
    }

    private getCurrentState(): FilterState {
      return {
        status: this.statusSelect?.value || "all",
        category: this.categorySelect?.value || "all",
      };
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => new AchievementFilter());
  } else {
    new AchievementFilter();
  }
</script>
