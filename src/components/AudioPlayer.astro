---
interface Props {
  audioSrc: string;
  imageSrc: string;
  imageAlt: string;
  title?: string;
  artist?: string;
  waveformColor?: string;
  accentColor?: string;
}

const {
  audioSrc,
  imageSrc,
  imageAlt,
  title = "",
  artist = "",
  waveformColor = "#a855f7", // Purple-500
  accentColor = "#c084fc", // Purple-400
} = Astro.props;

// Generate a unique ID for this player
const playerId = `audio-player-${Math.random().toString(36).substring(2, 10)}`;
---

<div class="w-full max-w-[500px] mx-auto relative" aria-label="Audio-Player">
  <div
    class="relative w-full rounded-2xl overflow-hidden isolate shadow-lg shadow-black/20 transition-all duration-300 hover:shadow-xl hover:shadow-black/30 hover:-translate-y-1"
  >
    <div class="relative w-full aspect-video overflow-hidden">
      <img
        src={imageSrc}
        alt={imageAlt}
        class="absolute w-full h-full object-cover top-0 left-0 transition-transform duration-500 ease-in-out group-hover:scale-105"
      />

      <!-- Overlay with glass effect and info area -->
      <div
        class="absolute bottom-0 left-0 w-full bg-gradient-to-t from-zinc-900/90 via-zinc-900/70 to-transparent pt-3 pb-3 px-4 text-white backdrop-blur-sm transition-opacity duration-300"
      >
        <!-- Audio player controls -->
        <div
          id={playerId}
          class="flex items-center gap-3 w-full"
          data-audio-src={audioSrc}
          data-waveform-color={waveformColor}
          data-accent-color={accentColor}
        >
          <button
            class="bg-white text-zinc-800 w-10 h-10 rounded-full border-none flex items-center justify-center cursor-pointer flex-shrink-0 transition-all duration-200 relative shadow-md hover:scale-105 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/50 focus-visible:ring-offset-2"
            aria-label="Play audio"
            title="Play/Pause"
          >
            <svg
              class="play-icon w-6 h-6 fill-current absolute transition-all"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path d="M8 5v14l11-7z"></path>
            </svg>
            <svg
              class="pause-icon w-6 h-6 fill-current absolute opacity-0 scale-75 transition-all"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
            </svg>
          </button>

          <div class="flex-grow flex flex-col gap-1">
            <div
              class="h-1.5 bg-zinc-200/20 rounded overflow-hidden relative cursor-pointer progress-bar-container"
            >
              <div
                class="progress-bar-bg absolute top-0 left-0 w-full h-full z-[1]"
              >
              </div>
              <div
                class="progress-bar h-full w-0 bg-purple-400 absolute z-[2] rounded transition-width duration-100 linear"
              >
              </div>
              <div
                class="waveform-container absolute top-0 left-0 w-full h-full z-0 opacity-70"
              >
              </div>
            </div>
            <div class="flex justify-between text-xs text-zinc-300/80">
              <span class="current-time">0:00</span>
              <span class="duration">0:00</span>
            </div>
          </div>

          <div class="flex items-center gap-2 relative">
            <button
              class="volume-btn bg-transparent text-white border-none p-1 cursor-pointer opacity-85 hover:opacity-100 transition-opacity flex items-center justify-center focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:rounded"
              aria-label="Adjust volume"
              title="Volume"
            >
              <svg
                class="volume-icon w-5 h-5 fill-current absolute transition-all"
                viewBox="0 0 24 24"
                aria-hidden="true"
              >
                <path
                  d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"
                ></path>
              </svg>
              <svg
                class="mute-icon w-5 h-5 fill-current absolute opacity-0 scale-75 transition-all"
                viewBox="0 0 24 24"
                aria-hidden="true"
              >
                <path
                  d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"
                ></path>
              </svg>
            </button>
            <div
              class="volume-slider-container w-0 overflow-hidden transition-[width] duration-300 h-6 flex items-center group-hover:w-20"
            >
              <input
                type="range"
                class="volume-slider appearance-none w-full h-1 bg-white/30 rounded outline-none volume-slider"
                min="0"
                max="1"
                step="0.01"
                value="1"
                aria-label="Adjust volume"
              />
            </div>
          </div>

          <!-- Hidden audio element -->
          <audio class="audio-element hidden" preload="metadata">
            <source src={audioSrc} type="audio/mpeg" />
            <p>Your browser does not support the audio element.</p>
          </audio>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  /* Necessary base styles for functionality */
  .volume-control:hover .volume-slider-container,
  .volume-slider-container:focus-within {
    width: 5rem;
  }

  .volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: white;
    cursor: pointer;
    transition: transform 0.2s ease;
  }

  .volume-slider::-moz-range-thumb {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: none;
    background: white;
    cursor: pointer;
    transition: transform 0.2s ease;
  }

  .volume-slider::-webkit-slider-thumb:hover,
  .volume-slider:active::-webkit-slider-thumb {
    transform: scale(1.2);
  }

  .volume-slider::-moz-range-thumb:hover,
  .volume-slider:active::-moz-range-thumb {
    transform: scale(1.2);
  }

  /* Reduced motion for accessibility */
  @media (prefers-reduced-motion: reduce) {
    .image-with-player:hover {
      transform: none;
    }

    button:hover {
      transform: none !important;
    }

    .play-icon,
    .pause-icon,
    .volume-icon,
    .mute-icon {
      transition: opacity 0.1s linear;
    }
  }
</style>

<script define:vars={{ playerId }}>
  /**
   * Modern Audio Player Implementation
   *
   * A lightweight, accessible audio player with the following features:
   * - Custom UI with play/pause controls
   * - Progress bar with seeking functionality
   * - Volume control with mute option
   * - Visual waveform representation
   * - Keyboard accessibility
   * - Touch-friendly mobile support
   */

  // Use an IIFE to prevent global scope pollution
  (() => {
    // Wait until DOM is fully loaded to ensure all elements are available
    document.addEventListener("DOMContentLoaded", () =>
      initializePlayer(playerId),
    );

    /**
     * Initialize the audio player with the given ID
     * @param {string} id - The unique ID of the player instance
     */
    function initializePlayer(id) {
      // Locate the player and its elements in the DOM
      const player = document.getElementById(id);
      if (!player) {
        console.warn(`Audio player with ID "${id}" not found in the DOM`);
        return;
      }

      // DOM element references - cached for performance
      const elements = {
        audio: player.querySelector(".audio-element"),
        playButton: player.querySelector("button"),
        playIcon: player.querySelector(".play-icon"),
        pauseIcon: player.querySelector(".pause-icon"),
        progress: {
          bar: player.querySelector(".progress-bar"),
          container: player.querySelector(".progress-bar-container"),
          waveform: player.querySelector(".waveform-container"),
        },
        time: {
          current: player.querySelector(".current-time"),
          duration: player.querySelector(".duration"),
        },
        volume: {
          button: player.querySelector(".volume-btn"),
          icon: player.querySelector(".volume-icon"),
          muteIcon: player.querySelector(".mute-icon"),
          slider: player.querySelector(".volume-slider"),
        },
      };

      // Player configuration from data attributes
      const config = {
        waveformColor: player.dataset.waveformColor || "#a855f7",
        accentColor: player.dataset.accentColor || "#c084fc",
        audioSrc: player.dataset.audioSrc || "",
      };

      // Player state management
      const state = {
        isPlaying: false,
        lastVolume: 1,
        isMuted: false,
        seekingEnabled: true,
      };

      // Apply configuration
      if (config.audioSrc) {
        elements.audio.src = config.audioSrc;
      }

      elements.progress.bar.style.backgroundColor = config.accentColor;

      /**
       * Creates and renders the audio waveform visualization
       * The waveform uses random heights to create a visual representation of audio
       */
      function renderWaveform() {
        const segments = 40; // Number of waveform segments
        let waveformHTML = "";

        // Generate random segment heights for visual variety
        for (let i = 0; i < segments; i++) {
          // Random height between 30% and 100%
          const height = Math.floor(30 + Math.random() * 70);
          const segmentWidth = 100 / segments;

          waveformHTML += `
            <div style="
              position: absolute;
              left: ${i * segmentWidth}%;
              width: ${segmentWidth * 0.7}%;
              height: ${height}%;
              background-color: ${config.waveformColor};
              opacity: 0.7;
              top: ${(100 - height) / 2}%;
              border-radius: 1px;
              z-index: 0;
            "></div>
          `;
        }

        elements.progress.waveform.innerHTML = waveformHTML;
      }

      /**
       * Formats time in seconds to mm:ss display format
       * @param {number} seconds - Time in seconds
       * @return {string} Formatted time string
       */
      function formatTime(seconds) {
        if (isNaN(seconds) || !isFinite(seconds)) return "0:00";

        const min = Math.floor(seconds / 60);
        const sec = Math.floor(seconds % 60);
        return `${min}:${sec < 10 ? "0" + sec : sec}`;
      }

      /**
       * Toggles play/pause state of the audio
       * Updates UI and accessibility attributes accordingly
       */
      function togglePlayback() {
        if (elements.audio.paused) {
          // Play audio with error handling
          elements.audio
            .play()
            .then(() => {
              state.isPlaying = true;
              updatePlaybackUI();
            })
            .catch((error) => {
              console.error("Error playing audio:", error);
              // Provide user feedback on playback error
              state.isPlaying = false;
              updatePlaybackUI();
            });
        } else {
          elements.audio.pause();
          state.isPlaying = false;
          updatePlaybackUI();
        }
      }

      /**
       * Updates play/pause button appearance and accessibility
       * based on current playback state
       */
      function updatePlaybackUI() {
        if (state.isPlaying) {
          elements.playIcon.style.opacity = "0";
          elements.playIcon.style.transform = "scale(0.8)";
          elements.pauseIcon.style.opacity = "1";
          elements.pauseIcon.style.transform = "scale(1)";
          elements.playButton.setAttribute("aria-label", "Pause audio");
          elements.playButton.setAttribute("title", "Pause");
        } else {
          elements.playIcon.style.opacity = "1";
          elements.playIcon.style.transform = "scale(1)";
          elements.pauseIcon.style.opacity = "0";
          elements.pauseIcon.style.transform = "scale(0.8)";
          elements.playButton.setAttribute("aria-label", "Play audio");
          elements.playButton.setAttribute("title", "Play");
        }
      }

      /**
       * Updates volume button appearance and accessibility
       * based on current volume state
       */
      function updateVolumeUI() {
        if (state.isMuted || elements.audio.volume === 0) {
          elements.volume.icon.style.opacity = "0";
          elements.volume.icon.style.transform = "scale(0.8)";
          elements.volume.muteIcon.style.opacity = "1";
          elements.volume.muteIcon.style.transform = "scale(1)";
          elements.volume.button.setAttribute("aria-label", "Unmute");
          elements.volume.button.setAttribute("title", "Unmute");
        } else {
          elements.volume.icon.style.opacity = "1";
          elements.volume.icon.style.transform = "scale(1)";
          elements.volume.muteIcon.style.opacity = "0";
          elements.volume.muteIcon.style.transform = "scale(0.8)";
          elements.volume.button.setAttribute("aria-label", "Mute");
          elements.volume.button.setAttribute("title", "Mute");
        }
      }

      /**
       * Updates progress bar and time displays
       * Called on timeupdate event
       */
      function updateProgress() {
        const { currentTime, duration } = elements.audio;
        if (isNaN(duration)) return;

        // Update progress bar width
        const progressPercent = (currentTime / duration) * 100;
        elements.progress.bar.style.width = `${progressPercent}%`;

        // Update time displays
        elements.time.current.textContent = formatTime(currentTime);
        elements.time.duration.textContent = formatTime(duration);

        // Set aria values for accessibility
        elements.progress.container.setAttribute(
          "aria-valuenow",
          Math.round(progressPercent),
        );
        elements.progress.container.setAttribute(
          "aria-valuetext",
          `${formatTime(currentTime)} of ${formatTime(duration)}`,
        );
      }

      /**
       * Jumps to a specific position in the audio when progress bar is clicked
       * @param {MouseEvent} event - Click event on progress bar
       */
      function seekAudio(event) {
        if (!state.seekingEnabled) return;

        const rect = elements.progress.container.getBoundingClientRect();
        const clickPosition = (event.clientX - rect.left) / rect.width;
        const duration = elements.audio.duration;

        if (isNaN(duration)) return;

        elements.audio.currentTime = clickPosition * duration;
      }

      /**
       * Toggles mute state of the audio
       * Remembers previous volume level when muting
       */
      function toggleMute() {
        if (elements.audio.volume === 0 || elements.audio.muted) {
          // Unmute
          elements.audio.muted = false;
          elements.audio.volume = state.lastVolume;
          elements.volume.slider.value = state.lastVolume;
          state.isMuted = false;
        } else {
          // Mute
          state.lastVolume = elements.audio.volume;
          elements.audio.volume = 0;
          elements.audio.muted = true;
          elements.volume.slider.value = 0;
          state.isMuted = true;
        }

        updateVolumeUI();
      }

      /**
       * Handles volume slider changes
       */
      function handleVolumeChange() {
        const newVolume = elements.volume.slider.value;
        elements.audio.volume = newVolume;
        elements.audio.muted = newVolume === "0";
        state.isMuted = newVolume === "0";
        updateVolumeUI();
      }

      /**
       * Resets the player to initial state
       * Called when audio playback ends
       */
      function resetPlayer() {
        state.isPlaying = false;
        updatePlaybackUI();
        elements.progress.bar.style.width = "0%";
        elements.time.current.textContent = formatTime(0);
      }

      /**
       * Handles keyboard navigation and controls
       * @param {KeyboardEvent} event - Keyboard event
       */
      function handleKeyboardControl(event) {
        // Only handle keyboard events when focused within this player
        if (!event.target.closest(`#${id}`)) return;

        switch (event.code) {
          case "Space":
            // Only toggle play/pause if the play button is focused
            if (event.target === elements.playButton) {
              event.preventDefault(); // Prevent page scrolling
              togglePlayback();
            }
            break;

          case "ArrowLeft":
            // Rewind 5 seconds
            elements.audio.currentTime = Math.max(
              0,
              elements.audio.currentTime - 5,
            );
            break;

          case "ArrowRight":
            // Forward 5 seconds
            if (!isNaN(elements.audio.duration)) {
              elements.audio.currentTime = Math.min(
                elements.audio.duration,
                elements.audio.currentTime + 5,
              );
            }
            break;

          case "ArrowUp":
            // Increase volume (only when volume slider is focused)
            if (event.target === elements.volume.slider) {
              const newVolume = Math.min(
                1,
                parseFloat(elements.volume.slider.value) + 0.1,
              );
              elements.volume.slider.value = newVolume;
              elements.audio.volume = newVolume;
              elements.audio.muted = false;
              state.isMuted = false;
              updateVolumeUI();
            }
            break;

          case "ArrowDown":
            // Decrease volume (only when volume slider is focused)
            if (event.target === elements.volume.slider) {
              const newVolume = Math.max(
                0,
                parseFloat(elements.volume.slider.value) - 0.1,
              );
              elements.volume.slider.value = newVolume;
              elements.audio.volume = newVolume;
              state.isMuted = newVolume === 0;
              updateVolumeUI();
            }
            break;

          case "KeyM":
            // Toggle mute with 'm' key
            toggleMute();
            break;
        }
      }

      // Initialize ARIA attributes for accessibility
      function initializeAccessibility() {
        elements.progress.container.setAttribute("role", "progressbar");
        elements.progress.container.setAttribute("aria-valuemin", "0");
        elements.progress.container.setAttribute("aria-valuemax", "100");
        elements.progress.container.setAttribute("aria-valuenow", "0");
        elements.progress.container.setAttribute(
          "aria-valuetext",
          "0:00 of 0:00",
        );
      }

      // Set up event listeners
      function setupEventListeners() {
        // Playback control
        elements.playButton.addEventListener("click", togglePlayback);

        // Progress tracking and seeking
        elements.audio.addEventListener("timeupdate", updateProgress);
        elements.progress.container.addEventListener("click", seekAudio);

        // Metadata loading
        elements.audio.addEventListener("loadedmetadata", () => {
          elements.time.duration.textContent = formatTime(
            elements.audio.duration,
          );
          elements.time.current.textContent = formatTime(0);
          renderWaveform();
        });

        // Playback ended
        elements.audio.addEventListener("ended", resetPlayer);

        // Volume control
        elements.volume.button.addEventListener("click", toggleMute);
        elements.volume.slider.addEventListener("input", handleVolumeChange);

        // Keyboard controls
        player.addEventListener("keydown", handleKeyboardControl);

        // Error handling
        elements.audio.addEventListener("error", (e) => {
          console.error("Audio playback error:", e);
          resetPlayer();
        });
      }

      // Initialize player components
      initializeAccessibility();
      setupEventListeners();

      // Pre-load duration if metadata is already available
      if (elements.audio.readyState >= 1) {
        elements.time.duration.textContent = formatTime(
          elements.audio.duration,
        );
        renderWaveform();
      }
    }
  })();
</script>
