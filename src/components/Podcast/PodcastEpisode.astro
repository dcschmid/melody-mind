---
/**
 * Podcast Episode Component
 *
 * Displays a podcast episode with image, description, audio player and
 * collapsible transcript. Designed for list view on the main podcast page.
 */
import type { PodcastData } from "../../types/podcast";
import { useTranslations } from "../../utils/i18n";
import Headline from "../Headline.astro";
import Paragraph from "../Paragraph.astro";

interface Props {
  podcast: PodcastData;
  lang: string;
  className?: string;
}

const { podcast, lang, className = "" } = Astro.props;
const t = useTranslations(lang);

// Generate unique ID for this episode instance
const audioId = `podcast-audio-${podcast.id}`;
---

<article class={`podcast-episode ${className}`} data-podcast-id={podcast.id}>
  <!-- Episode Header -->
  <div class="podcast-episode__header">
    <!-- Episode Image -->
    <div class="podcast-episode__image-wrapper">
      <img
        src={podcast.imageUrl}
        alt={podcast.title}
        class="podcast-episode__image"
        loading="lazy"
        width="800"
        height="450"
      />
      <div class="podcast-episode__image-overlay">
        <span class="podcast-episode__badge">Podcast</span>
      </div>
    </div>

    <!-- Episode Info -->
    <div class="podcast-episode__info">
      <Headline
        level="h2"
        title={podcast.title}
        size="2xl"
        textAlign="center"
        className="podcast-episode__title"
      />
      <div class="podcast-episode__divider"></div>
      <Paragraph
        description={podcast.description}
        textSize="lg"
        align="center"
        className="podcast-episode__description"
      />

      <!-- Episode Meta -->
      <div class="podcast-episode__meta">
        <span class="podcast-episode__meta-item podcast-episode__date">
          <span class="podcast-episode__meta-icon">ðŸ“…</span>
          <span class="podcast-episode__meta-text">{podcast.publishedAt}</span>
        </span>
      </div>
    </div>
  </div>

  <!-- Audio Player -->
  <div class="podcast-episode__player-wrapper">
    <div class="podcast-episode__player">
      <!-- Hidden native audio element -->
      <audio
        id={audioId}
        preload="none"
        class="podcast-episode__audio"
        data-episode-id={podcast.id}
        data-audio-url={podcast.audioUrl}
      >
        <source src={podcast.audioUrl} type="audio/mpeg" />
        {
          podcast.subtitleUrl && (
            <track
              kind="captions"
              src={podcast.subtitleUrl}
              srclang={podcast.language || lang}
              label={t("podcasts.captions")}
              default
            />
          )
        }
        {t("podcasts.audio.not_supported")}
      </audio>

      <!-- Custom player controls -->
      <div class="podcast-episode__custom-player">
        <button class="podcast-episode__play-button" aria-label="Play audio" type="button">
          <svg class="podcast-episode__play-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"></path>
          </svg>
          <svg class="podcast-episode__pause-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
          </svg>
        </button>

        <div class="podcast-episode__progress-container">
          <div class="podcast-episode__waveform-bg">
            {
              Array(50)
                .fill(0)
                .map((_, index) => (
                  <div
                    class="podcast-episode__waveform-bar"
                    style={`height: ${Math.floor(Math.random() * 70) + 10}%`}
                  />
                ))
            }
          </div>
          <div class="podcast-episode__progress-indicator"></div>
        </div>

        <div class="podcast-episode__time-display">
          <span class="podcast-episode__current-time">0:00</span>
          <span class="podcast-episode__time-separator">/</span>
          <span class="podcast-episode__total-time">0:00</span>
        </div>
      </div>
    </div>
  </div>
</article>

<style lang="scss">
  /* ======================================
   * PODCAST EPISODE COMPONENT - Optimized
   * Uses global.css variables for consistency
   * ====================================== */

  /* Episode Container */
  .podcast-episode {
    background: var(--card-bg);
    border-radius: var(--radius-xl);
    overflow: hidden;
    box-shadow: var(--card-shadow);
    border: var(--border-width-thin) solid var(--border-primary);
    margin-bottom: var(--space-lg);
    transition: all var(--transition-normal);
    container-type: inline-size;
    container-name: podcast-episode;
    width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;

    @media (min-width: 768px) {
      margin-bottom: var(--space-xl);
    }

    &:hover {
      box-shadow: var(--card-shadow-hover);
      transform: translateY(var(--animation-y-offset-small));
    }

    &:focus-within {
      outline: var(--focus-outline);
      outline-offset: var(--focus-ring-offset);
      box-shadow: var(--focus-ring), var(--card-shadow-hover);
    }
  }

  /* Episode Header Layout - Enhanced Responsive Grid */
  .podcast-episode__header {
    display: grid;
    gap: var(--space-md);
    padding: var(--space-md);
    align-items: start;
    width: 100%;
    box-sizing: border-box;
    background: linear-gradient(to bottom, var(--bg-tertiary), var(--card-bg));

    /* Mobile First: Single column layout */
    grid-template-columns: 1fr;
    grid-template-areas:
      "image"
      "info";
    text-align: center;

    @media (min-width: 480px) {
      padding: var(--space-lg);
      gap: var(--space-lg);
    }

    /* Small tablet: Image + Info side by side */
    @media (min-width: 640px) {
      grid-template-columns: 220px 1fr;
      grid-template-areas: "image info";
      text-align: left;
      gap: var(--space-lg);
    }

    /* Large tablet and Desktop: Wider image */
    @media (min-width: 768px) {
      grid-template-columns: 280px 1fr;
      padding: var(--space-xl) var(--space-xl) var(--space-lg);
      gap: var(--space-xl);
    }

    /* Large desktop: Even wider image */
    @media (min-width: 1024px) {
      grid-template-columns: 320px 1fr;
    }
  }

  /* Episode Image with Overlay */
  .podcast-episode__image-wrapper {
    position: relative;
    grid-area: image;
    width: 100%;
    aspect-ratio: 16/9;
    border-radius: var(--radius-lg);
    overflow: hidden;
    box-shadow: var(--shadow-lg);
    background: var(--bg-tertiary);
    transform: translateZ(0); /* Fix for Safari border-radius overflow issue */
    transition:
      transform var(--transition-normal),
      box-shadow var(--transition-normal);

    &:hover {
      transform: translateZ(0) scale(var(--animation-scale-hover-subtle));
      box-shadow: var(--shadow-xl);
    }
  }

  .podcast-episode__image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    transition: transform var(--transition-slow);

    .podcast-episode:hover & {
      transform: scale(var(--animation-scale-medium));
    }
  }

  .podcast-episode__image-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0) 50%);
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding: var(--space-md);
    transition: background var(--transition-normal);

    .podcast-episode:hover & {
      background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0.2) 70%);
    }
  }

  .podcast-episode__badge {
    display: inline-block;
    background: var(--color-primary-500);
    color: var(--color-white);
    font-size: var(--text-xs);
    font-weight: var(--font-bold);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--radius-pill);
    text-transform: uppercase;
    letter-spacing: var(--letter-spacing-enhanced);
    box-shadow: var(--shadow-sm);
    align-self: flex-start;
  }

  /* Episode Info */
  .podcast-episode__info {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
    grid-area: info;
    min-width: 0; /* Prevent text overflow */
  }

  .podcast-episode__divider {
    width: 60px;
    height: 3px;
    background: var(--color-primary-500);
    border-radius: var(--radius-pill);
    margin: var(--space-sm) auto var(--space-md);
    opacity: 0.8;
  }

  /* Meta Information */
  .podcast-episode__meta {
    display: flex;
    gap: var(--space-md);
    flex-wrap: wrap;
    justify-content: center;
    margin-top: var(--space-xs);

    @media (min-width: 640px) {
      justify-content: flex-start;
    }
  }

  .podcast-episode__meta-item {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    font-size: var(--text-sm);
    color: var(--text-tertiary);
    padding: var(--space-xs) var(--space-sm);
    background: var(--bg-tertiary);
    border-radius: var(--radius-pill);
    box-shadow: var(--shadow-xs);
  }

  .podcast-episode__meta-icon {
    font-size: 1.1em;
  }

  .podcast-episode__meta-text {
    font-weight: var(--font-medium);
  }

  /* Audio Player Wrapper */
  .podcast-episode__player-wrapper {
    padding: var(--space-md);
    background: var(--card-bg);
    border-top: var(--border-width-thin) solid var(--border-primary);

    @media (min-width: 480px) {
      padding: var(--space-lg);
    }
  }

  /* Native Audio Player */
  .podcast-episode__audio {
    display: none; /* Hide native controls */
  }

  /* States */
  .is-playing .podcast-episode__image-wrapper {
    box-shadow:
      0 0 0 var(--border-width-thick) var(--color-primary-500),
      var(--shadow-lg);
  }

  .is-loading .podcast-episode__image-wrapper {
    opacity: var(--opacity-medium);
  }

  .has-error .podcast-episode__image-wrapper {
    opacity: var(--opacity-low);
  }
</style>

<script>
  // Initialize custom audio players when DOM is loaded
  document.addEventListener("DOMContentLoaded", initAllAudioPlayers);

  // Also run if DOM is already loaded
  if (document.readyState === "complete" || document.readyState === "interactive") {
    setTimeout(initAllAudioPlayers, 100);
  }

  // Format time in MM:SS format
  function formatTime(seconds: number): string {
    if (isNaN(seconds) || !isFinite(seconds)) {
      return "0:00";
    }

    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);

    return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
  }

  // Find parent episode container
  function findParentEpisode(element: Element): Element | null {
    let current: Element | null = element;
    while (current && !current.classList.contains("podcast-episode")) {
      current = current.parentElement;
    }
    return current;
  }

  // Initialize all audio players on the page
  function initAllAudioPlayers(): void {
    try {
      const audioElements = document.querySelectorAll(
        ".podcast-episode__audio"
      ) as NodeListOf<HTMLAudioElement>;
      console.log(`Found ${audioElements.length} audio players`);

      audioElements.forEach((audio: HTMLAudioElement) => {
        console.log(`Initializing audio player for: ${audio.dataset.audioUrl}`);
        initSingleAudioPlayer(audio);
      });
    } catch (err) {
      console.error("Error initializing audio players:", err);
    }
  }

  // Initialize a single audio player with custom UI
  function initSingleAudioPlayer(audio: HTMLAudioElement): void {
    try {
      const episodeElement = findParentEpisode(audio);
      if (!episodeElement) {
        console.error("No parent episode found");
        return;
      }

      // Get custom player elements
      const playButton = episodeElement.querySelector(
        ".podcast-episode__play-button"
      ) as HTMLButtonElement;
      const progressIndicator = episodeElement.querySelector(
        ".podcast-episode__progress-indicator"
      ) as HTMLElement;
      const progressContainer = episodeElement.querySelector(
        ".podcast-episode__progress-container"
      ) as HTMLElement;
      const currentTimeDisplay = episodeElement.querySelector(
        ".podcast-episode__current-time"
      ) as HTMLElement;
      const totalTimeDisplay = episodeElement.querySelector(
        ".podcast-episode__total-time"
      ) as HTMLElement;

      if (
        !playButton ||
        !progressIndicator ||
        !progressContainer ||
        !currentTimeDisplay ||
        !totalTimeDisplay
      ) {
        console.error("Missing player UI elements");
        return;
      }

      // Remove existing event listeners to prevent duplicates
      const newPlayButton = playButton.cloneNode(true) as HTMLButtonElement;
      playButton.parentNode?.replaceChild(newPlayButton, playButton);

      // Get the new button reference
      const cleanPlayButton = episodeElement.querySelector(
        ".podcast-episode__play-button"
      ) as HTMLButtonElement;

      // Reset audio state
      audio.pause();
      audio.currentTime = 0;
      episodeElement.classList.remove("is-playing", "is-loading", "has-error");
      cleanPlayButton.setAttribute("aria-label", "Play audio");

      // Play/Pause button functionality
      cleanPlayButton.addEventListener("click", () => {
        console.log("Play button clicked");
        const allAudio = document.querySelectorAll(
          ".podcast-episode__audio"
        ) as NodeListOf<HTMLAudioElement>;

        // Pause all other audio players
        allAudio.forEach((otherAudio: HTMLAudioElement) => {
          if (otherAudio !== audio && !otherAudio.paused) {
            otherAudio.pause();
            const otherEpisode = findParentEpisode(otherAudio);
            if (otherEpisode) {
              otherEpisode.classList.remove("is-playing");
              const otherButton = otherEpisode.querySelector(
                ".podcast-episode__play-button"
              ) as HTMLButtonElement;
              if (otherButton) {
                otherButton.setAttribute("aria-label", "Play audio");
              }
            }
          }
        });

        if (audio.paused) {
          console.log("Attempting to play audio...");

          // Load audio on first play if not already loaded
          if (audio.readyState === 0) {
            console.log("Loading audio metadata first...");
            audio.load();

            // Wait for metadata to load before playing
            audio.addEventListener(
              "loadedmetadata",
              () => {
                console.log("Metadata loaded, now attempting to play...");
                playAudio();
              },
              { once: true }
            );

            audio.addEventListener(
              "error",
              (event) => {
                console.error("Error loading audio metadata:", event);
                episodeElement.classList.add("has-error");
              },
              { once: true }
            );
          } else {
            playAudio();
          }
        } else {
          console.log("Pausing audio...");
          audio.pause();
          episodeElement.classList.remove("is-playing");
          cleanPlayButton.setAttribute("aria-label", "Play audio");
        }

        // Helper function to actually play the audio
        function playAudio() {
          if (!episodeElement) {
            console.error("Episode element not found");
            return;
          }

          audio
            .play()
            .then(() => {
              console.log("Audio started successfully");
              episodeElement.classList.add("is-playing");
              cleanPlayButton.setAttribute("aria-label", "Pause audio");
            })
            .catch((error: Error) => {
              console.error("Error playing audio:", error);

              // Handle specific autoplay policy errors
              if (error.name === "NotAllowedError" || error.message.includes("user gesture")) {
                console.log("Autoplay blocked - user interaction required");
                // Show user-friendly message
                episodeElement.classList.add("has-error");
                // You could show a message to the user here
              } else {
                episodeElement.classList.add("has-error");
              }
            });
        }
      });

      // Progress bar click functionality (seek)
      progressContainer.addEventListener("click", function (event: MouseEvent) {
        const rect = this.getBoundingClientRect();
        const clickPosition = (event.clientX - rect.left) / rect.width;
        audio.currentTime = clickPosition * audio.duration;
      });

      // Update progress bar and time display
      audio.addEventListener("timeupdate", () => {
        if (audio.duration && isFinite(audio.duration)) {
          const progress = (audio.currentTime / audio.duration) * 100;
          progressIndicator.style.width = `${progress}%`;
          currentTimeDisplay.textContent = formatTime(audio.currentTime);

          // Add visual feedback for progress
          const bars = progressContainer.querySelectorAll(".podcast-episode__waveform-bar");
          const activeBarCount = Math.floor((progress / 100) * bars.length);

          bars.forEach((bar, index) => {
            if (index < activeBarCount) {
              bar.classList.add("active");
            } else {
              bar.classList.remove("active");
            }
          });
        }
      });

      // Set total duration when metadata is loaded
      audio.addEventListener("loadedmetadata", () => {
        if (audio.duration && isFinite(audio.duration)) {
          totalTimeDisplay.textContent = formatTime(audio.duration);
          progressIndicator.style.width = "0%";
        }
      });

      // Update play button state
      audio.addEventListener("play", () => {
        episodeElement.classList.add("is-playing");
        cleanPlayButton.setAttribute("aria-label", "Pause audio");
      });

      audio.addEventListener("pause", () => {
        episodeElement.classList.remove("is-playing");
        cleanPlayButton.setAttribute("aria-label", "Play audio");
      });

      audio.addEventListener("ended", () => {
        episodeElement.classList.remove("is-playing");
        cleanPlayButton.setAttribute("aria-label", "Play audio");
        progressIndicator.style.width = "0%";
        audio.currentTime = 0;
      });

      // Loading state
      audio.addEventListener("loadstart", () => {
        console.log("Audio loadstart event fired");
        episodeElement.classList.add("is-loading");
      });

      audio.addEventListener("waiting", () => {
        console.log("Audio waiting event fired");
        episodeElement.classList.add("is-loading");
      });

      audio.addEventListener("canplay", () => {
        console.log("Audio canplay event fired");
        episodeElement.classList.remove("is-loading");
      });

      audio.addEventListener("canplaythrough", () => {
        console.log("Audio canplaythrough event fired");
        episodeElement.classList.remove("is-loading");
      });

      // Error handling
      audio.addEventListener("error", (event) => {
        console.error("Audio error event fired:", event);
        console.error("Audio error details:", audio.error);
        episodeElement.classList.remove("is-playing", "is-loading");
        episodeElement.classList.add("has-error");
      });

      // Add keyboard accessibility
      cleanPlayButton.addEventListener("keydown", (event: KeyboardEvent) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          cleanPlayButton.click();
        }
      });

      console.log("Player initialized successfully");
    } catch (err) {
      console.error("Failed to initialize player:", err);
    }
  }
</script>

<style>
  /* Custom Audio Player Styles - SoundCloud Style */
  .podcast-episode__custom-player {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: var(--space-md);
    align-items: center;
    width: 100%;
    padding: var(--space-md);
    background: var(--bg-tertiary);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-md);
    margin: var(--space-md) 0;
  }

  /* Extra Large Play Button */
  .podcast-episode__play-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100px;
    height: 100px;
    border-radius: var(--radius-full);
    border: none;
    background: var(--color-primary-500);
    color: var(--color-white);
    cursor: pointer;
    transition: all var(--transition-fast);
    box-shadow: var(--shadow-lg);
    position: relative;
    z-index: 2;
  }

  .podcast-episode__play-button:hover {
    background: var(--color-primary-600);
    transform: scale(var(--animation-scale-hover-subtle));
  }

  .podcast-episode__play-button:active {
    transform: scale(var(--animation-scale-hover));
  }

  .podcast-episode__play-button:focus-visible {
    outline: var(--focus-outline);
    outline-offset: var(--focus-ring-offset);
    box-shadow: var(--focus-ring);
  }

  /* Play/Pause Icons */
  .podcast-episode__play-icon,
  .podcast-episode__pause-icon {
    width: 60px;
    height: 60px;
  }

  .podcast-episode__pause-icon {
    display: none;
  }

  .is-playing .podcast-episode__play-icon {
    display: none;
  }

  .is-playing .podcast-episode__pause-icon {
    display: inline;
  }

  /* SoundCloud-style Waveform Progress Bar */
  .podcast-episode__progress-container {
    position: relative;
    height: 60px;
    background: var(--bg-tertiary);
    border-radius: var(--radius-lg);
    overflow: hidden;
    cursor: pointer;
    width: 100%;
    transition: all var(--transition-normal);
  }

  .podcast-episode__waveform-bg {
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 100%;
    width: 100%;
    padding: var(--space-sm);
    gap: 2px;
  }

  .podcast-episode__waveform-bar {
    flex: 1;
    background: var(--color-white);
    border-radius: var(--radius-sm);
    min-height: 8px;
    max-height: 80%;
    transition: all var(--transition-normal);
    position: relative;
    box-shadow: var(--shadow-sm);
  }

  .podcast-episode__waveform-bar::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--color-primary-400), var(--color-primary-500));
    border-radius: var(--radius-sm);
    transform: scaleY(0);
    transform-origin: bottom;
    transition: transform var(--transition-normal);
  }

  .podcast-episode__progress-indicator {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 0%;
    background: linear-gradient(
      90deg,
      rgba(var(--color-primary-rgb), 0.05),
      rgba(var(--color-primary-rgb), 0.1)
    );
    pointer-events: none;
    z-index: 1;
    transition: width var(--transition-fast);
  }

  /* Active bars styling - fill up with color */
  .podcast-episode__waveform-bar.active::after {
    transform: scaleY(1);
    background: linear-gradient(to top, var(--color-primary-500), var(--color-primary-600));
  }

  /* Active state when playing */
  .is-playing .podcast-episode__waveform-bar.active::after {
    background: linear-gradient(to top, var(--color-primary-500), var(--color-primary-600));
    animation: pulse var(--animation-pulse-duration) infinite;
  }

  @keyframes pulse {
    0%,
    100% {
      opacity: 1;
    }
    50% {
      opacity: 0.8;
    }
  }

  /* Loading state */
  .is-loading .podcast-episode__progress-container {
    opacity: var(--opacity-medium);
  }

  .is-loading .podcast-episode__waveform-bar {
    animation: loading-wave var(--animation-duration-slow) infinite;
  }

  @keyframes loading-wave {
    0%,
    100% {
      transform: scaleY(0.3);
    }
    50% {
      transform: scaleY(1);
    }
  }

  /* Error state */
  .has-error .podcast-episode__progress-container {
    background: var(--bg-error);
  }

  .has-error .podcast-episode__waveform-bar {
    background: var(--color-error-100);
  }

  .has-error .podcast-episode__waveform-bar::after {
    background: linear-gradient(to top, var(--color-error-400), var(--color-error-500));
  }

  /* Time Display */
  .podcast-episode__time-display {
    font-family: var(--font-family-mono);
    font-size: var(--text-sm);
    color: var(--text-secondary);
    white-space: nowrap;
    padding: var(--space-xs) var(--space-sm);
    background: rgba(255, 255, 255, 0.1);
    border-radius: var(--radius-md);
  }

  .podcast-episode__time-separator {
    margin: 0 4px;
    opacity: 0.5;
  }

  /* Loading State */
  .is-loading .podcast-episode__play-button {
    opacity: var(--opacity-medium);
    animation: pulse var(--animation-pulse-duration) infinite;
  }

  @keyframes pulse {
    0% {
      opacity: var(--opacity-medium);
      transform: scale(var(--animation-scale-default));
    }
    50% {
      opacity: var(--opacity-low);
      transform: scale(var(--animation-scale-hover));
    }
    100% {
      opacity: var(--opacity-medium);
      transform: scale(var(--animation-scale-default));
    }
  }

  /* Error State */
  .has-error .podcast-episode__play-button {
    background: var(--color-error-500);
    cursor: not-allowed;
  }

  /* Responsive Adjustments */
  @media (max-width: 640px) {
    .podcast-episode__custom-player {
      grid-template-columns: auto 1fr;
      grid-template-rows: auto auto;
      gap: var(--space-sm);
    }

    .podcast-episode__play-button {
      grid-row: span 2;
      width: 80px;
      height: 80px;
    }

    .podcast-episode__play-icon,
    .podcast-episode__pause-icon {
      width: 40px;
      height: 40px;
    }

    .podcast-episode__progress-container {
      height: 40px;
    }

    .podcast-episode__time-display {
      grid-column: 2;
      justify-self: start;
      font-size: var(--text-xs);
    }
  }

  /* Screen reader only class */
  .sr-only {
    position: absolute;
    width: var(--sr-only-width);
    height: var(--sr-only-height);
    padding: 0;
    margin: var(--sr-only-margin);
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>
