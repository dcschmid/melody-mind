---
/**
 * PodcastEpisode Component
 *
 * Renders a podcast episode with image, description, and custom audio player.
 * Features responsive design, performance optimizations, and accessibility.
 *
 * @component
 * @example
 * <PodcastEpisode podcast={podcastData} lang="en" className="featured" />
 */
import type { PodcastData } from "../../types/podcast";
import { useTranslations } from "../../utils/i18n";
import Headline from "../Headline.astro";
import Paragraph from "../Paragraph.astro";

/**
 * Props for the PodcastEpisode component
 * @interface Props
 * @property {PodcastData} podcast - The podcast episode data
 * @property {string} lang - Language code for internationalization
 * @property {string} [className] - Optional CSS class for styling
 */
interface Props {
  podcast: PodcastData;
  lang: string;
  className?: string;
}

const { podcast, lang, className = "" } = Astro.props;
const t = useTranslations(lang);

// Generate unique ID for this episode instance
const audioId = `podcast-audio-${podcast.id}`;
---

<article class={`podcast-episode ${className}`} data-podcast-id={podcast.id}>
  <!-- Episode Header -->
  <div class="podcast-episode__header">
    <!-- Episode Image -->
    <div class="podcast-episode__image-wrapper">
      <img
        src={podcast.imageUrl}
        alt={podcast.title}
        class="podcast-episode__image"
        loading="lazy"
        width="800"
        height="450"
      />
      <div class="podcast-episode__image-overlay">
        <span class="podcast-episode__badge">Podcast</span>
      </div>
    </div>

    <!-- Episode Info -->
    <div class="podcast-episode__info">
      <Headline
        level="h2"
        title={podcast.title}
        size="2xl"
        textAlign="center"
        className="podcast-episode__title"
      />
      <div class="podcast-episode__divider"></div>
      <Paragraph
        description={podcast.description}
        textSize="lg"
        align="center"
        className="podcast-episode__description"
      />

      <!-- Episode Meta -->
      {/* Datum entfernt */}
    </div>
  </div>

  <!-- Audio Player -->
  <div class="podcast-episode__player-wrapper">
    <div class="podcast-episode__player">
      <!-- Hidden native audio element -->
      <audio
        id={audioId}
        preload="none"
        class="podcast-episode__audio"
        data-episode-id={podcast.id}
        data-audio-url={podcast.audioUrl}
      >
        <source src={podcast.audioUrl} type="audio/mpeg" />
        {
          podcast.subtitleUrl && (
            <track
              kind="captions"
              src={podcast.subtitleUrl}
              srclang={podcast.language || lang}
              label={t("podcasts.captions")}
              default
            />
          )
        }
        {t("podcasts.audio.not_supported")}
      </audio>

      <!-- Custom player controls -->
      <div class="podcast-episode__custom-player">
        <button class="podcast-episode__play-button" aria-label="Play audio" type="button">
          <svg class="podcast-episode__play-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"></path>
          </svg>
          <svg class="podcast-episode__pause-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
          </svg>
        </button>

        <div class="podcast-episode__progress-container">
          <div class="podcast-episode__waveform-bg">
            {
              Array(50)
                .fill(0)
                .map((_, _index) => (
                  <div
                    class="podcast-episode__waveform-bar"
                    style={`height: ${Math.floor(Math.random() * 70) + 10}%`}
                  />
                ))
            }
          </div>
          <div class="podcast-episode__progress-indicator"></div>
        </div>

        <div class="podcast-episode__time-display">
          <span class="podcast-episode__current-time">0:00</span>
          <span class="podcast-episode__time-separator">/</span>
          <span class="podcast-episode__total-time">0:00</span>
        </div>
      </div>
    </div>
  </div>
</article>

<style lang="scss">
  /* ======================================
   * PODCAST EPISODE COMPONENT - SCSS Version
   * Uses global.css variables for consistency
   * ====================================== */

  /**
   * Episode Container - Main wrapper with performance optimizations
   * Uses CSS containment and will-change for better performance
   */
  .podcast-episode {
    background: var(--card-bg);
    border-radius: var(--radius-xl);
    overflow: hidden;
    box-shadow: var(--card-shadow);
    border: var(--border-width-thin) solid var(--border-primary);
    margin-bottom: var(--space-lg);
    transition: all var(--transition-normal);
    container-type: inline-size;
    container-name: podcast-episode;
    width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    contain: layout style paint;
    will-change: transform, box-shadow;

    @media (min-width: 48em) {
      margin-bottom: var(--space-xl);
    }

    &:hover {
      box-shadow: var(--card-shadow-hover);
      transform: translateY(var(--animation-y-offset-small));
    }

    &:focus-within {
      outline: var(--focus-outline);
      outline-offset: var(--focus-ring-offset);
      box-shadow: var(--focus-ring), var(--card-shadow-hover);
    }

    // Performance optimization for reduced motion
    @media (prefers-reduced-motion: reduce) {
      will-change: auto;
      transition: none;

      &:hover {
        transform: none;
      }
    }
  }

  // Episode Header Layout - Enhanced Responsive Grid
  .podcast-episode__header {
    display: grid;
    gap: var(--space-md);
    padding: var(--space-md);
    align-items: start;
    width: 100%;
    box-sizing: border-box;
    background: linear-gradient(to bottom, var(--bg-tertiary), var(--card-bg));

    // Mobile First: Single column layout
    grid-template-columns: 1fr;
    grid-template-areas:
      "image"
      "info";
    text-align: center;

    @media (min-width: 30em) {
      padding: var(--space-lg);
      gap: var(--space-lg);
    }

    // Small tablet: Image + Info side by side
    @media (min-width: 40em) {
      grid-template-columns: 220px 1fr;
      grid-template-areas: "image info";
      text-align: left;
      gap: var(--space-lg);
    }

    // Large tablet and Desktop: Wider image
    @media (min-width: 48em) {
      grid-template-columns: 280px 1fr;
      padding: var(--space-xl) var(--space-xl) var(--space-lg);
      gap: var(--space-xl);
    }

    // Large desktop: Even wider image
    @media (min-width: 64em) {
      grid-template-columns: 320px 1fr;
    }

    // Extra large screens
    @media (min-width: 80em) {
      grid-template-columns: 360px 1fr;
      gap: var(--space-2xl);
    }
  }

  /**
   * Episode Image with Overlay - Optimized for performance
   * Uses transform3d for hardware acceleration and content-visibility
   */
  .podcast-episode__image-wrapper {
    position: relative;
    grid-area: image;
    width: 100%;
    aspect-ratio: 16/9;
    border-radius: var(--radius-lg);
    overflow: hidden;
    box-shadow: var(--shadow-lg);
    background: var(--bg-tertiary);
    transform: translate3d(0, 0, 0); // Hardware acceleration
    transition:
      transform var(--transition-normal),
      box-shadow var(--transition-normal);
    content-visibility: auto;
    contain: layout style paint;

    &:hover {
      transform: translate3d(0, 0, 0) scale(var(--animation-scale-hover-subtle));
      box-shadow: var(--shadow-xl);
    }

    @media (max-width: 39.9375em) {
      max-width: 300px;
      margin: 0 auto;
    }

    // Performance optimization for reduced motion
    @media (prefers-reduced-motion: reduce) {
      transition: none;

      &:hover {
        transform: translate3d(0, 0, 0);
      }
    }
  }

  /**
   * Episode Image - Optimized loading and rendering
   * Uses object-fit for proper scaling and loading="lazy"
   */
  .podcast-episode__image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    transition: transform var(--transition-slow);
    // Performance optimization
    transform: translate3d(0, 0, 0);
    will-change: transform;

    .podcast-episode:hover & {
      transform: translate3d(0, 0, 0) scale(var(--animation-scale-medium));
    }

    // Performance optimization for reduced motion
    @media (prefers-reduced-motion: reduce) {
      will-change: auto;
      transition: none;

      .podcast-episode:hover & {
        transform: translate3d(0, 0, 0);
      }
    }
  }

  .podcast-episode__image-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0) 50%);
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding: var(--space-md);
    transition: background var(--transition-normal);

    .podcast-episode:hover & {
      background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0.2) 70%);
    }
  }

  .podcast-episode__badge {
    display: inline-block;
    background: var(--color-primary-500);
    color: var(--color-white);
    font-size: var(--text-xs);
    font-weight: var(--font-bold);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--radius-pill);
    text-transform: uppercase;
    letter-spacing: var(--letter-spacing-enhanced);
    box-shadow: var(--shadow-sm);
    align-self: flex-start;
  }

  // Episode Info
  .podcast-episode__info {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
    grid-area: info;
    min-width: 0; // Prevent text overflow
  }

  .podcast-episode__divider {
    width: 60px;
    height: 3px;
    background: var(--color-primary-500);
    border-radius: var(--radius-pill);
    margin: 0 auto var(--space-md); /* Immer zentriert, oben kein Abstand */
    opacity: 0.8;
  }

  // Meta Information
  .podcast-episode__meta {
    display: flex;
    gap: var(--space-md);
    flex-wrap: wrap;
    justify-content: center;
    margin-top: var(--space-xs);

    @media (min-width: 40em) {
      justify-content: flex-start;
    }
  }

  .podcast-episode__meta-item {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    font-size: var(--text-sm);
    color: var(--text-tertiary);
    padding: var(--space-xs) var(--space-sm);
    background: var(--bg-tertiary);
    border-radius: var(--radius-pill);
    box-shadow: var(--shadow-xs);
  }

  .podcast-episode__meta-icon {
    font-size: 1.1em;
  }

  .podcast-episode__meta-text {
    font-weight: var(--font-medium);
  }

  // Audio Player Wrapper
  .podcast-episode__player-wrapper {
    padding: var(--space-md);
    background: var(--card-bg);
    border-top: var(--border-width-thin) solid var(--border-primary);

    @media (min-width: 30em) {
      padding: var(--space-lg);
    }
  }

  // Native Audio Player
  .podcast-episode__audio {
    display: none; // Hide native controls
  }

  /**
   * Custom Audio Player - SoundCloud-style with performance optimizations
   * Uses CSS Grid for flexible layout and containment for performance
   */
  .podcast-episode__custom-player {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: var(--space-md);
    align-items: center;
    width: 100%;
    padding: var(--space-md);
    background: var(--bg-tertiary);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-md);
    margin: var(--space-md) 0;
    contain: layout style;
    content-visibility: auto;

    @media (max-width: 39.9375em) {
      grid-template-columns: auto 1fr;
      grid-template-rows: auto auto;
      gap: var(--space-sm);
    }
  }

  /**
   * Play Button - Large, accessible, and performant
   * Uses hardware acceleration and proper touch targets
   */
  .podcast-episode__play-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100px;
    height: 100px;
    border-radius: var(--radius-full);
    border: none;
    background: var(--color-primary-500);
    color: var(--color-white);
    cursor: pointer;
    transition: all var(--transition-fast);
    box-shadow: var(--shadow-lg);
    position: relative;
    z-index: 2;
    transform: translate3d(0, 0, 0); // Hardware acceleration
    will-change: transform, background-color;
    // Enhanced touch target
    min-width: var(--min-touch-size);
    min-height: var(--min-touch-size);

    &:hover {
      background: var(--color-primary-600);
      transform: translate3d(0, 0, 0) scale(var(--animation-scale-hover-subtle));
    }

    &:active {
      transform: translate3d(0, 0, 0) scale(var(--animation-scale-hover));
    }

    &:focus-visible {
      outline: var(--focus-outline);
      outline-offset: var(--focus-ring-offset);
      box-shadow: var(--focus-ring);
    }

    @media (max-width: 39.9375em) {
      grid-row: span 2;
      width: 80px;
      height: 80px;
    }

    // Performance optimization for reduced motion
    @media (prefers-reduced-motion: reduce) {
      will-change: auto;
      transition: background-color var(--transition-fast);

      &:hover,
      &:active {
        transform: translate3d(0, 0, 0);
      }
    }
  }

  // Play/Pause Icons
  .podcast-episode__play-icon,
  .podcast-episode__pause-icon {
    width: 60px;
    height: 60px;

    @media (max-width: 39.9375em) {
      width: 40px;
      height: 40px;
    }
  }

  .podcast-episode__pause-icon {
    display: none;
  }

  .is-playing .podcast-episode__play-icon {
    display: none;
  }

  .is-playing .podcast-episode__pause-icon {
    display: inline;
  }

  /**
   * Waveform Progress Bar - SoundCloud-style with performance optimizations
   * Uses CSS containment and optimized rendering
   */
  .podcast-episode__progress-container {
    position: relative;
    height: 60px;
    background: var(--bg-tertiary);
    border-radius: var(--radius-lg);
    overflow: hidden;
    cursor: pointer;
    width: 100%;
    transition: all var(--transition-normal);
    contain: layout style paint;
    transform: translate3d(0, 0, 0); // Hardware acceleration
    // Enhanced touch target
    min-height: var(--min-touch-size);

    @media (max-width: 39.9375em) {
      height: 40px;
    }

    // Performance optimization for reduced motion
    @media (prefers-reduced-motion: reduce) {
      transition: none;
    }
  }

  .podcast-episode__waveform-bg {
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 100%;
    width: 100%;
    padding: var(--space-sm);
    gap: 2px;
  }

  /**
   * Waveform Bars - Individual bars with optimized animations
   * Uses transform3d for hardware acceleration
   */
  .podcast-episode__waveform-bar {
    flex: 1;
    background: var(--color-white);
    border-radius: var(--radius-sm);
    min-height: 8px;
    max-height: 80%;
    transition: all var(--transition-normal);
    position: relative;
    box-shadow: var(--shadow-sm);
    transform: translate3d(0, 0, 0); // Hardware acceleration
    will-change: transform;

    &::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to top, var(--color-primary-400), var(--color-primary-500));
      border-radius: var(--radius-sm);
      transform: translate3d(0, 0, 0) scaleY(0);
      transform-origin: bottom;
      transition: transform var(--transition-normal);
    }

    &.active::after {
      transform: translate3d(0, 0, 0) scaleY(1);
      background: linear-gradient(to top, var(--color-primary-500), var(--color-primary-600));
    }

    // Performance optimization for reduced motion
    @media (prefers-reduced-motion: reduce) {
      will-change: auto;
      transition: none;

      &::after {
        transition: none;
      }
    }
  }

  .podcast-episode__progress-indicator {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 0%;
    background: linear-gradient(
      90deg,
      rgba(var(--color-primary-rgb), 0.05),
      rgba(var(--color-primary-rgb), 0.1)
    );
    pointer-events: none;
    z-index: 1;
    transition: width var(--transition-fast);
  }

  // Active state when playing
  .is-playing .podcast-episode__waveform-bar.active::after {
    background: linear-gradient(to top, var(--color-primary-500), var(--color-primary-600));
    animation: pulse var(--animation-pulse-duration) infinite;
  }

  @keyframes pulse {
    0%,
    100% {
      opacity: 1;
    }
    50% {
      opacity: 0.8;
    }
  }

  // Loading state
  .is-loading .podcast-episode__progress-container {
    opacity: var(--opacity-medium);
  }

  .is-loading .podcast-episode__waveform-bar {
    animation: loading-wave var(--animation-duration-slow) infinite;
  }

  @keyframes loading-wave {
    0%,
    100% {
      transform: scaleY(0.3);
    }
    50% {
      transform: scaleY(1);
    }
  }

  // Error state
  .has-error .podcast-episode__progress-container {
    background: var(--bg-error);
  }

  .has-error .podcast-episode__waveform-bar {
    background: var(--color-error-100);

    &::after {
      background: linear-gradient(to top, var(--color-error-400), var(--color-error-500));
    }
  }

  // Time Display
  .podcast-episode__time-display {
    font-family: var(--font-family-mono);
    font-size: var(--text-sm);
    color: var(--text-secondary);
    white-space: nowrap;
    padding: var(--space-xs) var(--space-sm);
    background: rgba(255, 255, 255, 0.1);
    border-radius: var(--radius-md);

    @media (max-width: 39.9375em) {
      grid-column: 2;
      justify-self: start;
      font-size: var(--text-xs);
    }
  }

  .podcast-episode__time-separator {
    margin: 0 4px;
    opacity: 0.5;
  }

  // Loading State
  .is-loading .podcast-episode__play-button {
    opacity: var(--opacity-medium);
    animation: pulse var(--animation-pulse-duration) infinite;
  }

  // Error State
  .has-error .podcast-episode__play-button {
    background: var(--color-error-500);
    cursor: not-allowed;
  }

  // States
  .is-playing .podcast-episode__image-wrapper {
    box-shadow:
      0 0 0 var(--border-width-thick) var(--color-primary-500),
      var(--shadow-lg);
  }

  .is-loading .podcast-episode__image-wrapper {
    opacity: var(--opacity-medium);
  }

  .has-error .podcast-episode__image-wrapper {
    opacity: var(--opacity-low);
  }

  // Screen reader only class
  .sr-only {
    position: absolute;
    width: var(--sr-only-width);
    height: var(--sr-only-height);
    padding: 0;
    margin: var(--sr-only-margin);
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>

<script>
  // Format time in MM:SS format
  const formatTime = (seconds: number): string => {
    if (isNaN(seconds) || !isFinite(seconds)) {
      return "0:00";
    }

    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);

    return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
  };

  // Find parent episode container
  const findParentEpisode = (element: Element): Element | null => {
    let current: Element | null = element;
    while (current && !current.classList.contains("podcast-episode")) {
      current = current.parentElement;
    }
    return current;
  };

  // Initialize a single audio player with custom UI
  const initSingleAudioPlayer = (audio: HTMLAudioElement): void => {
    try {
      const episodeElement = findParentEpisode(audio);
      if (!episodeElement) {
        console.error("No parent episode found");
        return;
      }

      // Get custom player elements
      const playButton = episodeElement.querySelector(
        ".podcast-episode__play-button"
      ) as HTMLButtonElement;
      const progressIndicator = episodeElement.querySelector(
        ".podcast-episode__progress-indicator"
      ) as HTMLElement;
      const progressContainer = episodeElement.querySelector(
        ".podcast-episode__progress-container"
      ) as HTMLElement;
      const currentTimeDisplay = episodeElement.querySelector(
        ".podcast-episode__current-time"
      ) as HTMLElement;
      const totalTimeDisplay = episodeElement.querySelector(
        ".podcast-episode__total-time"
      ) as HTMLElement;

      if (
        !playButton ||
        !progressIndicator ||
        !progressContainer ||
        !currentTimeDisplay ||
        !totalTimeDisplay
      ) {
        console.error("Missing player UI elements");
        return;
      }

      // Remove existing event listeners to prevent duplicates
      const newPlayButton = playButton.cloneNode(true) as HTMLButtonElement;
      playButton.parentNode?.replaceChild(newPlayButton, playButton);

      // Get the new button reference
      const cleanPlayButton = episodeElement.querySelector(
        ".podcast-episode__play-button"
      ) as HTMLButtonElement;

      // Reset audio state
      audio.pause();
      audio.currentTime = 0;
      episodeElement.classList.remove("is-playing", "is-loading", "has-error");
      cleanPlayButton.setAttribute("aria-label", "Play audio");

      // Helper function to actually play the audio
      const playAudio = async (): Promise<void> => {
        if (!episodeElement) {
          console.error("Episode element not found");
          return;
        }

        try {
          await audio.play();
          console.log("Audio started successfully");
          episodeElement.classList.add("is-playing");
          cleanPlayButton.setAttribute("aria-label", "Pause audio");
        } catch (error: unknown) {
          console.error("Error playing audio:", error);

          // Handle specific autoplay policy errors
          if (
            error instanceof Error &&
            (error.name === "NotAllowedError" || error.message.includes("user gesture"))
          ) {
            console.log("Autoplay blocked - user interaction required");
            episodeElement.classList.add("has-error");
          } else {
            episodeElement.classList.add("has-error");
          }
        }
      };

      // Play/Pause button functionality
      cleanPlayButton.addEventListener("click", () => {
        console.log("Play button clicked");
        const allAudio = document.querySelectorAll(
          ".podcast-episode__audio"
        ) as NodeListOf<HTMLAudioElement>;

        // Pause all other audio players
        allAudio.forEach((otherAudio: HTMLAudioElement) => {
          if (otherAudio !== audio && !otherAudio.paused) {
            otherAudio.pause();
            const otherEpisode = findParentEpisode(otherAudio);
            if (otherEpisode) {
              otherEpisode.classList.remove("is-playing");
              const otherButton = otherEpisode.querySelector(
                ".podcast-episode__play-button"
              ) as HTMLButtonElement;
              if (otherButton) {
                otherButton.setAttribute("aria-label", "Play audio");
              }
            }
          }
        });

        if (audio.paused) {
          console.log("Attempting to play audio...");

          // Load audio on first play if not already loaded
          if (audio.readyState === 0) {
            console.log("Loading audio metadata first...");
            audio.load();

            // Wait for metadata to load before playing
            audio.addEventListener(
              "loadedmetadata",
              () => {
                console.log("Metadata loaded, now attempting to play...");
                playAudio();
              },
              { once: true }
            );

            audio.addEventListener(
              "error",
              (event) => {
                console.error("Error loading audio metadata:", event);
                episodeElement.classList.add("has-error");
              },
              { once: true }
            );
          } else {
            playAudio();
          }
        } else {
          console.log("Pausing audio...");
          audio.pause();
          episodeElement.classList.remove("is-playing");
          cleanPlayButton.setAttribute("aria-label", "Play audio");
        }
      });

      // Progress bar click functionality (seek)
      progressContainer.addEventListener("click", (event: MouseEvent) => {
        const rect = progressContainer.getBoundingClientRect();
        const clickPosition = (event.clientX - rect.left) / rect.width;
        audio.currentTime = clickPosition * audio.duration;
      });

      // Update progress bar and time display
      audio.addEventListener("timeupdate", () => {
        if (audio.duration && isFinite(audio.duration)) {
          const progress = (audio.currentTime / audio.duration) * 100;
          progressIndicator.style.width = `${progress}%`;
          currentTimeDisplay.textContent = formatTime(audio.currentTime);

          // Add visual feedback for progress
          const bars = progressContainer.querySelectorAll(".podcast-episode__waveform-bar");
          const activeBarCount = Math.floor((progress / 100) * bars.length);

          bars.forEach((bar, index) => {
            if (index < activeBarCount) {
              bar.classList.add("active");
            } else {
              bar.classList.remove("active");
            }
          });
        }
      });

      // Set total duration when metadata is loaded
      audio.addEventListener("loadedmetadata", () => {
        if (audio.duration && isFinite(audio.duration)) {
          totalTimeDisplay.textContent = formatTime(audio.duration);
          progressIndicator.style.width = "0%";
        }
      });

      // Update play button state
      audio.addEventListener("play", () => {
        episodeElement.classList.add("is-playing");
        cleanPlayButton.setAttribute("aria-label", "Pause audio");
      });

      audio.addEventListener("pause", () => {
        episodeElement.classList.remove("is-playing");
        cleanPlayButton.setAttribute("aria-label", "Play audio");
      });

      audio.addEventListener("ended", () => {
        episodeElement.classList.remove("is-playing");
        cleanPlayButton.setAttribute("aria-label", "Play audio");
        progressIndicator.style.width = "0%";
        audio.currentTime = 0;
      });

      // Loading state
      audio.addEventListener("loadstart", () => {
        console.log("Audio loadstart event fired");
        episodeElement.classList.add("is-loading");
      });

      audio.addEventListener("waiting", () => {
        console.log("Audio waiting event fired");
        episodeElement.classList.add("is-loading");
      });

      audio.addEventListener("canplay", () => {
        console.log("Audio canplay event fired");
        episodeElement.classList.remove("is-loading");
      });

      audio.addEventListener("canplaythrough", () => {
        console.log("Audio canplaythrough event fired");
        episodeElement.classList.remove("is-loading");
      });

      // Error handling
      audio.addEventListener("error", (event) => {
        console.error("Audio error event fired:", event);
        console.error("Audio error details:", audio.error);
        episodeElement.classList.remove("is-playing", "is-loading");
        episodeElement.classList.add("has-error");
      });

      // Add keyboard accessibility
      cleanPlayButton.addEventListener("keydown", (event: KeyboardEvent) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          cleanPlayButton.click();
        }
      });

      console.log("Player initialized successfully");
    } catch (err) {
      console.error("Failed to initialize player:", err);
    }
  };

  // Initialize all audio players on the page
  const initAllAudioPlayers = (): void => {
    try {
      const audioElements = document.querySelectorAll(
        ".podcast-episode__audio"
      ) as NodeListOf<HTMLAudioElement>;
      console.log(`Found ${audioElements.length} audio players`);

      audioElements.forEach((audio: HTMLAudioElement) => {
        console.log(`Initializing audio player for: ${audio.dataset.audioUrl}`);
        initSingleAudioPlayer(audio);
      });
    } catch (err) {
      console.error("Error initializing audio players:", err);
    }
  };

  // Initialize custom audio players when DOM is loaded
  document.addEventListener("DOMContentLoaded", initAllAudioPlayers);

  // Also run if DOM is already loaded
  if (document.readyState === "complete" || document.readyState === "interactive") {
    setTimeout(initAllAudioPlayers, 100);
  }
</script>
