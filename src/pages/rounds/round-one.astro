---
import { Icon } from "astro-icon/components";
import { Picture } from "astro:assets";
import { For } from "@astropub/flow";

import Layout from "../../layouts/Layout.astro";
import ThreeJoker from "../../components/HeaderItems/ThreeJoker.astro";
import StartOverlay from "../../components/Overlays/StartOverlay.astro";
import TimeupsOverlay from "../../components/Overlays/TimeupsOverlay.astro";
import IntroText from "../../components/Round/IntroText.astro";
import Timer from "../../components/Round/Timer.astro";
import Arrows from "../../components/Round/Arrows.astro";

function shuffleArray(array: any) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

const coverflowData = [
  {
    band: "SnowPatrol",
    album: "Eyes Open",
    data: "2006",
    coverSrc: "/bandcover/snowPatrol.jpeg",
    audioSrc: "/mp3s/snowPatrol.mp3",
  },
  {
    band: "KellyClarkson",
    album: "Breakaway",
    data: "2004",
    coverSrc: "/bandcover/kellyClarkson.jpeg",
    audioSrc: "/mp3s/kellyClarkson.mp3",
  },
  {
    band: "NoDoubt",
    album: "Tragic Kingdom",
    data: "1995",
    coverSrc: "/bandcover/noDoubt.jpg",
    audioSrc: "/mp3s/noDoubt.mp3",
  },
  {
    band: "FleetWoodMac",
    album: "Rumours",
    data: "1977",
    coverSrc: "/bandcover/fleetwoodMac.jpg",
    audioSrc: "/mp3s/fleetwoodMac.mp3",
  },
];

const randomizedCoverflowData = shuffleArray(coverflowData);
---

<Layout title="Spielrunde 1" showUserLink={false}>
  <ThreeJoker slot="left-headercol" />

  <StartOverlay headline="Runde 1 / 3" whiteText="Erscheinungsjahr: vorne das neueste, hinten das älteste." />

  <TimeupsOverlay />

  <IntroText headline="Runde 1 / 3" subline="Sortieren Sie nach dem" whiteText="Erscheinungsjahr!" />

  <div class="smallText">Älteste</div>

  <div class="coverflow">
    <For of={randomizedCoverflowData}>
      {
        (item: any) => (
          <div
            class="cover"
            data-band={item.band}
            data-album={item.album}
            data-data={item.data}
            data-cover-source={item.coverSrc}
          >
            <Picture src={item.coverSrc} width={266} height={266} formats={["avif", "webp"]} alt="" />
            <audio id={`audio-${item.band}`} src={item.audioSrc} preload="none" />
          </div>
        )
      }
    </For>

    <Arrows />

    <div class="hintText">Neueste</div>
  </div>

  <Timer minutes="01" seconds="00" />
</Layout>

<style>
  .smallText {
    color: var(--colour-text-BTN-inverted);
    text-align: center;
    font-size: 16px;
    font-style: normal;
    font-weight: 400;
    line-height: 35.28px;
  }

  .coverflow {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 400px;
    margin-bottom: var(--spacing-spacing-xl);
  }

  .cover {
    width: 114px;
    height: 114px;
    position: absolute;
  }

  .cover img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .cover.selected {
    border-radius: var(--radius-radius-rounded);
    border: 8px solid var(--colour-border-secondary);
    transform: rotate(6.6deg);
  }

  .cover:nth-child(1) {
    width: 114px;
    height: 114px;
  }

  .cover:nth-child(2) {
    width: 160px;
    height: 160px;
    top: 2.5rem;
  }

  .cover:nth-child(3) {
    width: 214px;
    height: 214px;
    top: 5rem;
  }

  .cover:nth-child(4) {
    width: 300px;
    height: 300px;
    top: 7.5rem;
  }

  .hintText {
    position: absolute;
    bottom: -2rem;
    z-index: 4;
    border-radius: var(--radius-radius-full);
    background: var(--colour-BTN-inverted);
    display: flex;
    padding: var(--spacing-spacing-xxs) var(--spacing-spacing-md);
    justify-content: center;
    align-items: center;
    gap: var(--spacing-spacing-xxs);
    font-size: 16px;
    font-style: normal;
    font-weight: 400;
    line-height: 35.28px;
    color: var(--colour-text-BTN-inverted);
  }
</style>

<script>
  import { resetLocalStorage } from "../../utils/resetLocalStorage";

  let timeRemaining = 60;
  let timerInterval: number | null = null;

  const minutesElement = document.getElementById("minutes")!;
  const secondsElement = document.getElementById("seconds")!;
  const timupsOverlay = document.getElementById("timupsOverlay");
  const endRoundButton = document.getElementById("endRound");
  const finishRoundButton = document.getElementById("finishRoundButton");

  const finalSolutionsArray = [
    {
      band: "SnowPatrol",
    },
    {
      band: "KellyClarkson",
    },
    {
      band: "NoDoubt",
    },
    {
      band: "FleetWoodMac",
    },
  ];

  /**
   * Retrieves the sorted results from the DOM and compares them with the final solutions.
   * Calculates the number of points earned and saves them to localStorage.
   * Returns nothing.
   */
  const getSortedResults = () => {
    // Get all the cover elements from the DOM and convert them to an array
    let sortedCovers = Array.from(document.querySelectorAll(".cover")).reverse();

    // Map over the cover elements and create an array of objects containing the data attributes
    const results = sortedCovers.map((cover) => ({
      band: cover.getAttribute("data-band"), // Get the band name
      album: cover.getAttribute("data-album"), // Get the album name
      date: cover.getAttribute("data-data"), // Get the release date
      coverSrc: cover.getAttribute("data-cover-source"), // Get the cover image source
      isWrong: false, // Initialize the 'isWrong' property to false
    }));

    let points = 0;
    let allCorrect = true;

    // Compare the results with the final solutions array
    results.forEach((result, index) => {
      // Check if the band name matches the band name in the final solutions array
      if (result.band === finalSolutionsArray[index]?.band) {
        points += 25; // Add 25 points for each correct match
      } else {
        result.isWrong = true; // Mark as true if not a match
        allCorrect = false; // Set allCorrect to false if there's any incorrect match
      }
    });

    // Add 25 extra points if all results are correct
    if (allCorrect) {
      points += 25;
      localStorage.setItem("allCorrectRound1", String(true));
    } else {
      localStorage.setItem("allCorrectRound1", String(false));
    }

    // Check if currentPoints exists in localStorage, if not, set it to 0
    if (localStorage.getItem("currentPoints") === null) {
      localStorage.setItem("currentPoints", "0");
    }

    // Save points to localStorage
    localStorage.setItem("PointsRound1", String(points));

    // Save results to localStorage
    localStorage.setItem("ResultsRound1", JSON.stringify(results));
  };

  /**
   * Updates the timer display and checks if the timer has reached zero.
   * If the timer has reached zero, it hides the timer overlay.
   */
  function updateTime() {
    // Calculate minutes and seconds from the remaining time
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;

    // Update the display with the formatted minutes and seconds
    minutesElement.textContent = String(minutes).padStart(2, "0");
    secondsElement.textContent = String(seconds).padStart(2, "0");

    // If the timer has reached zero, hide the timer overlay and stop the timer
    if (timeRemaining === 0) {
      clearInterval(timerInterval!);
      timupsOverlay!.style.visibility = "visible";
      getSortedResults();
    } else {
      // Otherwise, decrement the remaining time by one second
      timeRemaining--;
    }
  }

  /**
   * Starts the timer by setting an interval to call the updateTime function every second.
   */
  function startTimer() {
    // Set an interval to call the updateTime function every second
    timerInterval = window.setInterval(updateTime, 1000);
  }

  /**
   * Initializes the overlay by setting its visibility and adding a click event listener to the game button.
   * When the game button is clicked, it hides the overlay and starts the timer.
   */
  function initializeOverlay() {
    // Get the overlay and game button elements
    const startOverlay = document.getElementById("startOverlay");
    const gameButton = document.getElementById("gameButton");

    // Set the visibility of the overlay and timupsOverlay elements
    startOverlay!.style.visibility = "visible";
    timupsOverlay!.style.visibility = "hidden";

    // Add a click event listener to the game button
    gameButton!.addEventListener("click", () => {
      // Hide the overlay and start the timer
      startOverlay!.style.visibility = "hidden";
      startTimer();
    });
  }

  /**
   * Updates the state of the up and down buttons based on the currently selected cover.
   *
   * @param {HTMLElement} selectedCover - The currently selected cover element.
   * @param {HTMLElement} upButton - The up button element.
   * @param {HTMLElement} downButton - The down button element.
   */
  function updateButtonState(selectedCover: HTMLElement, upButton: HTMLElement, downButton: HTMLElement) {
    // Get the parent element of the selected cover
    const parent = selectedCover.parentElement!;
    // Get the index of the selected cover within its parent
    const index = Array.from(parent.children).indexOf(selectedCover);

    // Toggle the "disabled" class on the up button based on whether the selected cover is the first child
    upButton.classList.toggle("disabled", index === 0);
    // Toggle the "disabled" class on the down button based on whether the selected cover is within the last three children
    downButton.classList.toggle("disabled", index >= parent.children.length - 3);
  }

  /**
   * Initializes the covers by setting up event listeners for each cover,
   * handling clicks and updating the selected cover and audio.
   */
  function initializeCovers() {
    // Initialize selected cover and covers elements
    let selectedCover: HTMLElement | null = null; // The currently selected cover element
    let currentAudio: HTMLAudioElement | null = null; // The currently playing audio element
    const covers = document.querySelectorAll<HTMLElement>(".cover"); // All cover elements
    const showButtons = document.getElementById("showButtons");

    // Get up and down buttons
    const upButton = document.getElementById("up")!; // The up button element
    const downButton = document.getElementById("down")!; // The down button element

    // Add click event listener to each cover
    covers.forEach((cover) => {
      cover.addEventListener("click", () => {
        showButtons!.style.display = "inline-flex";

        // Clear the selected class from the previously selected cover
        selectedCover?.classList.remove("selected");
        // Pause the currently playing audio
        currentAudio?.pause();

        // Set the selected cover to the clicked cover
        selectedCover = cover;
        // Add the selected class to the clicked cover
        cover.classList.add("selected");

        // Get the band attribute of the clicked cover
        const band = cover.getAttribute("data-band")!;
        // Get the audio element with the corresponding id
        currentAudio = document.getElementById(`audio-${band}`) as HTMLAudioElement | null;

        // Play the audio if it exists
        if (currentAudio) {
          currentAudio.play();
        }

        // Update the state of the up and down buttons
        updateButtonState(selectedCover!, upButton, downButton);
      });
    });

    /**
     * Moves the selected cover element in the specified direction.
     * If the move is valid, the selected cover is inserted before the reference node.
     * The up and down buttons are updated accordingly.
     *
     * @param {number} direction - The direction to move the selected cover. Negative for up, positive for down.
     */
    function moveSelection(direction: number) {
      // If no cover is selected, return early
      if (!selectedCover) return;

      // Get the parent element of the selected cover
      const parent = selectedCover.parentElement!;
      // Get the index of the selected cover within its parent
      const index = Array.from(parent.children).indexOf(selectedCover);
      // Calculate the new index after moving in the specified direction
      const newIndex = index + direction;

      // If the new index is within the valid range, move the selected cover
      if (newIndex >= 0 && newIndex < parent.children.length) {
        // Determine the reference node based on the direction
        const referenceNode = direction === -1 ? parent.children[newIndex] : parent.children[newIndex].nextSibling;
        // Insert the selected cover before the reference node
        parent.insertBefore(selectedCover, referenceNode);
        selectedCover.dataset.index = index as unknown as string;

        // Update the state of the up and down buttons
        updateButtonState(selectedCover, upButton, downButton);
      }
    }

    // Add click event listeners to up and down buttons
    upButton.addEventListener("click", () => moveSelection(-1));
    downButton.addEventListener("click", () => moveSelection(1));
  }

  /**
   * Adds a click event listener to the end round button.
   * When the button is clicked, it gets the sorted results,
   * navigates to the results page for round one.
   */
  endRoundButton?.addEventListener("click", () => {
    // Get the sorted results
    getSortedResults();
    // Navigate to the results page for round one
    window.location.href = "/results/result-one";
  });

  /**
   * Adds a click event listener to the finsh round button.
   * When the button is clicked, it gets the sorted results,
   * navigates to the results page for round one.
   */
  finishRoundButton?.addEventListener("click", () => {
    // Get the sorted results
    getSortedResults();
    // Navigate to the results page for round one
    window.location.href = "/results/result-one";
  });

  window.addEventListener("load", function () {
    resetLocalStorage();
    initializeOverlay();
    initializeCovers();
  });
</script>
