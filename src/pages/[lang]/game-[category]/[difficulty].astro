---
import Layout from "@layouts/Layout.astro";
import ShowCoins from "@components/Shared/ShowCoins.astro";
import { getTitleBasedOnDifficulty } from "@utils/getTitleBasedOnDifficulty";
import GameHeadline from "@components/Game/GameHeadline.astro";
import FeedbackOverlay from "@components/Overlays/FeedbackOverlay.astro";
import EndOverlay from "@components/Overlays/EndOverlay.astro";
import LoadingSpinner from "@components/Game/LoadingSpinner.astro";
import Joker from "@components/Game/Joker.astro";
import ErrorMessage from "@components/Shared/ErrorMessage.astro";
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import type { Difficulty as GameDifficulty } from "@utils/game/jokerUtils";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
const { category, difficulty } = Astro.params;

// Dynamic import of categories based on language
let categories;
try {
  categories = await import(/* @vite-ignore */ `@json/${lang}_categories.json`);
} catch (error) {
  // Fallback to default language if the specific language file doesn't exist
  categories = await import(/* @vite-ignore */ `@json/de_categories.json`);
}

// No login check needed anymore
const user = { id: "guest" }; // Default user for game functionality

const currentCategoryData = categories.default.find(
  (cat: any) => cat.slug === category,
);

const playerTitle = getTitleBasedOnDifficulty(difficulty as GameDifficulty);
---

<Layout title={`${currentCategoryData?.headline}`} showCoins={true}>
  <div slot="left-headercol">
    <ShowCoins />
  </div>

  <FeedbackOverlay />

  <EndOverlay
    id="endgame-popup"
    data-score="0"
    data-category={currentCategoryData?.headline || ""}
    data-difficulty={difficulty || ""}
  />

  <GameHeadline headline={currentCategoryData?.headline} />

  <ErrorMessage />

  <LoadingSpinner />

  <div
    id="question-container"
    class="w-full mx-auto p-6 rounded-lg bg-zinc-800 shadow-xl border border-zinc-700 text-center transition-opacity duration-500 opacity-100 data-[hidden=true]:opacity-0"
    role="main"
    aria-label={t("game.area.label")}
    data-categoryName={currentCategoryData?.headline}
    data-genre={category}
    data-userID={user.id}
    date-difficulty={difficulty}
  >
    <div
      id="question"
      class="mb-8 text-2xl font-bold text-zinc-50"
      role="heading"
      aria-level="2"
    >
    </div>
    <div
      id="options"
      class="flex flex-col gap-4"
      role="radiogroup"
      aria-label={t("game.options.label")}
    >
    </div>
  </div>

  <Joker />
</Layout>

<script>
  import { stopAudio } from "@utils/audio/audioControls";
  import { ErrorHandler } from "@utils/error/errorHandler";
  import { handleEndGame, restartGame } from "@utils/game/endGameUtils";
  import { getRandomQuestion } from "@utils/game/getRandomQuestion";
  import { initializeMediaElements } from "@utils/game/mediaUtils";
  import { QueueManager } from "@utils/queue/queueManager";
  import { loadQuestion } from "@utils/game/loadQuestionUtils";
  import { handleAnswer } from "@utils/game/handleAnswerUtils";
  import { JokerManager } from "@utils/game/jokerManager";
  import { Difficulty } from "@utils/game/jokerUtils";
  import type { Album } from "src/types/game";
  import { getLangFromUrl, useTranslations } from "@utils/i18n";

  const lang = getLangFromUrl(
    new URL(window.location.pathname, window.location.origin),
  );
  const t = useTranslations(lang);

  const ROUNDS_PER_DIFFICULTY = {
    [Difficulty.EASY]: 10,
    [Difficulty.MEDIUM]: 15,
    [Difficulty.HARD]: 20,
  } as const;

  const validateDifficulty = (diff: string | null): Difficulty => {
    if (diff === "easy") return Difficulty.EASY;
    if (diff === "medium") return Difficulty.MEDIUM;
    if (diff === "hard") return Difficulty.HARD;
    return Difficulty.EASY;
  };

  interface GameElements {
    score: HTMLParagraphElement;
    round: HTMLParagraphElement;
    feedback: HTMLParagraphElement;
    question: HTMLParagraphElement;
    options: HTMLDivElement;
    container: HTMLDivElement;
    overlayCover: HTMLImageElement;
    overlay: HTMLDivElement;
    jokerButton: HTMLButtonElement;
    jokerCounter: HTMLElement;
    nextRoundButton: HTMLButtonElement;
    restartButton: HTMLButtonElement;
    loadingSpinner: HTMLElement;
  }

  function cacheElements(): GameElements {
    const elements = {
      score: document.querySelector(".coinsCount") as HTMLParagraphElement,
      round: document.querySelector(".round") as HTMLParagraphElement,
      feedback: document.getElementById("feedback") as HTMLParagraphElement,
      question: document.getElementById("question") as HTMLParagraphElement,
      options: document.getElementById("options") as HTMLDivElement,
      container: document.getElementById(
        "question-container",
      ) as HTMLDivElement,
      overlayCover: document.getElementById(
        "overlay-cover",
      ) as HTMLImageElement,
      overlay: document.getElementById("overlay") as HTMLDivElement,
      jokerButton: document.getElementById("joker-button") as HTMLButtonElement,
      jokerCounter: document.getElementById("joker-count") as HTMLElement,
      nextRoundButton: document.getElementById(
        "next-round-button",
      ) as HTMLButtonElement,
      restartButton: document.getElementById(
        "restart-button",
      ) as HTMLButtonElement,
      loadingSpinner: document.getElementById("loading-spinner") as HTMLElement,
    };

    return elements;
  }

  const initializeGame = async (elements: GameElements) => {
    QueueManager.startProcessing();

    if (!elements.container) {
      console.error("Container Element nicht gefunden");
      return;
    }

    const category = elements.container.getAttribute("data-genre");
    const userId = elements.container.getAttribute("data-userID");
    const categoryName = elements.container.getAttribute("data-categoryName");
    const difficulty = elements.container.getAttribute("date-difficulty");

    let score = 0;
    let correctAnswers = 0;
    let roundIndex = 0;
    const totalRounds =
      ROUNDS_PER_DIFFICULTY[validateDifficulty(difficulty)] ??
      ROUNDS_PER_DIFFICULTY.easy;
    elements.round.textContent = `${roundIndex + 1}/${totalRounds}`;

    let albums: Album[] | null = null;
    try {
      // Try to load albums for the current language
      try {
        const albumsPromise = import(
          /* @vite-ignore */ `../../../json/genres/${lang}/${category}.json`
        );
        albums = (await albumsPromise).default;
      } catch (langError) {
        // Fallback to German if the specific language file doesn't exist
        console.log(
          `No albums found for ${lang}/${category}, falling back to German`,
        );
        const fallbackPromise = import(
          /* @vite-ignore */ `../../../json/genres/de/${category}.json`
        );
        albums = (await fallbackPromise).default;
      }

      if (!albums?.length) {
        throw new Error(t("error.no.albums.found"));
      }
    } catch (error) {
      ErrorHandler.handleApiError(
        error instanceof Error ? error : new Error(String(error)),
      );
      return;
    }

    let currentQuestion: null = null;

    const jokerManager = new JokerManager({
      difficulty: validateDifficulty(difficulty) as Difficulty,
      elements: {
        jokerButton: elements.jokerButton,
        jokerCounter: elements.jokerCounter,
      },
    });

    const mediaElements = initializeMediaElements();
    if (!mediaElements) {
      console.error("Media-Elemente konnten nicht initialisiert werden");
      return;
    }

    function handleAnswerWrapper(
      option: any,
      correctAnswer: any,
      currentQuestion: { trivia: string },
      album: { coverSrc: string; artist: string; album: string; year: string },
    ) {
      score = handleAnswer({
        option,
        correctAnswer,
        currentQuestion,
        album,
        elements: {
          feedbackElement: elements.feedback,
          scoreElement: elements.score,
          overlayCover: elements.overlayCover,
          overlay: elements.overlay,
          mediaElements,
        },
        state: {
          score,
          roundIndex,
          totalRounds,
          roundElement: elements.round,
        },
      });

      elements.nextRoundButton.onclick = function () {
        stopAudio();
        elements.overlay.classList.add("hidden");
        if (roundIndex < totalRounds - 1) {
          roundIndex++;
          elements.round.textContent = `${roundIndex + 1}/${totalRounds}`;
          const newQuestion = getRandomQuestion(
            albums ?? [],
            validateDifficulty(difficulty),
            totalRounds,
          );
          if (newQuestion) {
            loadNewQuestion(
              newQuestion.randomQuestion,
              newQuestion.randomAlbum,
            );
            elements.feedback.textContent = "";
          }
        } else {
          endGame();
        }
      };
    }

    function endGame() {
      const config = {
        userId: userId || "",
        categoryName: categoryName || "",
        difficulty: validateDifficulty(difficulty) || "easy",
        totalRounds,
        correctAnswers,
        score,
        language: lang,
      };

      const ui = {
        showEndgamePopup: (score: number) => {
          const popup = document.getElementById("endgame-popup");
          const scoreElement = popup?.querySelector("#popup-score");

          if (popup && scoreElement) {
            scoreElement.textContent = score.toString();
            popup.setAttribute("data-score", score.toString());
            popup.classList.remove("hidden");
          }
        },
        // GoldenLP popup removed
      };

      handleEndGame(config, ui, {
        onError: (error) => {
          ErrorHandler.handleSaveError(error, "score", {
            userId: config.userId,
            category: config.categoryName,
          });
        },
      });
    }

    elements.restartButton?.addEventListener("click", restartGame);

    function loadNewQuestion(question: any, album: any) {
      if (!question || !question.options) {
        console.error(t("error.invalid.question"));
        return;
      }

      currentQuestion = question;
      jokerManager.setCurrentQuestion(question);

      loadQuestion({
        question,
        album,
        elements: {
          questionContainer: elements.container,
          spinner: elements.loadingSpinner,
          questionElement: elements.question,
          optionsContainer: elements.options,
        },
        handlers: {
          handleAnswer: handleAnswerWrapper,
        },
        jokerState: jokerManager.getCurrentJokerState(),
      });
    }

    const initialQuestion = getRandomQuestion(
      albums,
      validateDifficulty(difficulty),
      totalRounds,
    );
    if (initialQuestion?.randomQuestion && initialQuestion?.randomAlbum) {
      loadNewQuestion(
        initialQuestion.randomQuestion,
        initialQuestion.randomAlbum,
      );
    } else {
      console.error(t("error.no.initial.question"));
    }

    window.addEventListener("beforeunload", (e) => {
      if (QueueManager.hasUnsavedData()) {
        e.preventDefault();
      }
    });

    const cleanup = () => {
      stopAudio();
      QueueManager.stopProcessing();
      jokerManager.cleanup();
      elements.restartButton?.removeEventListener("click", restartGame);
    };

    window.addEventListener("unload", cleanup);
  };

  document.addEventListener("DOMContentLoaded", () => {
    const elements = cacheElements();
    if (!validateElements(elements)) {
      console.error("Erforderliche DOM-Elemente nicht gefunden");
      return;
    }
    initializeGame(elements);
  });

  function validateElements(elements: GameElements): boolean {
    const requiredElements = [
      "score",
      "round",
      "question",
      "options",
      "container",
    ];

    return requiredElements.every(
      (key) => elements[key as keyof GameElements] !== null,
    );
  }
</script>

<style is:global>
  /* Diese Stile könnten später in utility classes umgesetzt werden */
  .overlay.hidden {
    @apply hidden;
  }

  .popup.hidden {
    @apply hidden;
  }

  /* Für ältere Browser, die data-hidden noch nicht unterstützen */
  #question-container.hidden {
    @apply opacity-0;
  }

  /* High Contrast Mode Support */
  @media (forced-colors: active) {
    #question-container {
      border: 2px solid CanvasText;
    }

    #options > button {
      border: 1px solid ButtonText;
    }

    #question {
      border-bottom: 1px solid CanvasText;
    }
  }

  /* Print Styles */
  @media print {
    #question-container {
      break-inside: avoid;
      border: 1px solid #000;
      box-shadow: none;
    }

    #options > button {
      break-inside: avoid;
      border: 1px solid #000;
    }
  }
</style>
