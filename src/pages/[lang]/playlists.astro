---
import Layout from "@layouts/Layout.astro";
import { useTranslations } from "@utils/i18n";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import PlaylistCard from "@components/PlaylistCard.astro";
import { Icon } from "astro-icon/components";
import { extractKeywords, generateMetaDescription } from "@utils/seo";
import { Picture } from "astro:assets";

/**
 * Enable static site generation for all supported languages.
 * This ensures the playlist pages are pre-rendered at build time for optimal performance.
 * @see https://docs.astro.build/en/reference/directives-reference/#prerender
 */
export const prerender = true;

/**
 * Define supported languages and generate static paths for each language.
 * This creates separate routes for each language version of the playlist page.
 * @returns {Array} Array of route objects with params and props
 */
export async function getStaticPaths() {
  // Define all languages supported by the application
  const supportedLanguages = [
    "de",
    "en",
    "es",
    "fr",
    "it",
    "pt",
    "da",
    "nl",
    "sv",
    "fi",
  ] as const;

  // Optimierte parallele Datenaufrufe mit Promise.all
  // Lädt alle Sprachdateien gleichzeitig und verarbeitet sie parallel
  const allLanguageDataPromises = supportedLanguages.map(async (lang) => {
    // Versuche, Playlist-Daten für die spezifische Sprache zu laden
    try {
      // Dynamischer Import mit Promise.all für parallele Verarbeitung
      const playlistData = await import(
        `../../../public/json/playlist/${lang}_playlist.json`
      );
      return { lang, playlists: playlistData.default };
    } catch (error) {
      // Fallback zu Englisch, wenn die Sprachdatei nicht existiert
      try {
        console.info(
          `No playlist data found for ${lang}, falling back to English`,
        );
        const fallbackData = await import(
          `../../../public/json/playlist/en_playlist.json`
        );
        return { lang, playlists: fallbackData.default };
      } catch (fallbackError) {
        console.error(
          `Error loading playlist data for ${lang}:`,
          fallbackError,
        );
        return { lang, playlists: [] };
      }
    }
  });

  // Warte auf alle Datenaufrufe und erstelle die Pfade
  const languageData = await Promise.all(allLanguageDataPromises);

  // Transformiere die Daten in das erwartete Format
  const paths = languageData.map(({ lang, playlists }) => ({
    params: { lang },
    props: { lang, playlists },
  }));

  return paths;
}

/**
 * Type definition for component props
 */
interface Props {
  lang: "de" | "en" | "es" | "fr" | "it" | "pt" | "da" | "nl" | "sv" | "fi";
  playlists: PlaylistData[];
}

/**
 * Type definition for playlist objects
 */
interface PlaylistData {
  headline: string;
  imageUrl: string;
  introSubline: string;
  spotifyPlaylist?: string;
  deezerPlaylist?: string;
  appleMusicPlaylist?: string;
}

// Extract data from props with default empty array for playlists
const { lang, playlists = [] } = Astro.props;

// Use the i18n utilities for translations
const t = useTranslations(lang);

// Generate SEO content
const title = t("playlist.page.title");
const description = t("playlist.page.description");

// Enhanced SEO content using utility functions
const pageContent = `${title} ${description} ${playlists.map((p) => `${p.headline} ${p.introSubline}`).join(" ")}`;

// Generate optimized meta description and keywords
const optimizedDescription = generateMetaDescription(pageContent);
const keywords = extractKeywords(pageContent) || t("meta.keywords");

// Additional structured data parameters for SEO
const pageType = "website";
const publishDate = new Date("2024-01-01");
const modifiedDate = new Date();

// Verbesserte Hilfsfunktion zur Extraktion des Jahrzehnts aus der Überschrift
function getDecadeFromHeadline(headline: string): string {
  // Suche nach 4-stelligen Jahreszahlen (z.B. 1960, 2020)
  const yearMatch = headline.match(/\b(\d{4})\b/);
  if (yearMatch) {
    return yearMatch[1].substring(0, 3) + "0s";
  }

  // Suche nach Jahrzehnten im Format "1960s", "60er", "Sixties" usw.
  const decadePatterns = [
    {
      pattern: /\b(\d{2})(?:er|s)\b/i,
      transform: (match: string) => {
        const decade = parseInt(match);
        return (decade < 30 ? "20" : "19") + match + "0s";
      },
    },
    {
      pattern: /\b(19\d0)(?:er|s)\b/i,
      transform: (match: string) => match + "s",
    },
    {
      pattern: /\b(20\d0)(?:er|s)\b/i,
      transform: (match: string) => match + "s",
    },
    { pattern: /\bsixties\b/i, transform: () => "1960s" },
    { pattern: /\bseventies\b/i, transform: () => "1970s" },
    { pattern: /\beighties\b/i, transform: () => "1980s" },
    { pattern: /\bnineties\b/i, transform: () => "1990s" },
  ];

  for (const { pattern, transform } of decadePatterns) {
    const match = headline.match(pattern);
    if (match) {
      return transform(match[1]);
    }
  }

  return "Other";
}

// Sort playlists chronologically basierend auf dem extrahierten Jahrzehnt
const sortedPlaylists = [...playlists].sort((a, b) => {
  const decadeA = getDecadeFromHeadline(a.headline);
  const decadeB = getDecadeFromHeadline(b.headline);
  return decadeA.localeCompare(decadeB, undefined, { sensitivity: "base" });
});
---

<Layout
  title={title}
  description={optimizedDescription}
  keywords={keywords}
  image={`/og-images/social-share-playlist-${lang}.jpg`}
  type={pageType}
  publishDate={publishDate}
  modifiedDate={modifiedDate}
>
  <!-- Strukturierte Daten für SEO -->
  <script
    type="application/ld+json"
    set:html={JSON.stringify([
      // BreadcrumbList Schema
      {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        itemListElement: [
          {
            "@type": "ListItem",
            position: 1,
            name: "Home",
            item: `${Astro.site}${lang}`,
          },
          {
            "@type": "ListItem",
            position: 2,
            name: title,
            item: `${Astro.site}${lang}/playlists`,
          },
        ],
      },
      // ItemList Schema für die Playlist-Sammlung
      {
        "@context": "https://schema.org",
        "@type": "ItemList",
        numberOfItems: sortedPlaylists.length,
        itemListOrder: "Ascending",
        itemListElement: sortedPlaylists.map((playlist, index) => ({
          "@type": "ListItem",
          position: index + 1,
          item: {
            "@type": "MusicPlaylist",
            name: playlist.headline,
            description: playlist.introSubline,
            image: playlist.imageUrl.startsWith("http")
              ? playlist.imageUrl
              : `${Astro.site}${playlist.imageUrl.replace(/^\//, "")}`,
            url: `${Astro.site}${lang}/playlists#playlist-${index}`,
            numTracks: playlist.spotifyPlaylist ? 1 : 0,
            provider: [
              playlist.spotifyPlaylist
                ? { "@type": "MusicService", name: "Spotify" }
                : null,
              playlist.deezerPlaylist
                ? { "@type": "MusicService", name: "Deezer" }
                : null,
              playlist.appleMusicPlaylist
                ? { "@type": "MusicService", name: "Apple Music" }
                : null,
            ].filter(Boolean),
          },
        })),
      },
      // Zusätzliches WebPage Schema für verbesserte Sichtbarkeit
      {
        "@context": "https://schema.org",
        "@type": "CollectionPage",
        name: title,
        description: optimizedDescription,
        url: `${Astro.site}${lang}/playlists`,
        isPartOf: {
          "@type": "WebSite",
          name: "Melody Mind",
          url: `${Astro.site}`,
        },
        datePublished: publishDate.toISOString(),
        dateModified: modifiedDate.toISOString(),
        inLanguage: lang,
        mainEntity: {
          "@type": "ItemList",
          itemListElement: sortedPlaylists.map((_, index) => ({
            "@type": "ListItem",
            position: index + 1,
            url: `${Astro.site}${lang}/playlists#playlist-${index}`,
          })),
        },
      },
    ])}
  />
  <main
    class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 sm:py-10 lg:py-12"
    style="contain: content;"
  >
    <!-- Page heading and description -->
    <div class="text-center mb-8 sm:mb-10 lg:mb-12">
      <Headline
        title={t("playlist.page.heading")}
        level="h1"
        className="text-white font-bold text-3xl sm:text-4xl lg:text-5xl mb-4"
      />
      <div
        class="h-1 w-16 sm:w-24 bg-purple-500 rounded-full mx-auto mt-2 mb-4 sm:mb-6"
      >
      </div>
      <Paragraph
        description={t("playlist.page.description")}
        className="max-w-xl sm:max-w-2xl mx-auto text-zinc-100 text-base sm:text-lg"
      />
    </div>

    <!-- Search and filter section -->
    <div
      class="search-filter-container bg-zinc-800/90 rounded-xl p-4 sm:p-6 lg:p-8 border border-zinc-700 shadow-lg mb-8 sm:mb-10"
      role="search"
      aria-labelledby="search-heading"
    >
      <h2 id="search-heading" class="sr-only">
        {t("playlist.search.label")}
      </h2>

      <div class="flex flex-col sm:flex-row gap-3 sm:gap-4 mb-4 sm:mb-6">
        <!-- Search field -->
        <div class="relative flex-grow">
          <label for="playlist-search" class="sr-only">
            {t("playlist.search.placeholder")}
          </label>
          <div class="relative">
            <div
              class="absolute inset-y-0 left-3 flex items-center pointer-events-none"
              aria-hidden="true"
            >
              <Icon name="search" class="h-5 w-5 text-purple-400" />
            </div>
            <input
              type="search"
              id="playlist-search"
              placeholder={t("playlist.search.placeholder")}
              class="w-full py-3 pl-10 pr-4 bg-zinc-800 border-2 border-zinc-600
                    rounded-xl text-zinc-50 placeholder-zinc-400
                    focus:outline-none focus:border-purple-500 focus:ring-3
                    focus:ring-purple-500/50 transition-all duration-200 ease-out
                    text-base sm:text-lg touch-manipulation min-h-[52px]
                    hover:border-zinc-500 active:border-purple-500"
              aria-controls="playlist-grid"
              aria-describedby="search-playlist-description"
              autocomplete="off"
              enterkeyhint="search"
            />
            <div id="search-playlist-description" class="sr-only">
              {
                t("playlist.search.live.description") ||
                  "Results are filtered automatically as you type"
              }
            </div>
          </div>
        </div>
      </div>

      <!-- Search status for screen readers -->
      <div
        id="search-results-status"
        class="sr-only"
        aria-live="polite"
        aria-atomic="true"
        role="status"
      >
      </div>

      <!-- No results message (initially hidden) -->
      <div
        id="no-results"
        class="hidden flex flex-col items-center justify-center p-6 sm:p-10 lg:p-12 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl border border-zinc-600 text-center shadow-md mb-6 sm:mb-10"
        aria-live="polite"
        role="status"
      >
        <Icon
          name="search-no-results"
          class="w-12 h-12 sm:w-16 sm:h-16 text-zinc-300 mb-3 sm:mb-4"
          aria-hidden="true"
        />
        <h2 class="text-zinc-100 text-lg sm:text-xl font-medium mb-2">
          {t("playlist.no.results.heading") || "No playlists found"}
        </h2>
        <p class="text-zinc-300 mb-3 sm:mb-4 text-base sm:text-lg">
          {t("playlist.no.results")}
        </p>
        <button
          id="reset-search"
          class="mt-2 px-5 sm:px-6 py-3 bg-purple-700 hover:bg-purple-600 active:bg-purple-800 text-white rounded-lg
                 min-h-[52px] min-w-[140px] font-medium text-base sm:text-lg
                 focus:outline-none focus:ring-4 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800
                 transition-colors transition-transform duration-200 ease-out touch-manipulation
                 active:scale-95 active:translate-y-[1px]"
          aria-label={t("playlist.reset.search.button") ||
            "Reset search filters"}
        >
          {t("playlist.reset.search") || "Reset search"}
        </button>
      </div>

      <!-- Playlist Grid -->
      <ul
        id="playlist-grid"
        class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6 lg:gap-8 contain-layout will-change-contents"
        aria-label={t("playlist.page.heading")}
        itemscope
        itemtype="https://schema.org/ItemList"
        style="content-visibility: auto; contain-intrinsic-size: auto 500px; transform: translateZ(0);"
      >
        {
          sortedPlaylists.map((playlist, index) => (
            <li
              class="playlist-card"
              itemscope
              itemtype="https://schema.org/ListItem"
              itemprop="itemListElement"
              data-searchable={`${playlist.headline.toLowerCase()} ${playlist.introSubline.toLowerCase()}`}
              data-decade={getDecadeFromHeadline(playlist.headline)}
              data-index={index}
              id={`playlist-${index}`}
              style={{
                animationDelay: `${index * 0.05}s`,
                contain: "content",
                transform: "translateZ(0)",
              }}
            >
              <meta itemprop="position" content={`${index + 1}`} />
              <PlaylistCard
                headline={playlist.headline}
                imageUrl={playlist.imageUrl}
                introSubline={playlist.introSubline}
                spotifyPlaylist={playlist.spotifyPlaylist}
                deezerPlaylist={playlist.deezerPlaylist}
                appleMusicPlaylist={playlist.appleMusicPlaylist}
                index={index}
                lang={lang}
              />
            </li>
          ))
        }
      </ul>

      <!-- Back to top button -->
      <button
        id="back-to-top"
        class="fixed bottom-4 sm:bottom-6 lg:bottom-8 right-4 sm:right-6 lg:right-8 p-3 sm:p-4 bg-purple-700 text-white rounded-full shadow-lg opacity-0 invisible
               transition-all duration-200 ease-out hover:bg-purple-600 active:bg-purple-800
               min-w-[56px] min-h-[56px] sm:min-w-[60px] sm:min-h-[60px] flex items-center justify-center
               focus:outline-none focus:ring-4 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800
               touch-manipulation z-50 active:scale-95 active:translate-y-[1px]"
        aria-label={t("back.to.top") || "Back to top of page"}
        style="transform: translateZ(0);"
      >
        <Icon
          name="arrow-up"
          class="h-5 w-5 sm:h-6 sm:w-6"
          aria-hidden="true"
        />
      </button>
    </div>
  </main>

  <style>
    /* Improved color contrast for WCAG AAA (7:1) */
    :root {
      --text-primary: #ffffff; /* Maximum contrast */
      --text-secondary: #e2e2e7; /* Higher contrast than standard zinc-300 */
      --bg-card: #27272a; /* zinc-800 */
      --border-card: rgba(161, 161, 170, 0.3); /* zinc-400 with transparency */
      --accent-primary: #9333ea; /* purple-600 - darker for better contrast */
      --accent-secondary: #a855f7; /* purple-500 */
      --touch-target-size: 44px; /* Minimum touch target size */
    }

    /* Improved focus states for keyboard navigation */
    :focus-visible {
      outline: 3px solid var(--accent-primary);
      outline-offset: 3px;
    }

    /* Animations for cards */
    @keyframes fadeIn {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      60% {
        opacity: 0.8;
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes shimmer {
      0% {
        background-position: -200% 0;
      }
      100% {
        background-position: 200% 0;
      }
    }

    .animate-fadeIn {
      animation: fadeIn 0.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
      opacity: 0;
      will-change: opacity, transform;
    }

    /* Progressive Loading Animation */
    .loading-shimmer {
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0.05) 0%,
        rgba(255, 255, 255, 0.1) 50%,
        rgba(255, 255, 255, 0.05) 100%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      will-change: background-position;
    }

    /* Improved back-to-top button animation */
    #back-to-top.visible {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    #back-to-top {
      transform: translateY(10px);
    }

    /* Optimized loading for better performance */
    .touch-manipulation {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    /* Optimized scrolling performance */
    .will-change-contents {
      will-change: contents;
      transform: translateZ(0);
      backface-visibility: hidden;
    }

    .contain-layout {
      contain: layout style;
    }

    /* Responsive adjustments */
    @media (max-width: 640px) {
      .playlist-card {
        contain: content;
      }

      /* Verbesserte Touch-Targets für mobile Geräte */
      button,
      input[type="search"],
      a[role="button"] {
        min-height: var(--touch-target-size);
        min-width: var(--touch-target-size);
      }

      /* Optimierte Abstände für Touch-Geräte */
      .gap-2 {
        gap: 0.625rem !important; /* 10px */
      }
    }

    /* Improved touch feedback */
    @media (hover: none) {
      button:active,
      input:active,
      a:active {
        transform: scale(0.97);
      }
    }

    /* Disable animations if user prefers reduced motion */
    @media (prefers-reduced-motion: reduce) {
      *,
      ::before,
      ::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }

      .animate-fadeIn {
        opacity: 1;
        animation: none !important;
        transform: translateY(0);
      }

      .loading-shimmer {
        animation: none !important;
        background: rgba(255, 255, 255, 0.05);
      }

      .playlist-card:hover,
      button:active,
      a:active {
        transform: none !important;
        scale: none !important;
        box-shadow: none !important;
      }

      #back-to-top {
        transform: none;
      }

      html {
        scroll-behavior: auto !important;
      }
    }
  </style>

  <style is:global>
    /* Verbesserte Fokus-Stile für Tastaturbenutzer */
    .user-is-tabbing :focus:not(:focus-visible) {
      outline: none;
      box-shadow: none;
    }

    .user-is-tabbing :focus-visible {
      outline: 3px solid var(--accent-primary);
      outline-offset: 3px;
      box-shadow: 0 0 0 3px rgba(147, 51, 234, 0.5);
    }

    /* Verbesserte Screenreader-Unterstützung */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    .sr-only.focus:not-sr-only {
      position: fixed;
      width: auto;
      height: auto;
      overflow: visible;
      clip: auto;
      white-space: normal;
    }

    /* Optimierte Rendering-Performance */
    img,
    video {
      image-rendering: high-quality;
      backface-visibility: hidden;
    }

    /* Verbesserte Touch-Feedback */
    @media (hover: none) {
      button:active,
      a:active {
        transform: scale(0.97);
        transition: transform 0.1s ease-out;
      }
    }
  </style>

  <script>
    /**
     * Hochoptimierter Playlist-Manager
     *
     * Diese Skript verwaltet die interaktive Funktionalität der Playlist-Seite mit
     * verbesserten Algorithmen für Suche, DOM-Manipulation und Zugänglichkeit:
     * - Erweiterte Suchlogik mit Fuzzy-Matching und Relevanz-Scoring
     * - Optimiertes Debouncing mit cancelierbaren Promises
     * - Effiziente DOM-Updates mit DocumentFragment und virtuelles Scrolling
     * - Verbesserte Zugänglichkeit mit präzisen ARIA-Ankündigungen und Keyboard-Shortcuts
     */
    document.addEventListener("DOMContentLoaded", function () {
      // DOM-Elemente cachen für bessere Performance
      const searchInput = document.getElementById(
        "playlist-search",
      ) as HTMLInputElement;
      const playlistGrid = document.getElementById("playlist-grid");
      const playlistCards = document.querySelectorAll(".playlist-card");
      const noResultsElement = document.getElementById("no-results");
      const searchStatusElement = document.getElementById(
        "search-results-status",
      );
      const resetSearchButton = document.getElementById("reset-search");
      const backToTopButton = document.getElementById("back-to-top");

      // Konfigurationswerte
      const DEBOUNCE_DELAY = 250; // ms
      const MIN_SEARCH_LENGTH = 2; // Mindestzeichenanzahl für Suche
      const VIRTUAL_SCROLL_THRESHOLD = 50; // Ab dieser Anzahl von Elementen virtuelles Scrolling aktivieren
      const FUZZY_MATCH_THRESHOLD = 0.6; // Schwellenwert für Fuzzy-Matching (0-1)
      const TOUCH_FEEDBACK_DURATION = 300; // ms
      const REDUCED_MOTION = window.matchMedia(
        "(prefers-reduced-motion: reduce)",
      ).matches;
      const IS_TOUCH_DEVICE = window.matchMedia("(hover: none)").matches;

      // Optimierungsvariablen
      let currentSearchOperation: { cancel: () => void } | null = null;
      let isSearching = false;
      let lastSearchTerm = "";
      let lastVisibleCount = playlistCards.length;
      let searchIndex: Array<{
        element: Element;
        searchable: string;
        decade: string;
        index: number;
        tokens: string[];
      }> = [];

      // Erstelle optimierten Suchindex
      function buildSearchIndex() {
        searchIndex = Array.from(playlistCards).map((card) => {
          const searchable = (
            card.getAttribute("data-searchable") || ""
          ).toLowerCase();
          const decade = card.getAttribute("data-decade") || "";
          const index = parseInt(card.getAttribute("data-index") || "0", 10);
          // Tokenisiere den Suchtext für bessere Suche
          const tokens = searchable
            .split(/\s+/)
            .filter((token) => token.length > 1);

          return { element: card, searchable, decade, index, tokens };
        });
      }

      // Initialisiere den Suchindex
      buildSearchIndex();

      /**
       * Fügt Progressive Loading-Animationen zu Playlist-Karten hinzu
       */
      function initProgressiveLoading() {
        // Erstelle einen Intersection Observer für Progressive Loading
        const cardObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                const card = entry.target as HTMLElement;

                // Verzögere die Animation leicht für einen Kaskaden-Effekt
                setTimeout(
                  () => {
                    card.classList.add("animate-fadeIn");

                    // Entferne Loading-Shimmer, wenn vorhanden
                    const shimmerElements =
                      card.querySelectorAll(".loading-shimmer");
                    shimmerElements.forEach((el) => {
                      (el as HTMLElement).classList.remove("loading-shimmer");
                    });
                  },
                  parseInt(card.dataset.index || "0") * 50,
                );

                cardObserver.unobserve(card);
              }
            });
          },
          {
            rootMargin: "100px",
            threshold: 0.1,
          },
        );

        // Füge Loading-Shimmer zu Bildern hinzu und beobachte Karten
        playlistCards.forEach((card) => {
          // Füge initial Loading-Shimmer hinzu
          const imageContainer = card.querySelector(".aspect-video");
          if (imageContainer && !REDUCED_MOTION) {
            imageContainer.classList.add("loading-shimmer");
          }

          // Beobachte für Intersection
          cardObserver.observe(card);
        });

        // Cleanup beim Verlassen der Seite
        document.addEventListener("astro:before-swap", () => {
          cardObserver.disconnect();
        });
      }

      // Initialisiere Progressive Loading
      initProgressiveLoading();

      /**
       * Fügt Touch-spezifische Feedback-Effekte hinzu
       */
      function initTouchFeedback() {
        if (!IS_TOUCH_DEVICE) return;

        // Füge Touch-Feedback für alle interaktiven Elemente hinzu
        const interactiveElements = document.querySelectorAll(
          'button, a, input[type="search"]',
        );

        interactiveElements.forEach((el) => {
          el.addEventListener(
            "touchstart",
            () => {
              if (REDUCED_MOTION) return;

              (el as HTMLElement).style.transition =
                `transform ${TOUCH_FEEDBACK_DURATION}ms cubic-bezier(0.19, 1, 0.22, 1)`;
              (el as HTMLElement).style.transform = "scale(0.97)";

              // Haptisches Feedback, wenn verfügbar
              if ("vibrate" in navigator) {
                try {
                  navigator.vibrate(10);
                } catch (e) {
                  // Ignoriere Fehler, falls Vibration nicht unterstützt wird
                }
              }
            },
            { passive: true },
          );

          el.addEventListener(
            "touchend",
            () => {
              if (REDUCED_MOTION) return;
              (el as HTMLElement).style.transform = "";
            },
            { passive: true },
          );

          el.addEventListener(
            "touchcancel",
            () => {
              if (REDUCED_MOTION) return;
              (el as HTMLElement).style.transform = "";
            },
            { passive: true },
          );
        });
      }

      // Initialisiere Touch-Feedback
      initTouchFeedback();

      /**
       * Verbesserte Debounce-Funktion mit Promise und Abbruchmöglichkeit
       * @param {Function} func - Zu debouncende Funktion
       * @param {number} delay - Verzögerung in Millisekunden
       * @returns {Function} Debounced Funktion mit Abbruchmöglichkeit
       */
      function debouncedPromise<T>(
        func: (...args: any[]) => Promise<T>,
        delay: number,
      ) {
        let timeoutId: number | null = null;
        let isCanceled = false;

        return {
          execute: (...args: any[]): Promise<T> => {
            return new Promise((resolve, reject) => {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }

              isCanceled = false;

              timeoutId = window.setTimeout(() => {
                if (isCanceled) {
                  reject(new Error("Operation cancelled"));
                  return;
                }

                func(...args)
                  .then(resolve)
                  .catch(reject)
                  .finally(() => {
                    timeoutId = null;
                  });
              }, delay);
            });
          },
          cancel: () => {
            if (timeoutId) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            isCanceled = true;
          },
        };
      }

      /**
       * Berechnet die Levenshtein-Distanz zwischen zwei Strings
       * für Fuzzy-Matching
       */
      function levenshteinDistance(a: string, b: string): number {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;

        const matrix = Array(a.length + 1)
          .fill(null)
          .map(() => Array(b.length + 1).fill(null));

        for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
        for (let j = 0; j <= b.length; j++) matrix[0][j] = j;

        for (let i = 1; i <= a.length; i++) {
          for (let j = 1; j <= b.length; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
              matrix[i - 1][j] + 1, // Löschen
              matrix[i][j - 1] + 1, // Einfügen
              matrix[i - 1][j - 1] + cost, // Ersetzen
            );
          }
        }

        return matrix[a.length][b.length];
      }

      /**
       * Berechnet die Ähnlichkeit zwischen zwei Strings (0-1)
       */
      function stringSimilarity(a: string, b: string): number {
        if (!a || !b) return 0;
        const maxLength = Math.max(a.length, b.length);
        if (maxLength === 0) return 1;
        const distance = levenshteinDistance(a, b);
        return 1 - distance / maxLength;
      }

      /**
       * Prüft, ob ein String einen anderen mit Fuzzy-Matching enthält
       */
      function fuzzyIncludes(
        text: string,
        query: string,
        threshold = FUZZY_MATCH_THRESHOLD,
      ): boolean {
        if (!query) return true;
        if (!text) return false;

        // Exakte Übereinstimmung hat Priorität
        if (text.includes(query)) return true;

        // Für kurze Queries prüfen wir Token für Token
        if (query.length <= 3) {
          const tokens = text.split(/\s+/);
          return tokens.some(
            (token) => stringSimilarity(token, query) >= threshold,
          );
        }

        // Für längere Queries prüfen wir Teilstrings
        for (let i = 0; i <= text.length - query.length; i++) {
          const substring = text.substr(i, query.length + 2); // Etwas mehr für Fuzzy-Matching
          if (stringSimilarity(substring, query) >= threshold) {
            return true;
          }
        }

        return false;
      }

      /**
       * Berechnet einen Relevanz-Score für Suchergebnisse
       */
      function calculateRelevance(
        item: (typeof searchIndex)[0],
        searchTerm: string,
      ): number {
        if (!searchTerm) return 1;

        // Exakte Übereinstimmung hat höchste Priorität
        if (item.searchable.includes(searchTerm)) return 2;

        // Prüfe Token-Übereinstimmungen
        const tokenMatches = item.tokens.filter((token) =>
          fuzzyIncludes(token, searchTerm),
        ).length;

        if (tokenMatches > 0) {
          return 1 + tokenMatches / item.tokens.length;
        }

        // Fuzzy-Matching als Fallback
        return fuzzyIncludes(item.searchable, searchTerm) ? 0.7 : 0;
      }

      /**
       * Filtert Playlists basierend auf Sucheingabe mit optimierter Performance
       * Verwendet DocumentFragment für Batch-DOM-Updates
       */
      async function filterPlaylists(): Promise<number> {
        if (!searchInput || isSearching) return lastVisibleCount;

        isSearching = true;
        const searchTerm = searchInput.value.toLowerCase().trim();

        // Überspringe Suche bei zu kurzen Suchbegriffen
        if (searchTerm.length > 0 && searchTerm.length < MIN_SEARCH_LENGTH) {
          isSearching = false;
          return lastVisibleCount;
        }

        // Überspringe, wenn sich nichts geändert hat
        if (searchTerm === lastSearchTerm) {
          isSearching = false;
          return lastVisibleCount;
        }

        lastSearchTerm = searchTerm;

        // Verwende DocumentFragment für Batch-DOM-Updates
        return new Promise((resolve) => {
          // Verwende requestAnimationFrame für flüssige UI-Updates
          requestAnimationFrame(() => {
            let visibleCount = 0;
            const totalCount = searchIndex.length;

            // Für große Listen: Virtuelles Rendering vorbereiten
            const useVirtualScroll = totalCount > VIRTUAL_SCROLL_THRESHOLD;
            const fragment = useVirtualScroll
              ? document.createDocumentFragment()
              : null;

            // Filtere und sortiere nach Relevanz
            const filteredItems = searchIndex
              .map((item) => {
                const relevance = calculateRelevance(item, searchTerm);
                return { item, relevance };
              })
              .filter(({ relevance }) => relevance > 0)
              .sort((a, b) => b.relevance - a.relevance);

            // Verstecke alle Elemente zuerst (verhindert Layout-Thrashing)
            if (!useVirtualScroll) {
              searchIndex.forEach(({ element }) => {
                (element as HTMLElement).classList.add("hidden");
              });
            }

            // Zeige relevante Elemente
            filteredItems.forEach(({ item }) => {
              if (useVirtualScroll && fragment) {
                // Bei virtuellem Scrolling: Füge zum Fragment hinzu
                fragment.appendChild(item.element.cloneNode(true));
              } else {
                // Normaler Modus: Zeige Element
                (item.element as HTMLElement).classList.remove("hidden");
              }
              visibleCount++;
            });

            // Bei virtuellem Scrolling: Ersetze Grid-Inhalt mit Fragment
            if (useVirtualScroll && fragment && playlistGrid) {
              // Speichere Scroll-Position
              const scrollTop = window.scrollY;

              // Leere Grid und füge Fragment hinzu
              playlistGrid.innerHTML = "";
              playlistGrid.appendChild(fragment);

              // Stelle Scroll-Position wieder her
              window.scrollTo(0, scrollTop);
            }

            // Zeige/verstecke "Keine Ergebnisse"-Nachricht
            if (noResultsElement) {
              noResultsElement.classList.toggle("hidden", visibleCount > 0);
            }

            // Aktualisiere ARIA-Live-Region mit präzisen Informationen
            if (searchStatusElement) {
              if (searchTerm && visibleCount > 0) {
                searchStatusElement.textContent = `${visibleCount} von ${totalCount} Playlists gefunden für "${searchTerm}"`;
              } else if (searchTerm && visibleCount === 0) {
                searchStatusElement.textContent = `Keine Playlists gefunden für "${searchTerm}". Versuchen Sie einen anderen Suchbegriff.`;
              } else {
                searchStatusElement.textContent = `Alle ${totalCount} Playlists werden angezeigt`;
              }
            }

            lastVisibleCount = visibleCount;
            isSearching = false;
            resolve(visibleCount);
          });
        });
      }

      // Erstelle debounced Suchfunktion mit Abbruchmöglichkeit
      const debouncedSearch = debouncedPromise(filterPlaylists, DEBOUNCE_DELAY);

      // Event-Listener für Suche mit optimiertem Debouncing
      if (searchInput) {
        searchInput.addEventListener("input", function () {
          // Breche vorherige Suche ab, wenn eine neue beginnt
          if (currentSearchOperation) {
            currentSearchOperation.cancel();
          }

          // Starte neue Suche
          currentSearchOperation = debouncedSearch;
          debouncedSearch.execute().catch((err) => {
            if (err.message !== "Operation cancelled") {
              console.error("Fehler bei der Suche:", err);
            }
          });
        });

        // Keyboard-Events für Zugänglichkeit
        searchInput.addEventListener("keydown", function (e) {
          if (e.key === "Escape") {
            searchInput.value = "";
            filterPlaylists();
          }
        });

        // Touch-spezifische Optimierungen
        if (IS_TOUCH_DEVICE) {
          // Optimiere für mobile Keyboards
          searchInput.addEventListener("focus", function () {
            // Scrolle zum Suchfeld, wenn es fokussiert wird
            setTimeout(() => {
              searchInput.scrollIntoView({
                behavior: REDUCED_MOTION ? "auto" : "smooth",
                block: "center",
              });
            }, 100);
          });
        }
      }

      // Zurücksetzen der Suche und Filter
      if (resetSearchButton) {
        resetSearchButton.addEventListener("click", function () {
          if (searchInput) searchInput.value = "";
          filterPlaylists();

          // Ankündigung für Screen-Reader
          if (searchStatusElement) {
            searchStatusElement.textContent = "Suchfilter wurden zurückgesetzt";
          }

          // Fokus zurück zum Sucheingabefeld für bessere Keyboard-UX
          searchInput?.focus();

          // Haptisches Feedback, wenn verfügbar
          if (IS_TOUCH_DEVICE && "vibrate" in navigator) {
            try {
              navigator.vibrate(15);
            } catch (e) {
              // Ignoriere Fehler, falls Vibration nicht unterstützt wird
            }
          }
        });
      }

      // "Zurück nach oben"-Button mit IntersectionObserver für Performance
      if (backToTopButton) {
        const observer = new IntersectionObserver(
          ([entry]) => {
            backToTopButton.classList.toggle("visible", !entry.isIntersecting);
          },
          { threshold: 0, rootMargin: "-200px 0px 0px 0px" },
        );

        // Beobachte den Seitenkopf, um Button ein-/auszublenden
        const pageHeader = document.querySelector("h1");
        if (pageHeader) observer.observe(pageHeader);

        backToTopButton.addEventListener("click", function () {
          // Verwende scrollIntoView mit behavior: smooth für bessere Performance als scrollTo
          document.body.scrollIntoView({
            behavior: REDUCED_MOTION ? "auto" : "smooth",
            block: "start",
          });

          // Ankündigung für Screen-Reader
          if (searchStatusElement) {
            searchStatusElement.textContent = "Zum Seitenanfang gescrollt";
          }

          // Haptisches Feedback, wenn verfügbar
          if (IS_TOUCH_DEVICE && "vibrate" in navigator) {
            try {
              navigator.vibrate(15);
            } catch (e) {
              // Ignoriere Fehler, falls Vibration nicht unterstützt wird
            }
          }
        });

        // Stelle sicher, dass Tastaturbenutzer nach "Zurück nach oben" zum Hauptinhalt gelangen können
        backToTopButton.addEventListener("keydown", function (e) {
          if (e.key === "Tab" && !e.shiftKey) {
            searchInput?.focus();
            e.preventDefault();
          }
        });
      }

      /**
       * Optimiert Scrolling-Performance durch passive Event-Listener
       * und content-visibility
       */
      function optimizeScrollingPerformance() {
        // Verwende passive Event-Listener für Touch-Events
        const scrollOptions = { passive: true };

        document.addEventListener("touchstart", () => {}, scrollOptions);
        document.addEventListener("touchmove", () => {}, scrollOptions);
        document.addEventListener("touchend", () => {}, scrollOptions);

        // Optimiere content-visibility beim Scrollen
        if ("contentVisibility" in document.documentElement.style) {
          let scrollTimeout: number;
          let lastScrollY = window.scrollY;
          let ticking = false;

          window.addEventListener(
            "scroll",
            () => {
              lastScrollY = window.scrollY;

              if (!ticking) {
                window.requestAnimationFrame(() => {
                  // Optimiere nur, wenn wir schnell scrollen
                  const isRapidScrolling =
                    Math.abs(lastScrollY - window.scrollY) > 50;

                  if (isRapidScrolling && playlistGrid) {
                    // Während schnellem Scrollen: Reduziere Rendering-Last
                    playlistGrid.style.contentVisibility = "auto";

                    if (scrollTimeout) {
                      clearTimeout(scrollTimeout);
                    }

                    scrollTimeout = window.setTimeout(() => {
                      // Stelle content-visibility nach dem Scrollen wieder her
                      if (playlistGrid) {
                        playlistGrid.style.contentVisibility = "";
                      }
                    }, 150);
                  }

                  ticking = false;
                });

                ticking = true;
              }
            },
            { passive: true },
          );
        }

        // Optimiere Bilder basierend auf Verbindungsqualität
        const connection = (navigator as any).connection;
        const isSlowConnection =
          connection &&
          (connection.saveData ||
            connection.effectiveType === "slow-2g" ||
            connection.effectiveType === "2g" ||
            connection.downlink < 0.5);

        if (isSlowConnection) {
          // Reduziere Bildqualität bei langsamen Verbindungen
          document.querySelectorAll("img").forEach((img) => {
            if (!img.getAttribute("loading"))
              img.setAttribute("loading", "lazy");
            if (img.getAttribute("fetchpriority") !== "high")
              img.setAttribute("fetchpriority", "low");
          });
        }
      }

      // Initialisiere Scrolling-Optimierungen
      optimizeScrollingPerformance();

      /**
       * Verbessert die Accessibility durch erweiterte ARIA-Unterstützung
       */
      function enhanceAccessibility() {
        // Verbessere ARIA-Labels für Screen Reader
        playlistCards.forEach((card, index) => {
          const cardElement = card as HTMLElement;
          const headline =
            cardElement.querySelector("h2")?.textContent ||
            `Playlist ${index + 1}`;
          const streamingLinks = cardElement.querySelectorAll("a[href]");

          // Füge zusätzliche ARIA-Beschreibungen hinzu
          streamingLinks.forEach((link) => {
            const serviceName =
              link.querySelector("span")?.textContent || "Streaming-Dienst";
            (link as HTMLElement).setAttribute(
              "aria-roledescription",
              `${serviceName} für ${headline}`,
            );
          });
        });

        // Verbessere Statusmeldungen für Screen Reader
        if (searchStatusElement) {
          // Stelle sicher, dass Statusmeldungen korrekt angekündigt werden
          searchStatusElement.setAttribute("aria-live", "polite");
          searchStatusElement.setAttribute("aria-atomic", "true");
        }

        // Füge Skip-Link für Tastaturbenutzer hinzu
        const skipLink = document.createElement("a");
        skipLink.href = "#playlist-grid";
        skipLink.className =
          "sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:p-4 focus:bg-purple-700 focus:text-white focus:rounded-md";
        skipLink.textContent = "Zum Inhalt springen";
        skipLink.setAttribute("tabindex", "0");
        document.body.insertBefore(skipLink, document.body.firstChild);

        // Verbessere Fokus-Management
        document.addEventListener("keydown", (e) => {
          // Verbessere Tab-Navigation
          if (e.key === "Tab") {
            document.body.classList.add("user-is-tabbing");
          }
        });

        // Entferne Klasse, wenn Maus verwendet wird
        document.addEventListener("mousedown", () => {
          document.body.classList.remove("user-is-tabbing");
        });
      }

      // Initialisiere erweiterte Accessibility
      enhanceAccessibility();

      // Initialisiere den Filter beim Laden der Seite
      filterPlaylists();

      // Erweiterte Keyboard-Navigation
      document.addEventListener("keydown", function (e) {
        // '/' drücken, um Suche zu fokussieren
        if (e.key === "/" && document.activeElement?.tagName !== "INPUT") {
          e.preventDefault();
          searchInput?.focus();
        }

        // 'Alt+R' drücken, um Suche zurückzusetzen
        if (e.key === "r" && e.altKey) {
          e.preventDefault();
          if (searchInput) searchInput.value = "";
          filterPlaylists();
          searchInput?.focus();
        }

        // 'Alt+T' drücken, um zum Seitenanfang zu scrollen
        if (e.key === "t" && e.altKey) {
          e.preventDefault();
          document.body.scrollIntoView({
            behavior: REDUCED_MOTION ? "auto" : "smooth",
            block: "start",
          });
        }
      });
    });
  </script>
</Layout>
