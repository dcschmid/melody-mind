---
import Layout from "@layouts/Layout.astro";
import { useTranslations } from "@utils/i18n";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import PlaylistCard from "@components/PlaylistCard.astro";
import BackToTop from "@components/Shared/BackToTop.astro";

import { extractKeywords, generateMetaDescription } from "@utils/seo";

/**
 * Enable static site generation for all supported languages.
 */
export const prerender = true;

/**
 * Define supported languages and generate static paths for each language.
 */
export async function getStaticPaths() {
  const supportedLanguages = [
    "de",
    "en",
    "es",
    "fr",
    "it",
    "pt",
    "da",
    "nl",
    "sv",
    "fi",
    "cn",
    "ru",
    "jp",
    "uk",
  ] as const;

  const allLanguageDataPromises = supportedLanguages.map(async (lang) => {
    try {
      const playlistData = await import(`../../../public/json/playlist/${lang}_playlist.json`);
      return { lang, playlists: playlistData.default };
    } catch {
      try {
        console.warn(`No playlist data found for ${lang}, falling back to English`);
        const fallbackData = await import(`../../../public/json/playlist/en_playlist.json`);
        return { lang, playlists: fallbackData.default };
      } catch (fallbackError) {
        console.error(`Error loading playlist data for ${lang}:`, fallbackError);
        return { lang, playlists: [] };
      }
    }
  });

  const languageData = await Promise.all(allLanguageDataPromises);
  const paths = languageData.map(({ lang, playlists }) => ({
    params: { lang },
    props: { playlists },
  }));

  return paths;
}

const { lang } = Astro.params;
const { playlists } = Astro.props;
const t = useTranslations(lang);

/**
 * Interface for playlist data structure
 */
interface Playlist {
  headline: string;
  imageUrl: string;
  introSubline: string;
  spotifyPlaylist: string;
  deezerPlaylist: string;
  appleMusicPlaylist: string;
  categoryType?: string;
}

// Helper function for decade extraction (moved up)
function getDecadeFromHeadline(headline: string): string {
  const yearMatch = headline.match(/\b(\d{4})\b/);
  if (yearMatch) {
    return `${yearMatch[1].substring(0, 3)}0s`;
  }
  return "Other";
}

// Sort playlists chronologically (moved up)
const sortedPlaylists = [...playlists].sort((a: Playlist, b: Playlist) => {
  const decadeA = getDecadeFromHeadline(a.headline);
  const decadeB = getDecadeFromHeadline(b.headline);
  return decadeA.localeCompare(decadeB, undefined, { sensitivity: "base" });
});

// Enhanced SEO content generation with more detailed information
const title = t("playlist.page.heading");
const description = t("playlist.page.description");

// Create enriched content for better SEO by including playlist information
const playlistDecades = [
  ...new Set(playlists.map((p: Playlist) => getDecadeFromHeadline(p.headline))),
].join(", ");
const playlistCount = playlists.length;
const enrichedContent = `${title} ${description} Explore ${playlistCount} carefully curated music playlists spanning decades including ${playlistDecades}. Each playlist features authentic tracks from legendary artists and iconic albums. Perfect for music enthusiasts, trivia players, and anyone looking to discover classic hits from different musical eras.`;

const optimizedDescription = generateMetaDescription(enrichedContent, 158);
const keywords = extractKeywords(enrichedContent, 12, lang);

// SEO-optimized URL and canonical setup
const baseUrl = Astro.site?.toString() || "https://melody-mind.de";
const currentUrl = `${baseUrl}/${lang}/playlists`;

// Enhanced structured data for playlist collection
const playlistCollectionSchema = {
  "@context": "https://schema.org",
  "@type": "ItemList",
  name: `${title} | Melody Mind`,
  description: optimizedDescription,
  url: currentUrl,
  numberOfItems: playlistCount,
  itemListOrder: "chronological",
  itemListElement: sortedPlaylists.slice(0, 10).map((playlist, index) => ({
    "@type": "MusicPlaylist",
    position: index + 1,
    name: playlist.headline,
    description: playlist.introSubline || playlist.headline,
    url: `${currentUrl}#playlist-${index}`,
    genre: getDecadeFromHeadline(playlist.headline),
    inLanguage: lang,
    creator: {
      "@type": "Organization",
      name: "Melody Mind",
    },
  })),
};

// Breadcrumb structured data for better navigation SEO
const breadcrumbSchema = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  itemListElement: [
    {
      "@type": "ListItem",
      position: 1,
      name: t("nav.home"),
      item: `${baseUrl}/${lang}/`,
    },
    {
      "@type": "ListItem",
      position: 2,
      name: title,
      item: currentUrl,
    },
  ],
};
---

<Layout
  {title}
  description={optimizedDescription}
  {keywords}
  image={`/og-images/social-share-playlist-${lang}.jpg`}
  type="website"
  publishDate={new Date()}
  modifiedDate={new Date()}
>
  <!-- Enhanced SEO structured data -->
  <Fragment slot="head">
    <script
      is:inline
      type="application/ld+json"
      set:html={JSON.stringify(playlistCollectionSchema)}
    />
    <script is:inline type="application/ld+json" set:html={JSON.stringify(breadcrumbSchema)} />
    <meta name="robots" content="index, follow, max-image-preview:large" />
    <meta name="googlebot" content="index, follow" />
    <link rel="canonical" href={currentUrl} />

    <!-- Additional SEO meta tags -->
    <meta name="author" content="Melody Mind Team" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content={`${lang}_${lang.toUpperCase()}`} />
    <meta property="article:section" content="Music" />
    <meta property="article:tag" content="Music Playlists" />
    <meta property="article:tag" content="Music History" />
    <meta property="article:tag" content="Music Discovery" />

    <!-- Music-specific meta tags -->
    <meta name="music:genre" content="Various" />
    <meta name="music:playlist_count" content={playlistCount.toString()} />
    <meta name="music:decades" content={playlistDecades} />

    <!-- Enhanced Open Graph for better social sharing -->
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:type" content="image/jpeg" />

    <!-- Twitter Card enhancements -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@melodymind" />
    <meta name="twitter:creator" content="@melodymind" />
  </Fragment>

  <main class="min-h-screen bg-gray-900 py-8 text-white">
    <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
      <!-- Hero section -->
      <section
        class="relative mb-16 overflow-hidden rounded-3xl border border-purple-500/30 bg-gradient-to-br from-purple-900 via-blue-800 to-gray-900 p-8 shadow-2xl sm:p-12 lg:p-16"
        aria-labelledby="playlist-heading"
      >
        <!-- Decorative background elements -->
        <div class="pointer-events-none absolute inset-0 opacity-10" aria-hidden="true">
          <div class="absolute -top-8 -right-8 h-32 w-32 rounded-full bg-white"></div>
          <div class="absolute -bottom-8 -left-8 h-24 w-24 rounded-full bg-white"></div>
          <div class="absolute top-1/2 right-4 h-16 w-16 rounded-full bg-white"></div>
        </div>

        <div class="relative z-10 w-full text-center text-white">
          <Headline level="h1" textSize="3xl" textAlign="center">
            {t("playlist.page.heading")}
          </Headline>
          <div class="mx-auto my-8 h-1 w-12 rounded-full bg-blue-400"></div>
          <Paragraph textAlign="center" textSize="lg">
            {t("playlist.page.description")}
          </Paragraph>
        </div>
      </section>

      <!-- Enhanced Search Section - Much Wider & Better Looking -->
      <section class="mb-16" aria-labelledby="search-heading">
        <div class="mx-auto w-full max-w-7xl px-4 sm:px-6 lg:px-8">
          <!-- Search Heading -->
          <div class="mb-10 text-center">
            <Headline level="h2" textSize="2xl" textAlign="center">
              {t("playlist.search.heading") || "Playlists durchsuchen"}
            </Headline>
            <Paragraph textAlign="center" textSize="lg">
              Finde deine Lieblingsmusik nach Künstler, Stil, Epoche oder Genre
            </Paragraph>
          </div>

          <!-- Enhanced Search Field - Much Wider -->
          <div class="relative mx-auto w-full max-w-5xl">
            <label for="playlist-search" class="sr-only">
              {t("playlist.search.aria.label") || "Musik-Playlists durchsuchen"}
            </label>

            <!-- Search Input with Glassmorphism - Full Width -->
            <div class="relative">
              <div
                class="pointer-events-none absolute inset-y-0 left-0 z-10 flex items-center pl-6"
              >
                <svg
                  class="h-7 w-7 text-purple-400"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                </svg>
              </div>

              <input
                type="text"
                id="playlist-search"
                class="block w-full rounded-3xl border-2 border-purple-500/40 bg-gray-800/90 py-5 pr-20 pl-16 text-xl font-medium text-white placeholder-gray-400 shadow-2xl backdrop-blur-md transition-all duration-300 hover:shadow-purple-500/20 focus:border-purple-400 focus:ring-4 focus:ring-purple-500/60 focus:outline-none"
                placeholder={t("playlist.search.placeholder") ||
                  "Suchen nach Künstler oder Stil..."}
                aria-describedby="search-examples"
              />

              <!-- Clear Button -->
              <button
                type="button"
                id="clear-search"
                class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-6 text-gray-400 opacity-0 transition-colors duration-200 hover:text-purple-400"
                aria-label="Suche löschen"
              >
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M6 18L18 6M6 6l12 12"></path>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </section>

      <!-- Enhanced Playlist Grid with semantic markup and microdata -->
      <section aria-labelledby="playlists-heading">
        <Headline level="h2" textSize="base" className="sr-only">
          {t("playlist.grid.heading", { count: playlistCount })}
        </Headline>

        {/* Simple sorted playlist grid */}
        <div class="grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3" id="playlist-grid">
          {
            sortedPlaylists.map((playlist, index) => (
              <div
                class="playlist-item overflow-hidden rounded-2xl border border-gray-700 bg-gray-800 shadow-lg transition-all duration-300 hover:-translate-y-1 hover:shadow-xl"
                itemscope
                itemtype="https://schema.org/MusicPlaylist"
                data-search-text={`${playlist.headline} ${playlist.introSubline || ""} ${playlist.categoryType || ""}`.toLowerCase()}
              >
                <meta itemprop="name" content={playlist.headline} />
                <meta itemprop="description" content={playlist.introSubline || playlist.headline} />
                <meta
                  itemprop="genre"
                  content={playlist.categoryType || getDecadeFromHeadline(playlist.headline)}
                />
                <meta itemprop="inLanguage" content={lang} />
                <PlaylistCard
                  headline={playlist.headline}
                  imageUrl={playlist.imageUrl}
                  introSubline={playlist.introSubline}
                  spotifyPlaylist={playlist.spotifyPlaylist}
                  deezerPlaylist={playlist.deezerPlaylist}
                  appleMusicPlaylist={playlist.appleMusicPlaylist}
                  index={index}
                  lang={lang}
                />
              </div>
            ))
          }
        </div>
      </section>
    </div>
  </main>

  <!-- Back to Top Button -->
  <BackToTop {lang} />
</Layout>

<script>
  // Enhanced playlist search functionality
  document.addEventListener("DOMContentLoaded", () => {
    const searchInput = document.getElementById("playlist-search") as HTMLInputElement;
    const clearButton = document.getElementById("clear-search") as HTMLButtonElement;
    const playlistItems = document.querySelectorAll(".playlist-item");
    const searchExamples = document.getElementById("search-examples") as HTMLElement;
    const searchExampleButtons = document.querySelectorAll(
      ".search-example"
    ) as NodeListOf<HTMLButtonElement>;

    if (!searchInput || !clearButton) {
      return;
    }

    // Show/hide clear button based on input
    function toggleClearButton() {
      if (searchInput.value.trim()) {
        clearButton.classList.remove("opacity-0", "pointer-events-none");
        clearButton.classList.add("opacity-100", "pointer-events-auto");
      } else {
        clearButton.classList.add("opacity-0", "pointer-events-none");
        clearButton.classList.remove("opacity-100", "pointer-events-auto");
      }
    }

    // Clear search functionality
    clearButton.addEventListener("click", () => {
      searchInput.value = "";
      searchInput.focus();
      toggleClearButton();
      showAllPlaylists();
      showSearchExamples();
    });

    // Calculate search score for an element
    function calculateScore(
      element: HTMLElement,
      searchWords: string[],
      searchTerm: string
    ): number {
      const searchText = element.getAttribute("data-search-text") || "";
      const headline = element.querySelector('[itemprop="name"]')?.getAttribute("content") || "";
      const description =
        element.querySelector('[itemprop="description"]')?.getAttribute("content") || "";
      const genre = element.querySelector('[itemprop="genre"]')?.getAttribute("content") || "";

      let score = 0;
      const fullText = `${headline} ${description} ${genre} ${searchText}`.toLowerCase();

      searchWords.forEach((word) => {
        if (headline.toLowerCase().includes(word)) {
          score += 10;
        }
        if (description.toLowerCase().includes(word)) {
          score += 8;
        }
        if (genre.toLowerCase().includes(word)) {
          score += 6;
        }
        if (searchText.toLowerCase().includes(word)) {
          score += 4;
        }
        if (fullText.includes(word)) {
          score += 2;
        }

        const wordBoundaryRegex = new RegExp(`\\b${word}`, "i");
        if (wordBoundaryRegex.test(fullText)) {
          score += 3;
        }
      });

      if (headline.toLowerCase().startsWith(searchTerm.toLowerCase())) {
        score += 5;
      }
      if (genre.toLowerCase() === searchTerm.toLowerCase()) {
        score += 8;
      }

      return score;
    }

    // Enhanced search functionality with fuzzy matching and scoring
    function performSearch(searchTerm: string) {
      if (!searchTerm.trim()) {
        showAllPlaylists();
        showSearchExamples();
        return;
      }

      const searchWords = searchTerm
        .toLowerCase()
        .split(/\s+/)
        .filter((word) => word.length > 0);
      let hasResults = false;
      const bestMatches: Array<{ element: HTMLElement; score: number; searchText: string }> = [];

      playlistItems.forEach((item) => {
        const element = item as HTMLElement;
        const score = calculateScore(element, searchWords, searchTerm);

        if (score > 0) {
          hasResults = true;
          bestMatches.push({
            element,
            score,
            searchText: element.getAttribute("data-search-text") || "",
          });
          element.style.display = "block";
          element.style.opacity = "1";
          element.style.transform = "scale(1)";
        } else {
          element.style.display = "none";
          element.style.opacity = "0";
          element.style.transform = "scale(0.95)";
        }
      });

      if (bestMatches.length > 1) {
        bestMatches.sort((a, b) => b.score - a.score);
        const playlistGrid = document.getElementById("playlist-grid");
        if (playlistGrid) {
          bestMatches.forEach(({ element }) => playlistGrid.appendChild(element));
        }
      }

      showNoResultsMessage(hasResults, searchTerm);
    }

    // Show all playlists
    function showAllPlaylists() {
      playlistItems.forEach((item) => {
        (item as HTMLElement).style.display = "block";
        (item as HTMLElement).style.opacity = "1";
        (item as HTMLElement).style.transform = "scale(1)";
      });
    }

    // Show/hide search examples
    function showSearchExamples() {
      if (searchExamples) {
        searchExamples.style.display = "block";
      }
    }

    // function _hideSearchExamples() {
    //   if (searchExamples) {
    //     searchExamples.style.display = "none";
    //   }
    // }

    // Show no results message with search suggestions
    function showNoResultsMessage(hasResults: boolean, searchTerm: string) {
      let noResultsElement = document.getElementById("no-results-message");

      if (!hasResults && searchTerm.trim()) {
        if (!noResultsElement) {
          // Generate search suggestions based on available content
          const suggestions = generateSearchSuggestions(searchTerm);

          noResultsElement = document.createElement("div");
          noResultsElement.id = "no-results-message";
          noResultsElement.className = "text-center py-12";
          noResultsElement.innerHTML = `
            <div class="text-gray-400 mb-6">
              <svg class="mx-auto h-16 w-16 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6-4h6m2 5.291A7.962 7.962 0 0112 15c-2.34 0-4.47-.881-6.08-2.33" />
              </svg>
            </div>
            <h3 class="text-xl font-semibold text-gray-300 mb-3">Keine Ergebnisse gefunden</h3>
            <p class="text-gray-400 mb-6">Für "${searchTerm}" wurden keine Playlists gefunden.</p>
            
            ${
              suggestions.length > 0
                ? `
              <div class="mb-6">
                <p class="text-sm text-gray-400 mb-3">Vielleicht meintest du:</p>
                <div class="flex flex-wrap justify-center gap-2">
                  ${suggestions
                    .map(
                      (suggestion) => `
                    <button
                      type="button"
                      class="px-3 py-1 bg-purple-500/30 border border-purple-500/50 rounded-full text-purple-200 hover:bg-purple-500/40 transition-colors duration-200 cursor-pointer text-sm"
                      onclick="document.getElementById('playlist-search').value='${suggestion}'; document.getElementById('playlist-search').dispatchEvent(new Event('input'));"
                    >
                      ${suggestion}
                    </button>
                  `
                    )
                    .join("")}
                </div>
              </div>
            `
                : ""
            }
            
            <div class="flex flex-wrap justify-center gap-3 text-sm">
              <span class="px-4 py-2 bg-purple-500/20 border border-purple-500/30 rounded-full text-purple-300">
                Versuche andere Begriffe
              </span>
              <span class="px-4 py-2 bg-blue-500/20 border border-blue-500/30 rounded-full text-blue-300">
                Oder lösche die Suche
              </span>
            </div>
          `;

          const playlistGrid = document.getElementById("playlist-grid");
          if (playlistGrid) {
            playlistGrid.parentNode?.insertBefore(noResultsElement, playlistGrid.nextSibling);
          }
        }
      } else if (noResultsElement) {
        noResultsElement.remove();
      }
    }

    // Generate search suggestions based on available content
    function generateSearchSuggestions(searchTerm: string): string[] {
      const suggestions: string[] = [];
      const searchWords = searchTerm.toLowerCase().split(/\s+/);

      // Common music terms that might be similar
      const musicTerms = [
        "rock",
        "pop",
        "jazz",
        "disco",
        "blues",
        "country",
        "electronic",
        "folk",
        "reggae",
        "hip-hop",
      ];
      const decades = ["1950s", "1960s", "1970s", "1980s", "1990s", "2000s", "2010s"];

      searchWords.forEach((word) => {
        // Check for similar music terms
        musicTerms.forEach((term) => {
          if (
            term.includes(word) ||
            word.includes(term) ||
            (word.length > 2 && term.includes(word.substring(0, 3)))
          ) {
            if (!suggestions.includes(term)) {
              suggestions.push(term);
            }
          }
        });

        // Check for similar decades
        decades.forEach((decade) => {
          if (decade.includes(word) || word.includes(decade)) {
            if (!suggestions.includes(decade)) {
              suggestions.push(decade);
            }
          }
        });
      });

      return suggestions.slice(0, 4); // Limit to 4 suggestions
    }

    // Debounced search function for better performance
    let searchTimeout: NodeJS.Timeout;

    function debouncedSearch(searchTerm: string) {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        performSearch(searchTerm);
      }, 300); // 300ms delay for better UX
    }

    // Search input event listener with debouncing
    searchInput.addEventListener("input", (e) => {
      const target = e.target as HTMLInputElement;
      const searchTerm = target.value.toLowerCase().trim();

      toggleClearButton();
      debouncedSearch(searchTerm);
    });

    // Search on Enter key
    searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        searchInput.blur();
      }
    });

    // Add click handlers for search example buttons
    searchExampleButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const searchTerm = button.getAttribute("data-search") || "";
        searchInput.value = searchTerm;
        searchInput.focus();
        toggleClearButton();
        performSearch(searchTerm);

        // Add visual feedback
        button.classList.add("ring-2", "ring-purple-500", "ring-opacity-50");
        setTimeout(() => {
          button.classList.remove("ring-2", "ring-purple-500", "ring-opacity-50");
        }, 500);
      });
    });

    // Initial state
    toggleClearButton();
  });
</script>
