---
import Layout from "@layouts/Layout.astro";
import { useTranslations } from "@utils/i18n";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import PlaylistCard from "@components/PlaylistCard.astro";
import { Icon } from "astro-icon/components";
import { extractKeywords, generateMetaDescription } from "@utils/seo";
import { Picture } from "astro:assets";

/**
 * Enable static site generation for all supported languages.
 * This ensures the playlist pages are pre-rendered at build time for optimal performance.
 * @see https://docs.astro.build/en/reference/directives-reference/#prerender
 */
export const prerender = true;

/**
 * Define supported languages and generate static paths for each language.
 * This creates separate routes for each language version of the playlist page.
 * @returns {Array} Array of route objects with params and props
 */
export async function getStaticPaths() {
  // Define all languages supported by the application
  const supportedLanguages = ["de", "en", "es", "fr", "it", "pt", "da", "nl", "sv", "fi"] as const;

  // Optimierte parallele Datenaufrufe mit Promise.all
  // Lädt alle Sprachdateien gleichzeitig und verarbeitet sie parallel
  const allLanguageDataPromises = supportedLanguages.map(async (lang) => {
    // Versuche, Playlist-Daten für die spezifische Sprache zu laden
    try {
      // Dynamischer Import mit Promise.all für parallele Verarbeitung
      const playlistData = await import(`../../../public/json/playlist/${lang}_playlist.json`);
      return { lang, playlists: playlistData.default };
    } catch (error) {
      // Fallback zu Englisch, wenn die Sprachdatei nicht existiert
      try {
        console.info(`No playlist data found for ${lang}, falling back to English`);
        const fallbackData = await import(`../../../public/json/playlist/en_playlist.json`);
        return { lang, playlists: fallbackData.default };
      } catch (fallbackError) {
        console.error(`Error loading playlist data for ${lang}:`, fallbackError);
        return { lang, playlists: [] };
      }
    }
  });

  // Warte auf alle Datenaufrufe und erstelle die Pfade
  const languageData = await Promise.all(allLanguageDataPromises);

  // Transformiere die Daten in das erwartete Format
  const paths = languageData.map(({ lang, playlists }) => ({
    params: { lang },
    props: { lang, playlists },
  }));

  return paths;
}

/**
 * Type definition for component props
 */
interface Props {
  lang: "de" | "en" | "es" | "fr" | "it" | "pt" | "da" | "nl" | "sv" | "fi";
  playlists: PlaylistData[];
}

/**
 * Type definition for playlist objects
 */
interface PlaylistData {
  headline: string;
  imageUrl: string;
  introSubline: string;
  spotifyPlaylist?: string;
  deezerPlaylist?: string;
  appleMusicPlaylist?: string;
}

// Extract data from props with default empty array for playlists
const { lang, playlists = [] } = Astro.props;

// Use the i18n utilities for translations
const t = useTranslations(lang);

// Generate SEO content
const title = t("playlist.page.title");
const description = t("playlist.page.description");

// Enhanced SEO content using utility functions
const pageContent = `${title} ${description} ${playlists.map((p) => `${p.headline} ${p.introSubline}`).join(" ")}`;

// Generate optimized meta description and keywords
const optimizedDescription = generateMetaDescription(pageContent);
const keywords = extractKeywords(pageContent) || t("meta.keywords");

// Additional structured data parameters for SEO
const pageType = "website";
const publishDate = new Date("2024-01-01");
const modifiedDate = new Date();

// Verbesserte Hilfsfunktion zur Extraktion des Jahrzehnts aus der Überschrift
function getDecadeFromHeadline(headline: string): string {
  // Suche nach 4-stelligen Jahreszahlen (z.B. 1960, 2020)
  const yearMatch = headline.match(/\b(\d{4})\b/);
  if (yearMatch) {
    return `${yearMatch[1].substring(0, 3)}0s`;
  }

  // Suche nach Jahrzehnten im Format "1960s", "60er", "Sixties" usw.
  const decadePatterns = [
    {
      pattern: /\b(\d{2})(?:er|s)\b/i,
      transform: (match: string) => {
        const decade = parseInt(match);
        return `${(decade < 30 ? "20" : "19") + match}0s`;
      },
    },
    {
      pattern: /\b(19\d0)(?:er|s)\b/i,
      transform: (match: string) => `${match}s`,
    },
    {
      pattern: /\b(20\d0)(?:er|s)\b/i,
      transform: (match: string) => `${match}s`,
    },
    { pattern: /\bsixties\b/i, transform: () => "1960s" },
    { pattern: /\bseventies\b/i, transform: () => "1970s" },
    { pattern: /\beighties\b/i, transform: () => "1980s" },
    { pattern: /\bnineties\b/i, transform: () => "1990s" },
  ];

  for (const { pattern, transform } of decadePatterns) {
    const match = headline.match(pattern);
    if (match) {
      return transform(match[1]);
    }
  }

  return "Other";
}

// Sort playlists chronologically basierend auf dem extrahierten Jahrzehnt
const sortedPlaylists = [...playlists].sort((a, b) => {
  const decadeA = getDecadeFromHeadline(a.headline);
  const decadeB = getDecadeFromHeadline(b.headline);
  return decadeA.localeCompare(decadeB, undefined, { sensitivity: "base" });
});
---

<Layout
  {title}
  description={optimizedDescription}
  {keywords}
  image={`/og-images/social-share-playlist-${lang}.jpg`}
  type={pageType}
  {publishDate}
  {modifiedDate}
>
  <!-- Strukturierte Daten für SEO -->
  <script
    type="application/ld+json"
    set:html={JSON.stringify([
      // BreadcrumbList Schema
      {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        itemListElement: [
          {
            "@type": "ListItem",
            position: 1,
            name: "Home",
            item: `${Astro.site}${lang}`,
          },
          {
            "@type": "ListItem",
            position: 2,
            name: title,
            item: `${Astro.site}${lang}/playlists`,
          },
        ],
      },
      // ItemList Schema für die Playlist-Sammlung
      {
        "@context": "https://schema.org",
        "@type": "ItemList",
        numberOfItems: sortedPlaylists.length,
        itemListOrder: "Ascending",
        itemListElement: sortedPlaylists.map((playlist, index) => ({
          "@type": "ListItem",
          position: index + 1,
          item: {
            "@type": "MusicPlaylist",
            name: playlist.headline,
            description: playlist.introSubline,
            image: playlist.imageUrl.startsWith("http")
              ? playlist.imageUrl
              : `${Astro.site}${playlist.imageUrl.replace(/^\//, "")}`,
            url: `${Astro.site}${lang}/playlists#playlist-${index}`,
            numTracks: playlist.spotifyPlaylist ? 1 : 0,
            provider: [
              playlist.spotifyPlaylist ? { "@type": "MusicService", name: "Spotify" } : null,
              playlist.deezerPlaylist ? { "@type": "MusicService", name: "Deezer" } : null,
              playlist.appleMusicPlaylist ? { "@type": "MusicService", name: "Apple Music" } : null,
            ].filter(Boolean),
          },
        })),
      },
      // Zusätzliches WebPage Schema für verbesserte Sichtbarkeit
      {
        "@context": "https://schema.org",
        "@type": "CollectionPage",
        name: title,
        description: optimizedDescription,
        url: `${Astro.site}${lang}/playlists`,
        isPartOf: {
          "@type": "WebSite",
          name: "Melody Mind",
          url: `${Astro.site}`,
        },
        datePublished: publishDate.toISOString(),
        dateModified: modifiedDate.toISOString(),
        inLanguage: lang,
        mainEntity: {
          "@type": "ItemList",
          itemListElement: sortedPlaylists.map((_, index) => ({
            "@type": "ListItem",
            position: index + 1,
            url: `${Astro.site}${lang}/playlists#playlist-${index}`,
          })),
        },
      },
    ])}
  />
  <main
    class="mx-auto max-w-7xl px-4 py-10 sm:px-6 sm:py-12 lg:px-8 lg:py-14"
    style="contain: content;"
    id="main-content"
  >
    <!-- Skip-Link-Ziel für Tastaturnavigation -->
    <div id="skip-link-target" tabindex="-1" class="sr-only">Hauptinhalt beginnt hier</div>
    <!-- Page heading and description -->
    <div class="mb-10 text-center sm:mb-12 lg:mb-14">
      <Headline
        title={t("playlist.page.heading")}
        level="h1"
        className="mb-5 text-3xl leading-tight font-bold tracking-wide text-white sm:text-4xl lg:text-5xl"
      />
      <div
        class="mx-auto mt-3 mb-5 h-1.5 w-20 rounded-full bg-purple-400 sm:mb-7 sm:w-28"
        aria-hidden="true"
      >
      </div>
      <Paragraph
        description={t("playlist.page.description")}
        className="mx-auto max-w-xl text-lg leading-relaxed tracking-wide text-white sm:max-w-2xl sm:text-xl lg:text-2xl"
      />
    </div>

    <!-- Search and filter section -->
    <div
      class="search-filter-container mb-10 rounded-xl border border-zinc-600 bg-zinc-900 p-5 shadow-lg sm:mb-12 sm:p-7 lg:p-9"
      role="search"
      aria-labelledby="search-heading"
    >
      <h2 id="search-heading" class="sr-only mb-4 text-xl font-bold">
        {t("playlist.search.label")}
      </h2>

      <div class="mb-5 flex flex-col gap-4 sm:mb-7 sm:flex-row sm:gap-5">
        <!-- Search field -->
        <div class="relative flex-grow">
          <label for="playlist-search" class="sr-only">
            {t("playlist.search.placeholder")}
          </label>
          <div class="relative">
            <div
              class="pointer-events-none absolute inset-y-0 left-4 flex items-center"
              aria-hidden="true"
            >
              <Icon name="search" class="h-6 w-6 text-purple-300" />
            </div>
            <input
              type="search"
              id="playlist-search"
              placeholder={t("playlist.search.placeholder")}
              class="min-h-[60px] w-full touch-manipulation rounded-xl border-3 border-zinc-500 bg-zinc-800 py-4 pr-5 pl-12 text-lg text-white placeholder-zinc-300 transition-all duration-200 ease-out hover:border-zinc-400 focus:border-purple-400 focus:ring-4 focus:ring-purple-400/70 focus:outline-none active:border-purple-400 sm:text-xl"
              aria-controls="playlist-grid"
              aria-describedby="search-playlist-description"
              aria-label={t("playlist.search.label") || "Playlists durchsuchen"}
              autocomplete="off"
              enterkeyhint="search"
            />
            <div id="search-playlist-description" class="sr-only">
              {
                t("playlist.search.live.description") ||
                  "Results are filtered automatically as you type"
              }
            </div>
          </div>
        </div>
      </div>

      <!-- Search status for screen readers -->
      <div
        id="search-results-status"
        class="sr-only"
        aria-live="polite"
        aria-atomic="true"
        role="status"
      >
      </div>

      <!-- No results message (initially hidden) -->
      <div
        id="no-results"
        class="mb-8 flex hidden flex-col items-center justify-center rounded-xl border border-zinc-500 bg-gradient-to-br from-zinc-800 to-zinc-900 p-8 text-center shadow-md sm:mb-10 sm:p-10 lg:p-12"
        aria-live="polite"
        role="status"
      >
        <Icon
          name="search-no-results"
          class="mb-4 h-14 w-14 text-zinc-300 sm:mb-5 sm:h-18 sm:w-18"
          aria-hidden="true"
        />
        <h2 class="mb-3 text-xl font-bold tracking-wide text-white sm:text-2xl">
          {t("playlist.no.results.heading") || "No playlists found"}
        </h2>
        <p class="mb-4 text-lg leading-relaxed text-white sm:mb-5 sm:text-xl">
          {t("playlist.no.results")}
        </p>
        <button
          id="reset-search"
          class="mt-3 min-h-[60px] min-w-[170px] touch-manipulation rounded-lg bg-purple-700 px-6 py-4 text-lg font-bold text-white transition-colors transition-transform duration-200 ease-out hover:bg-purple-600 focus:ring-4 focus:ring-purple-400/70 focus:ring-offset-4 focus:ring-offset-zinc-900 focus:outline-none active:translate-y-[1px] active:scale-95 active:bg-purple-800 sm:px-7 sm:text-xl"
          aria-label={t("playlist.reset.search.button") || "Suchfilter zurücksetzen"}
        >
          {t("playlist.reset.search") || "Reset search"}
        </button>
      </div>

      <!-- Playlist Grid -->
      <ul
        id="playlist-grid"
        class="grid grid-cols-1 gap-6 will-change-contents contain-layout sm:gap-8 md:grid-cols-2 lg:gap-10"
        aria-label={t("playlist.page.heading")}
        aria-live="polite"
        aria-relevant="additions removals"
        aria-atomic="false"
        itemscope
        itemtype="https://schema.org/ItemList"
        style="content-visibility: auto; contain-intrinsic-size: auto 500px; transform: translateZ(0);"
      >
        {
          sortedPlaylists.map((playlist, index) => (
            <li
              class="playlist-card"
              itemscope
              itemtype="https://schema.org/ListItem"
              itemprop="itemListElement"
              data-searchable={`${playlist.headline.toLowerCase()} ${playlist.introSubline.toLowerCase()}`}
              data-decade={getDecadeFromHeadline(playlist.headline)}
              data-index={index}
              id={`playlist-${index}`}
              aria-posinset={index + 1}
              aria-setsize={sortedPlaylists.length}
              style={{
                animationDelay: `${index * 0.05}s`,
                contain: "content",
                transform: "translateZ(0)",
              }}
            >
              <meta itemprop="position" content={`${index + 1}`} />
              <PlaylistCard
                headline={playlist.headline}
                imageUrl={playlist.imageUrl}
                introSubline={playlist.introSubline}
                spotifyPlaylist={playlist.spotifyPlaylist}
                deezerPlaylist={playlist.deezerPlaylist}
                appleMusicPlaylist={playlist.appleMusicPlaylist}
                index={index}
                lang={lang}
              />
            </li>
          ))
        }
      </ul>

      <!-- Back to top button -->
      <button
        id="back-to-top"
        class="invisible fixed right-6 bottom-6 z-50 flex min-h-[64px] min-w-[64px] touch-manipulation items-center justify-center rounded-full bg-purple-700 p-4 text-white opacity-0 shadow-lg transition-all duration-200 ease-out hover:bg-purple-600 focus:ring-4 focus:ring-purple-400/70 focus:ring-offset-4 focus:ring-offset-zinc-900 focus:outline-none active:translate-y-[1px] active:scale-95 active:bg-purple-800 sm:right-8 sm:bottom-8 sm:min-h-[72px] sm:min-w-[72px] sm:p-5 lg:right-10 lg:bottom-10"
        aria-label={t("back.to.top") || "Zurück zum Seitenanfang"}
        style="transform: translateZ(0);"
      >
        <Icon name="arrow-up" class="h-6 w-6 sm:h-7 sm:w-7" aria-hidden="true" />
      </button>
    </div>
  </main>

  <style>
    /* Improved color contrast for WCAG AAA (7:1) */
    :root {
      --text-primary: #ffffff; /* Maximum contrast */
      --text-secondary: #f8f8ff; /* Higher contrast than standard zinc-300 */
      --bg-card: #18181b; /* zinc-900 - darker for better contrast */
      --border-card: rgba(212, 212, 216, 0.4); /* zinc-300 with transparency */
      --accent-primary: #8b5cf6; /* purple-500 - optimized for contrast */
      --accent-secondary: #a78bfa; /* purple-400 */
      --touch-target-size: 48px; /* Increased minimum touch target size */
      --focus-ring-width: 4px; /* Increased focus ring width */
      --focus-ring-offset: 4px; /* Increased focus ring offset */
    }

    /* Verbesserte Unterstützung für hohen Kontrast (WCAG AAA) */
    @media (forced-colors: active), (prefers-contrast: more) {
      :root {
        --accent-primary: SelectedItem;
        --accent-secondary: SelectedItemText;
        --border-card: ButtonBorder;
      }

      /* Verbesserte Sichtbarkeit für Elemente im hohen Kontrast-Modus */
      .playlist-card {
        border: 2px solid ButtonBorder !important;
        outline: 1px solid transparent;
      }

      /* Verbesserte Fokus-Indikatoren für hohen Kontrast */
      :focus-visible {
        outline: 3px solid SelectedItem !important;
        outline-offset: 4px !important;
      }

      /* Verbesserte Button-Kontraste */
      button,
      a[role="button"],
      input[type="search"] {
        border: 2px solid ButtonBorder !important;
      }

      /* Verbesserte Icon-Sichtbarkeit */
      svg {
        fill: currentColor !important;
        stroke: currentColor !important;
        forced-color-adjust: none;
      }
    }

    /* Improved focus states for keyboard navigation */
    :focus-visible {
      outline: var(--focus-ring-width) solid var(--accent-primary);
      outline-offset: var(--focus-ring-offset);
    }

    /* Animations for cards */
    @keyframes fadeIn {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      60% {
        opacity: 0.8;
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes shimmer {
      0% {
        background-position: -200% 0;
      }
      100% {
        background-position: 200% 0;
      }
    }

    .animate-fadeIn {
      animation: fadeIn 0.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
      opacity: 0;
      will-change: opacity, transform;
    }

    /* Progressive Loading Animation */
    .loading-shimmer {
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0.05) 0%,
        rgba(255, 255, 255, 0.1) 50%,
        rgba(255, 255, 255, 0.05) 100%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      will-change: background-position;
    }

    /* Improved back-to-top button animation */
    #back-to-top.visible {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    #back-to-top {
      transform: translateY(10px);
    }

    /* Optimized loading for better performance */
    .touch-manipulation {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    /* Optimized scrolling performance */
    .will-change-contents {
      will-change: contents;
      transform: translateZ(0);
      backface-visibility: hidden;
    }

    .contain-layout {
      contain: layout style;
    }

    /* Responsive adjustments */
    @media (max-width: 640px) {
      .playlist-card {
        contain: content;
      }

      /* Verbesserte Touch-Targets für mobile Geräte */
      button,
      input[type="search"],
      a[role="button"] {
        min-height: var(--touch-target-size);
        min-width: var(--touch-target-size);
      }

      /* Optimierte Abstände für Touch-Geräte */
      .gap-2 {
        gap: 0.625rem !important; /* 10px */
      }
    }

    /* Verbesserte Unterstützung für Textvergrößerung (WCAG AAA) */
    @media (min-resolution: 1dppx) {
      html {
        /* Erlaubt Textvergrößerung ohne Verlust von Inhalten */
        -webkit-text-size-adjust: 100%;
        text-size-adjust: 100%;
      }
    }

    /* Optimierungen für Textvergrößerung bis 200% */
    @media screen and (max-width: 640px),
      (min-width: 641px) and (max-width: 1024px) and (min-resolution: 1dppx) {
      /* Verbesserte Lesbarkeit bei vergrößertem Text */
      .text-base {
        font-size: max(1rem, 16px);
        line-height: 1.8;
      }

      .text-lg {
        font-size: max(1.125rem, 18px);
        line-height: 1.8;
      }

      .text-xl {
        font-size: max(1.25rem, 20px);
        line-height: 1.8;
      }

      /* Verbesserte Abstände für vergrößerten Text */
      .p-5,
      .p-6 {
        padding: max(1.25rem, 20px);
      }

      /* Flexiblere Layouts für vergrößerten Text */
      .grid {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      /* Verbesserte Button-Größen für vergrößerten Text */
      button,
      a[role="button"] {
        padding-left: max(1rem, 16px);
        padding-right: max(1rem, 16px);
      }
    }

    /* Improved touch feedback */
    @media (hover: none) {
      button:active,
      input:active,
      a:active {
        transform: scale(0.97);
      }
    }

    /* Verbesserte Unterstützung für reduzierte Bewegung (WCAG AAA) */
    @media (prefers-reduced-motion: reduce) {
      *,
      ::before,
      ::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }

      .animate-fadeIn {
        opacity: 1;
        animation: none !important;
        transform: translateY(0);
      }

      .loading-shimmer {
        animation: none !important;
        background: rgba(255, 255, 255, 0.05);
      }

      .playlist-card:hover,
      button:active,
      a:active {
        transform: none !important;
        scale: none !important;
        box-shadow: none !important;
      }

      #back-to-top {
        transform: none;
      }

      html {
        scroll-behavior: auto !important;
      }

      /* Verbesserte statische Fokus-Indikatoren für reduzierte Bewegung */
      :focus {
        outline: 4px solid var(--accent-primary) !important;
        outline-offset: 4px !important;
      }

      /* Statische Alternativen für Hover-Effekte */
      .playlist-card:focus-within {
        border-color: var(--accent-primary) !important;
        box-shadow: 0 0 0 2px var(--accent-primary) !important;
      }

      /* Verbesserte Kontraste für Benutzer mit reduzierter Bewegung */
      button,
      a[role="button"] {
        border: 2px solid transparent;
      }

      button:focus,
      a[role="button"]:focus {
        border-color: white !important;
      }
    }
  </style>

  <style is:global>
    /* Verbesserte Fokus-Stile für Tastaturbenutzer */
    .user-is-tabbing :focus:not(:focus-visible) {
      outline: none;
      box-shadow: none;
    }

    .user-is-tabbing :focus-visible {
      outline: var(--focus-ring-width) solid var(--accent-primary);
      outline-offset: var(--focus-ring-offset);
      box-shadow: 0 0 0 var(--focus-ring-width) rgba(139, 92, 246, 0.5);
    }

    /* Verbesserte Screenreader-Unterstützung */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    /* Verbesserte Skip-Links für Tastaturbenutzer */
    .sr-only.focus:not-sr-only,
    .sr-only:focus-visible {
      position: fixed;
      top: 1rem;
      left: 1rem;
      width: auto;
      height: auto;
      padding: 1rem 1.5rem;
      background-color: var(--accent-primary);
      color: white;
      font-weight: bold;
      font-size: 1.125rem;
      line-height: 1.5;
      text-align: center;
      overflow: visible;
      clip: auto;
      white-space: normal;
      z-index: 9999;
      border-radius: 0.5rem;
      box-shadow:
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Optimierte Rendering-Performance */
    img,
    video {
      image-rendering: high-quality;
      backface-visibility: hidden;
    }

    /* Verbesserte Touch-Feedback */
    @media (hover: none) {
      button:active,
      a:active {
        transform: scale(0.97);
        transition: transform 0.1s ease-out;
      }
    }
  </style>

  <script>
    /**
     * Hochoptimierter Playlist-Manager
     *
     * Diese Skript verwaltet die interaktive Funktionalität der Playlist-Seite mit
     * verbesserten Algorithmen für Suche, DOM-Manipulation und Zugänglichkeit:
     * - Erweiterte Suchlogik mit Fuzzy-Matching und Relevanz-Scoring
     * - Optimiertes Debouncing mit cancelierbaren Promises
     * - Effiziente DOM-Updates mit DocumentFragment und virtuelles Scrolling
     * - Verbesserte Zugänglichkeit mit präzisen ARIA-Ankündigungen und Keyboard-Shortcuts
     */
    document.addEventListener("DOMContentLoaded", function () {
      // DOM-Elemente cachen für bessere Performance
      const searchInput = document.getElementById("playlist-search") as HTMLInputElement;
      const playlistGrid = document.getElementById("playlist-grid");
      const playlistCards = document.querySelectorAll(".playlist-card");
      const noResultsElement = document.getElementById("no-results");
      const searchStatusElement = document.getElementById("search-results-status");
      const resetSearchButton = document.getElementById("reset-search");
      const backToTopButton = document.getElementById("back-to-top");

      // Konfigurationswerte
      const DEBOUNCE_DELAY = 250; // ms
      const MIN_SEARCH_LENGTH = 2; // Mindestzeichenanzahl für Suche
      const VIRTUAL_SCROLL_THRESHOLD = 50; // Ab dieser Anzahl von Elementen virtuelles Scrolling aktivieren
      const FUZZY_MATCH_THRESHOLD = 0.6; // Schwellenwert für Fuzzy-Matching (0-1)
      const TOUCH_FEEDBACK_DURATION = 300; // ms
      const REDUCED_MOTION = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      const IS_TOUCH_DEVICE = window.matchMedia("(hover: none)").matches;

      // Optimierungsvariablen
      let currentSearchOperation: { cancel: () => void } | null = null;
      let isSearching = false;
      let lastSearchTerm = "";
      let lastVisibleCount = playlistCards.length;
      let searchIndex: Array<{
        element: Element;
        searchable: string;
        decade: string;
        index: number;
        tokens: string[];
      }> = [];

      // Erstelle optimierten Suchindex
      function buildSearchIndex() {
        searchIndex = Array.from(playlistCards).map((card) => {
          const searchable = (card.getAttribute("data-searchable") || "").toLowerCase();
          const decade = card.getAttribute("data-decade") || "";
          const index = parseInt(card.getAttribute("data-index") || "0", 10);
          // Tokenisiere den Suchtext für bessere Suche
          const tokens = searchable.split(/\s+/).filter((token) => token.length > 1);

          return { element: card, searchable, decade, index, tokens };
        });
      }

      // Initialisiere den Suchindex
      buildSearchIndex();

      /**
       * Fügt Progressive Loading-Animationen zu Playlist-Karten hinzu
       */
      function initProgressiveLoading() {
        // Erstelle einen Intersection Observer für Progressive Loading
        const cardObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                const card = entry.target as HTMLElement;

                // Verzögere die Animation leicht für einen Kaskaden-Effekt
                setTimeout(
                  () => {
                    card.classList.add("animate-fadeIn");

                    // Entferne Loading-Shimmer, wenn vorhanden
                    const shimmerElements = card.querySelectorAll(".loading-shimmer");
                    shimmerElements.forEach((el) => {
                      (el as HTMLElement).classList.remove("loading-shimmer");
                    });
                  },
                  parseInt(card.dataset.index || "0") * 50
                );

                cardObserver.unobserve(card);
              }
            });
          },
          {
            rootMargin: "100px",
            threshold: 0.1,
          }
        );

        // Füge Loading-Shimmer zu Bildern hinzu und beobachte Karten
        playlistCards.forEach((card) => {
          // Füge initial Loading-Shimmer hinzu
          const imageContainer = card.querySelector(".aspect-video");
          if (imageContainer && !REDUCED_MOTION) {
            imageContainer.classList.add("loading-shimmer");
          }

          // Beobachte für Intersection
          cardObserver.observe(card);
        });

        // Cleanup beim Verlassen der Seite
        document.addEventListener("astro:before-swap", () => {
          cardObserver.disconnect();
        });
      }

      // Initialisiere Progressive Loading
      initProgressiveLoading();

      /**
       * Fügt Touch-spezifische Feedback-Effekte hinzu
       */
      function initTouchFeedback() {
        if (!IS_TOUCH_DEVICE) {
          return;
        }

        // Füge Touch-Feedback für alle interaktiven Elemente hinzu
        const interactiveElements = document.querySelectorAll('button, a, input[type="search"]');

        interactiveElements.forEach((el) => {
          el.addEventListener(
            "touchstart",
            () => {
              if (REDUCED_MOTION) {
                return;
              }

              (el as HTMLElement).style.transition =
                `transform ${TOUCH_FEEDBACK_DURATION}ms cubic-bezier(0.19, 1, 0.22, 1)`;
              (el as HTMLElement).style.transform = "scale(0.97)";

              // Haptisches Feedback, wenn verfügbar
              if ("vibrate" in navigator) {
                try {
                  navigator.vibrate(10);
                } catch (e) {
                  // Ignoriere Fehler, falls Vibration nicht unterstützt wird
                }
              }
            },
            { passive: true }
          );

          el.addEventListener(
            "touchend",
            () => {
              if (REDUCED_MOTION) {
                return;
              }
              (el as HTMLElement).style.transform = "";
            },
            { passive: true }
          );

          el.addEventListener(
            "touchcancel",
            () => {
              if (REDUCED_MOTION) {
                return;
              }
              (el as HTMLElement).style.transform = "";
            },
            { passive: true }
          );
        });
      }

      // Initialisiere Touch-Feedback
      initTouchFeedback();

      /**
       * Verbesserte Debounce-Funktion mit Promise und Abbruchmöglichkeit
       * @param {Function} func - Zu debouncende Funktion
       * @param {number} delay - Verzögerung in Millisekunden
       * @returns {Function} Debounced Funktion mit Abbruchmöglichkeit
       */
      function debouncedPromise<T>(func: (...args: any[]) => Promise<T>, delay: number) {
        let timeoutId: number | null = null;
        let isCanceled = false;

        return {
          execute: (...args: any[]): Promise<T> => {
            return new Promise((resolve, reject) => {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }

              isCanceled = false;

              timeoutId = window.setTimeout(() => {
                if (isCanceled) {
                  reject(new Error("Operation cancelled"));
                  return;
                }

                func(...args)
                  .then(resolve)
                  .catch(reject)
                  .finally(() => {
                    timeoutId = null;
                  });
              }, delay);
            });
          },
          cancel: () => {
            if (timeoutId) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            isCanceled = true;
          },
        };
      }

      /**
       * Berechnet die Levenshtein-Distanz zwischen zwei Strings
       * für Fuzzy-Matching
       */
      function levenshteinDistance(a: string, b: string): number {
        if (a.length === 0) {
          return b.length;
        }
        if (b.length === 0) {
          return a.length;
        }

        const matrix = Array(a.length + 1)
          .fill(null)
          .map(() => Array(b.length + 1).fill(null));

        for (let i = 0; i <= a.length; i++) {
          matrix[i][0] = i;
        }
        for (let j = 0; j <= b.length; j++) {
          matrix[0][j] = j;
        }

        for (let i = 1; i <= a.length; i++) {
          for (let j = 1; j <= b.length; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
              matrix[i - 1][j] + 1, // Löschen
              matrix[i][j - 1] + 1, // Einfügen
              matrix[i - 1][j - 1] + cost // Ersetzen
            );
          }
        }

        return matrix[a.length][b.length];
      }

      /**
       * Berechnet die Ähnlichkeit zwischen zwei Strings (0-1)
       */
      function stringSimilarity(a: string, b: string): number {
        if (!a || !b) {
          return 0;
        }
        const maxLength = Math.max(a.length, b.length);
        if (maxLength === 0) {
          return 1;
        }
        const distance = levenshteinDistance(a, b);
        return 1 - distance / maxLength;
      }

      /**
       * Prüft, ob ein String einen anderen mit Fuzzy-Matching enthält
       */
      function fuzzyIncludes(
        text: string,
        query: string,
        threshold = FUZZY_MATCH_THRESHOLD
      ): boolean {
        if (!query) {
          return true;
        }
        if (!text) {
          return false;
        }

        // Exakte Übereinstimmung hat Priorität
        if (text.includes(query)) {
          return true;
        }

        // Für kurze Queries prüfen wir Token für Token
        if (query.length <= 3) {
          const tokens = text.split(/\s+/);
          return tokens.some((token) => stringSimilarity(token, query) >= threshold);
        }

        // Für längere Queries prüfen wir Teilstrings
        for (let i = 0; i <= text.length - query.length; i++) {
          const substring = text.substr(i, query.length + 2); // Etwas mehr für Fuzzy-Matching
          if (stringSimilarity(substring, query) >= threshold) {
            return true;
          }
        }

        return false;
      }

      /**
       * Berechnet einen Relevanz-Score für Suchergebnisse
       */
      function calculateRelevance(item: (typeof searchIndex)[0], searchTerm: string): number {
        if (!searchTerm) {
          return 1;
        }

        // Exakte Übereinstimmung hat höchste Priorität
        if (item.searchable.includes(searchTerm)) {
          return 2;
        }

        // Prüfe Token-Übereinstimmungen
        const tokenMatches = item.tokens.filter((token) => fuzzyIncludes(token, searchTerm)).length;

        if (tokenMatches > 0) {
          return 1 + tokenMatches / item.tokens.length;
        }

        // Fuzzy-Matching als Fallback
        return fuzzyIncludes(item.searchable, searchTerm) ? 0.7 : 0;
      }

      /**
       * Filtert Playlists basierend auf Sucheingabe mit optimierter Performance
       * Verwendet DocumentFragment für Batch-DOM-Updates
       */
      async function filterPlaylists(): Promise<number> {
        if (!searchInput || isSearching) {
          return lastVisibleCount;
        }

        isSearching = true;
        const searchTerm = searchInput.value.toLowerCase().trim();

        // Überspringe Suche bei zu kurzen Suchbegriffen
        if (searchTerm.length > 0 && searchTerm.length < MIN_SEARCH_LENGTH) {
          isSearching = false;
          return lastVisibleCount;
        }

        // Überspringe, wenn sich nichts geändert hat
        if (searchTerm === lastSearchTerm) {
          isSearching = false;
          return lastVisibleCount;
        }

        lastSearchTerm = searchTerm;

        // Verwende DocumentFragment für Batch-DOM-Updates
        return new Promise((resolve) => {
          // Verwende requestAnimationFrame für flüssige UI-Updates
          requestAnimationFrame(() => {
            let visibleCount = 0;
            const totalCount = searchIndex.length;

            // Für große Listen: Virtuelles Rendering vorbereiten
            const useVirtualScroll = totalCount > VIRTUAL_SCROLL_THRESHOLD;
            const fragment = useVirtualScroll ? document.createDocumentFragment() : null;

            // Filtere und sortiere nach Relevanz
            const filteredItems = searchIndex
              .map((item) => {
                const relevance = calculateRelevance(item, searchTerm);
                return { item, relevance };
              })
              .filter(({ relevance }) => relevance > 0)
              .sort((a, b) => b.relevance - a.relevance);

            // Verstecke alle Elemente zuerst (verhindert Layout-Thrashing)
            if (!useVirtualScroll) {
              searchIndex.forEach(({ element }) => {
                (element as HTMLElement).classList.add("hidden");
              });
            }

            // Zeige relevante Elemente
            filteredItems.forEach(({ item }) => {
              if (useVirtualScroll && fragment) {
                // Bei virtuellem Scrolling: Füge zum Fragment hinzu
                fragment.appendChild(item.element.cloneNode(true));
              } else {
                // Normaler Modus: Zeige Element
                (item.element as HTMLElement).classList.remove("hidden");
              }
              visibleCount++;
            });

            // Bei virtuellem Scrolling: Ersetze Grid-Inhalt mit Fragment
            if (useVirtualScroll && fragment && playlistGrid) {
              // Speichere Scroll-Position
              const scrollTop = window.scrollY;

              // Leere Grid und füge Fragment hinzu
              playlistGrid.innerHTML = "";
              playlistGrid.appendChild(fragment);

              // Stelle Scroll-Position wieder her
              window.scrollTo(0, scrollTop);
            }

            // Zeige/verstecke "Keine Ergebnisse"-Nachricht
            if (noResultsElement) {
              noResultsElement.classList.toggle("hidden", visibleCount > 0);
            }

            // Aktualisiere ARIA-Live-Region mit präzisen Informationen
            if (searchStatusElement) {
              if (searchTerm && visibleCount > 0) {
                searchStatusElement.textContent = `${visibleCount} von ${totalCount} Playlists gefunden für "${searchTerm}"`;
              } else if (searchTerm && visibleCount === 0) {
                searchStatusElement.textContent = `Keine Playlists gefunden für "${searchTerm}". Versuchen Sie einen anderen Suchbegriff.`;
              } else {
                searchStatusElement.textContent = `Alle ${totalCount} Playlists werden angezeigt`;
              }
            }

            lastVisibleCount = visibleCount;
            isSearching = false;
            resolve(visibleCount);
          });
        });
      }

      // Erstelle debounced Suchfunktion mit Abbruchmöglichkeit
      const debouncedSearch = debouncedPromise(filterPlaylists, DEBOUNCE_DELAY);

      // Event-Listener für Suche mit optimiertem Debouncing
      if (searchInput) {
        searchInput.addEventListener("input", function () {
          // Breche vorherige Suche ab, wenn eine neue beginnt
          if (currentSearchOperation) {
            currentSearchOperation.cancel();
          }

          // Starte neue Suche
          currentSearchOperation = debouncedSearch;
          debouncedSearch.execute().catch((err) => {
            if (err.message !== "Operation cancelled") {
              console.error("Fehler bei der Suche:", err);
            }
          });
        });

        // Keyboard-Events für Zugänglichkeit
        searchInput.addEventListener("keydown", function (e) {
          if (e.key === "Escape") {
            searchInput.value = "";
            filterPlaylists();
          }
        });

        // Touch-spezifische Optimierungen
        if (IS_TOUCH_DEVICE) {
          // Optimiere für mobile Keyboards
          searchInput.addEventListener("focus", function () {
            // Scrolle zum Suchfeld, wenn es fokussiert wird
            setTimeout(() => {
              searchInput.scrollIntoView({
                behavior: REDUCED_MOTION ? "auto" : "smooth",
                block: "center",
              });
            }, 100);
          });
        }
      }

      // Zurücksetzen der Suche und Filter
      if (resetSearchButton) {
        resetSearchButton.addEventListener("click", function () {
          if (searchInput) {
            searchInput.value = "";
          }
          filterPlaylists();

          // Ankündigung für Screen-Reader
          if (searchStatusElement) {
            searchStatusElement.textContent = "Suchfilter wurden zurückgesetzt";
          }

          // Fokus zurück zum Sucheingabefeld für bessere Keyboard-UX
          searchInput?.focus();

          // Haptisches Feedback, wenn verfügbar
          if (IS_TOUCH_DEVICE && "vibrate" in navigator) {
            try {
              navigator.vibrate(15);
            } catch (e) {
              // Ignoriere Fehler, falls Vibration nicht unterstützt wird
            }
          }
        });
      }

      // "Zurück nach oben"-Button mit IntersectionObserver für Performance
      if (backToTopButton) {
        const observer = new IntersectionObserver(
          ([entry]) => {
            backToTopButton.classList.toggle("visible", !entry.isIntersecting);
          },
          { threshold: 0, rootMargin: "-200px 0px 0px 0px" }
        );

        // Beobachte den Seitenkopf, um Button ein-/auszublenden
        const pageHeader = document.querySelector("h1");
        if (pageHeader) {
          observer.observe(pageHeader);
        }

        backToTopButton.addEventListener("click", function () {
          // Verwende scrollIntoView mit behavior: smooth für bessere Performance als scrollTo
          document.body.scrollIntoView({
            behavior: REDUCED_MOTION ? "auto" : "smooth",
            block: "start",
          });

          // Ankündigung für Screen-Reader
          if (searchStatusElement) {
            searchStatusElement.textContent = "Zum Seitenanfang gescrollt";
          }

          // Haptisches Feedback, wenn verfügbar
          if (IS_TOUCH_DEVICE && "vibrate" in navigator) {
            try {
              navigator.vibrate(15);
            } catch (e) {
              // Ignoriere Fehler, falls Vibration nicht unterstützt wird
            }
          }
        });

        // Stelle sicher, dass Tastaturbenutzer nach "Zurück nach oben" zum Hauptinhalt gelangen können
        backToTopButton.addEventListener("keydown", function (e) {
          if (e.key === "Tab" && !e.shiftKey) {
            searchInput?.focus();
            e.preventDefault();
          }
        });
      }

      /**
       * Optimiert Scrolling-Performance durch passive Event-Listener
       * und content-visibility
       */
      function optimizeScrollingPerformance() {
        // Verwende passive Event-Listener für Touch-Events
        const scrollOptions = { passive: true };

        document.addEventListener("touchstart", () => {}, scrollOptions);
        document.addEventListener("touchmove", () => {}, scrollOptions);
        document.addEventListener("touchend", () => {}, scrollOptions);

        // Optimiere content-visibility beim Scrollen
        if ("contentVisibility" in document.documentElement.style) {
          let scrollTimeout: number;
          let lastScrollY = window.scrollY;
          let ticking = false;

          window.addEventListener(
            "scroll",
            () => {
              lastScrollY = window.scrollY;

              if (!ticking) {
                window.requestAnimationFrame(() => {
                  // Optimiere nur, wenn wir schnell scrollen
                  const isRapidScrolling = Math.abs(lastScrollY - window.scrollY) > 50;

                  if (isRapidScrolling && playlistGrid) {
                    // Während schnellem Scrollen: Reduziere Rendering-Last
                    playlistGrid.style.contentVisibility = "auto";

                    if (scrollTimeout) {
                      clearTimeout(scrollTimeout);
                    }

                    scrollTimeout = window.setTimeout(() => {
                      // Stelle content-visibility nach dem Scrollen wieder her
                      if (playlistGrid) {
                        playlistGrid.style.contentVisibility = "";
                      }
                    }, 150);
                  }

                  ticking = false;
                });

                ticking = true;
              }
            },
            { passive: true }
          );
        }

        // Optimiere Bilder basierend auf Verbindungsqualität
        const connection = (navigator as any).connection;
        const isSlowConnection =
          connection &&
          (connection.saveData ||
            connection.effectiveType === "slow-2g" ||
            connection.effectiveType === "2g" ||
            connection.downlink < 0.5);

        if (isSlowConnection) {
          // Reduziere Bildqualität bei langsamen Verbindungen
          document.querySelectorAll("img").forEach((img) => {
            if (!img.getAttribute("loading")) {
              img.setAttribute("loading", "lazy");
            }
            if (img.getAttribute("fetchpriority") !== "high") {
              img.setAttribute("fetchpriority", "low");
            }
          });
        }
      }

      // Initialisiere Scrolling-Optimierungen
      optimizeScrollingPerformance();

      /**
       * Verbessert die Accessibility durch erweiterte ARIA-Unterstützung
       */
      function enhanceAccessibility() {
        // Verbessere ARIA-Labels für Screen Reader
        playlistCards.forEach((card, index) => {
          const cardElement = card as HTMLElement;
          const headline = cardElement.querySelector("h2")?.textContent || `Playlist ${index + 1}`;
          const streamingLinks = cardElement.querySelectorAll("a[href]");

          // Füge zusätzliche ARIA-Beschreibungen hinzu
          streamingLinks.forEach((link) => {
            const serviceName = link.querySelector("span")?.textContent || "Streaming-Dienst";
            (link as HTMLElement).setAttribute(
              "aria-roledescription",
              `${serviceName} für ${headline}`
            );
          });
        });

        // Verbessere Statusmeldungen für Screen Reader
        if (searchStatusElement) {
          // Stelle sicher, dass Statusmeldungen korrekt angekündigt werden
          searchStatusElement.setAttribute("aria-live", "polite");
          searchStatusElement.setAttribute("aria-atomic", "true");
        }

        // Füge verbesserte Skip-Links für Tastaturbenutzer hinzu
        const skipLink = document.createElement("a");
        skipLink.href = "#skip-link-target";
        skipLink.className =
          "sr-only focus:not-sr-only focus:fixed focus:top-4 focus:left-4 focus:z-50 focus:p-4 focus:bg-purple-600 focus:text-white focus:rounded-lg focus:font-bold focus:text-lg focus:shadow-lg";
        skipLink.textContent = "Zum Hauptinhalt springen";
        skipLink.setAttribute("tabindex", "0");
        skipLink.setAttribute("aria-label", "Zum Hauptinhalt springen, Umgeht die Navigation");
        document.body.insertBefore(skipLink, document.body.firstChild);

        // Füge zusätzlichen Skip-Link für Suche hinzu
        const searchSkipLink = document.createElement("a");
        searchSkipLink.href = "#playlist-search";
        searchSkipLink.className =
          "sr-only focus:not-sr-only focus:fixed focus:top-4 focus:left-64 focus:z-50 focus:p-4 focus:bg-purple-600 focus:text-white focus:rounded-lg focus:font-bold focus:text-lg focus:shadow-lg";
        searchSkipLink.textContent = "Zur Suche springen";
        searchSkipLink.setAttribute("tabindex", "0");
        searchSkipLink.setAttribute("aria-label", "Direkt zur Playlist-Suche springen");
        document.body.insertBefore(searchSkipLink, skipLink.nextSibling);

        // Verbessere Fokus-Management
        document.addEventListener("keydown", (e) => {
          // Verbessere Tab-Navigation
          if (e.key === "Tab") {
            document.body.classList.add("user-is-tabbing");
          }
        });

        // Entferne Klasse, wenn Maus verwendet wird
        document.addEventListener("mousedown", () => {
          document.body.classList.remove("user-is-tabbing");
        });
      }

      // Initialisiere erweiterte Accessibility
      enhanceAccessibility();

      // Initialisiere den Filter beim Laden der Seite
      filterPlaylists();

      /**
       * Erweiterte Keyboard-Navigation mit WCAG AAA Konformität
       * - Verbesserte Tastaturkürzel für Screenreader-Kompatibilität
       * - Zusätzliche Shortcuts für verbesserte Zugänglichkeit
       * - Dokumentierte Tastaturkürzel für Benutzer
       */
      function enhanceKeyboardNavigation() {
        // Erstelle ein verstecktes Element für Screenreader, das Tastaturkürzel erklärt
        const keyboardHelpElement = document.createElement("div");
        keyboardHelpElement.id = "keyboard-shortcuts-help";
        keyboardHelpElement.className = "sr-only";
        keyboardHelpElement.setAttribute("aria-live", "polite");
        keyboardHelpElement.innerHTML = `
          <h2>Tastaturkürzel für diese Seite:</h2>
          <ul>
            <li>Taste / (Schrägstrich): Suchfeld fokussieren</li>
            <li>Alt + R: Suchfilter zurücksetzen</li>
            <li>Alt + T: Zum Seitenanfang scrollen</li>
            <li>Alt + P: Erste Playlist fokussieren</li>
            <li>Escape: Suchfeld leeren</li>
          </ul>
        `;
        document.body.appendChild(keyboardHelpElement);

        // Füge Tastaturkürzel-Listener hinzu
        document.addEventListener("keydown", function (e) {
          // '/' drücken, um Suche zu fokussieren
          if (e.key === "/" && document.activeElement?.tagName !== "INPUT") {
            e.preventDefault();
            searchInput?.focus();

            // Ankündigung für Screenreader
            if (searchStatusElement) {
              searchStatusElement.textContent =
                "Suchfeld fokussiert. Geben Sie Ihren Suchbegriff ein.";
            }
          }

          // 'Alt+R' drücken, um Suche zurückzusetzen
          if (e.key === "r" && e.altKey) {
            e.preventDefault();
            if (searchInput) {
              searchInput.value = "";
            }
            filterPlaylists();
            searchInput?.focus();

            // Ankündigung für Screenreader
            if (searchStatusElement) {
              searchStatusElement.textContent = "Suchfilter wurden zurückgesetzt.";
            }
          }

          // 'Alt+T' drücken, um zum Seitenanfang zu scrollen
          if (e.key === "t" && e.altKey) {
            e.preventDefault();
            document.body.scrollIntoView({
              behavior: REDUCED_MOTION ? "auto" : "smooth",
              block: "start",
            });

            // Ankündigung für Screenreader
            if (searchStatusElement) {
              searchStatusElement.textContent = "Zum Seitenanfang gescrollt.";
            }
          }

          // 'Alt+P' drücken, um erste Playlist zu fokussieren
          if (e.key === "p" && e.altKey) {
            e.preventDefault();
            const firstPlaylistLink = document.querySelector(".playlist-card a");
            if (firstPlaylistLink) {
              (firstPlaylistLink as HTMLElement).focus();

              // Ankündigung für Screenreader
              if (searchStatusElement) {
                searchStatusElement.textContent =
                  "Erste Playlist fokussiert. Verwenden Sie Tab, um durch die Playlists zu navigieren.";
              }
            }
          }

          // 'Alt+H' drücken, um Tastaturkürzel anzuzeigen/anzukündigen
          if (e.key === "h" && e.altKey) {
            e.preventDefault();

            // Ankündigung für Screenreader
            if (searchStatusElement) {
              searchStatusElement.textContent =
                "Tastaturkürzel: / für Suche, Alt+R zum Zurücksetzen, Alt+T für Seitenanfang, Alt+P für erste Playlist, Escape zum Leeren des Suchfelds.";
            }
          }
        });
      }

      // Initialisiere erweiterte Tastaturnavigation
      enhanceKeyboardNavigation();
    });
  </script>
</Layout>
