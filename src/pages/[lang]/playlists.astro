---
import Layout from "@layouts/Layout.astro";
import { useTranslations } from "@utils/i18n";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import PlaylistCard from "@components/PlaylistCard.astro";
import { Icon } from "astro-icon/components";
import { extractKeywords, generateMetaDescription } from "@utils/seo";
import { Picture } from "astro:assets";

/**
 * Enable static site generation for all supported languages.
 * This ensures the playlist pages are pre-rendered at build time for optimal performance.
 * @see https://docs.astro.build/en/reference/directives-reference/#prerender
 */
export const prerender = true;

/**
 * Define supported languages and generate static paths for each language.
 * This creates separate routes for each language version of the playlist page.
 * @returns {Array} Array of route objects with params and props
 */
export async function getStaticPaths() {
  // Define all languages supported by the application
  const supportedLanguages = [
    "de",
    "en",
    "es",
    "fr",
    "it",
    "pt",
    "da",
    "nl",
    "sv",
    "fi",
  ] as const;

  // Optimierte parallele Datenaufrufe mit Promise.all
  // Lädt alle Sprachdateien gleichzeitig und verarbeitet sie parallel
  const allLanguageDataPromises = supportedLanguages.map(async (lang) => {
    // Versuche, Playlist-Daten für die spezifische Sprache zu laden
    try {
      // Dynamischer Import mit Promise.all für parallele Verarbeitung
      const playlistData = await import(
        `../../../public/json/playlist/${lang}_playlist.json`
      );
      return { lang, playlists: playlistData.default };
    } catch (error) {
      // Fallback zu Englisch, wenn die Sprachdatei nicht existiert
      try {
        console.info(
          `No playlist data found for ${lang}, falling back to English`,
        );
        const fallbackData = await import(
          `../../../public/json/playlist/en_playlist.json`
        );
        return { lang, playlists: fallbackData.default };
      } catch (fallbackError) {
        console.error(
          `Error loading playlist data for ${lang}:`,
          fallbackError,
        );
        return { lang, playlists: [] };
      }
    }
  });

  // Warte auf alle Datenaufrufe und erstelle die Pfade
  const languageData = await Promise.all(allLanguageDataPromises);
  
  // Transformiere die Daten in das erwartete Format
  const paths = languageData.map(({ lang, playlists }) => ({
    params: { lang },
    props: { lang, playlists },
  }));

  return paths;
}

/**
 * Type definition for component props
 */
interface Props {
  lang: "de" | "en" | "es" | "fr" | "it" | "pt" | "da" | "nl" | "sv" | "fi";
  playlists: PlaylistData[];
}

/**
 * Type definition for playlist objects
 */
interface PlaylistData {
  headline: string;
  imageUrl: string;
  introSubline: string;
  spotifyPlaylist?: string;
  deezerPlaylist?: string;
  appleMusicPlaylist?: string;
}

// Extract data from props with default empty array for playlists
const { lang, playlists = [] } = Astro.props;

// Use the i18n utilities for translations
const t = useTranslations(lang);

// Generate SEO content
const title = t("playlist.page.title");
const description = t("playlist.page.description");

// Enhanced SEO content using utility functions
const pageContent = `${title} ${description} ${playlists.map((p) => `${p.headline} ${p.introSubline}`).join(" ")}`;

// Generate optimized meta description and keywords
const optimizedDescription = generateMetaDescription(pageContent);
const keywords = extractKeywords(pageContent) || t("meta.keywords");

// Additional structured data parameters for SEO
const pageType = "website";
const publishDate = new Date("2024-01-01");
const modifiedDate = new Date();

// Sort playlists chronologically (assuming decade in headline format like "1950s")
const sortedPlaylists = [...playlists].sort((a, b) =>
  a.imageUrl.localeCompare(b.imageUrl, undefined, { sensitivity: "base" }),
);
---

<Layout
  title={title}
  description={optimizedDescription}
  keywords={keywords}
  image={`/og-images/social-share-playlist-${lang}.jpg`}
  type={pageType}
  publishDate={publishDate}
  modifiedDate={modifiedDate}
>
  <main class="max-w-6xl mx-auto px-4 py-8">
    <!-- Page heading and description -->
    <div class="text-center mb-12">
      <Headline
        title={t("playlist.page.heading")}
        level="h1"
        className="text-white font-bold text-3xl md:text-4xl mb-4"
      />
      <div class="h-1 w-24 bg-purple-500 rounded-full mx-auto mt-2 mb-6"></div>
      <Paragraph
        description={t("playlist.page.description")}
        className="max-w-2xl mx-auto text-zinc-100"
      />
    </div>

    <!-- Search and filter section -->
    <div
      class="search-filter-container bg-zinc-800/90 rounded-xl p-6 border border-zinc-700 shadow-lg mb-10"
      role="search"
      aria-labelledby="search-heading"
    >
      <h2 id="search-heading" class="sr-only">
        {t("playlist.search.label")}
      </h2>

      <div class="flex flex-col md:flex-row gap-4 mb-6">
        <!-- Search field -->
        <div class="relative flex-grow">
          <label for="playlist-search" class="sr-only">
            {t("playlist.search.placeholder")}
          </label>
          <div class="relative">
            <div
              class="absolute inset-y-0 left-3 flex items-center pointer-events-none"
              aria-hidden="true"
            >
              <Icon name="search" class="h-5 w-5 text-purple-400" />
            </div>
            <input
              type="search"
              id="playlist-search"
              placeholder={t("playlist.search.placeholder")}
              class="w-full py-3 pl-10 pr-4 bg-zinc-800 border-2 border-zinc-600
                    rounded-xl text-zinc-50 placeholder-zinc-400
                    focus:outline-none focus:border-purple-500 focus:ring-3
                    focus:ring-purple-500/50 transition-all duration-300"
              aria-controls="playlist-grid"
              aria-describedby="search-playlist-description"
            />
            <div id="search-playlist-description" class="sr-only">
              {
                t("playlist.search.live.description") ||
                  "Results are filtered automatically as you type"
              }
            </div>
          </div>
        </div>
      </div>

      <!-- Search status for screen readers -->
      <div
        id="search-results-status"
        class="sr-only"
        aria-live="polite"
        aria-atomic="true"
        role="status"
      >
      </div>

      <!-- No results message (initially hidden) -->
      <div
        id="no-results"
        class="hidden flex flex-col items-center justify-center p-12 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl border border-zinc-600 text-center shadow-md mb-10"
        aria-live="polite"
        role="status"
      >
        <Icon
          name="search-no-results"
          class="w-16 h-16 text-zinc-300 mb-4"
          aria-hidden="true"
        />
        <h2 class="text-zinc-100 text-xl font-medium mb-2">
          {t("playlist.no.results.heading") || "No playlists found"}
        </h2>
        <p class="text-zinc-300 mb-4">
          {t("playlist.no.results")}
        </p>
        <button
          id="reset-search"
          class="mt-2 px-6 py-3 bg-purple-700 hover:bg-purple-600 text-white rounded-lg
                 min-h-[44px] min-w-[120px] font-medium
                 focus:outline-none focus:ring-4 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800
                 transition-all duration-300"
          aria-label={t("playlist.reset.search.button") ||
            "Reset search filters"}
        >
          {t("playlist.reset.search") || "Reset search"}
        </button>
      </div>

      <!-- Playlist Grid -->
      <ul
        id="playlist-grid"
        class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-8"
        aria-label={t("playlist.page.heading")}
      >
        {
          sortedPlaylists.map((playlist, index) => (
            <PlaylistCard
              headline={playlist.headline}
              imageUrl={playlist.imageUrl}
              introSubline={playlist.introSubline}
              spotifyPlaylist={playlist.spotifyPlaylist}
              deezerPlaylist={playlist.deezerPlaylist}
              appleMusicPlaylist={playlist.appleMusicPlaylist}
              index={index}
              lang={lang}
            />
          ))
        }
      </ul>

      <!-- Back to top button -->
      <button
        id="back-to-top"
        class="fixed bottom-8 right-8 p-4 bg-purple-700 text-white rounded-full shadow-lg opacity-0 invisible
               transition-all duration-300 hover:bg-purple-600
               min-w-[48px] min-h-[48px] flex items-center justify-center
               focus:outline-none focus:ring-4 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800"
        aria-label={t("back.to.top") || "Back to top of page"}
      >
        <Icon name="arrow-up" class="h-6 w-6" aria-hidden="true" />
      </button>
    </div>
  </main>

  <style>
    /* Improved color contrast for WCAG AAA (7:1) */
    :root {
      --text-primary: #ffffff; /* Maximum contrast */
      --text-secondary: #e2e2e7; /* Higher contrast than standard zinc-300 */
      --bg-card: #27272a; /* zinc-800 */
      --border-card: rgba(161, 161, 170, 0.3); /* zinc-400 with transparency */
      --accent-primary: #9333ea; /* purple-600 - darker for better contrast */
      --accent-secondary: #a855f7; /* purple-500 */
    }

    /* Improved focus states for keyboard navigation */
    :focus-visible {
      outline: 3px solid var(--accent-primary);
      outline-offset: 3px;
    }

    /* Animations for cards */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-fadeIn {
      animation: fadeIn 0.5s ease-out forwards;
      opacity: 0;
    }

    /* Improved back-to-top button animation */
    #back-to-top.visible {
      opacity: 1;
      visibility: visible;
    }

    /* Disable animations if user prefers reduced motion */
    @media (prefers-reduced-motion: reduce) {
      *,
      ::before,
      ::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }

      .animate-fadeIn {
        opacity: 1;
        animation: none;
        transform: translateY(0);
      }

      .playlist-card:hover {
        transform: none !important;
        box-shadow: none !important;
      }

      html {
        scroll-behavior: auto !important;
      }
    }
  </style>

  <script>
    /**
     * Hochoptimierter Playlist-Manager
     *
     * Diese Skript verwaltet die interaktive Funktionalität der Playlist-Seite mit
     * verbesserten Algorithmen für Suche, DOM-Manipulation und Zugänglichkeit:
     * - Erweiterte Suchlogik mit Fuzzy-Matching und Relevanz-Scoring
     * - Optimiertes Debouncing mit cancelierbaren Promises
     * - Effiziente DOM-Updates mit DocumentFragment und virtuelles Scrolling
     * - Verbesserte Zugänglichkeit mit präzisen ARIA-Ankündigungen und Keyboard-Shortcuts
     */
    document.addEventListener("DOMContentLoaded", function () {
      // DOM-Elemente cachen für bessere Performance
      const searchInput = document.getElementById(
        "playlist-search"
      ) as HTMLInputElement;
      const playlistGrid = document.getElementById("playlist-grid");
      const playlistCards = document.querySelectorAll(".playlist-card");
      const noResultsElement = document.getElementById("no-results");
      const searchStatusElement = document.getElementById("search-results-status");
      const resetSearchButton = document.getElementById("reset-search");
      const backToTopButton = document.getElementById("back-to-top");

      // Konfigurationswerte
      const DEBOUNCE_DELAY = 250; // ms
      const MIN_SEARCH_LENGTH = 2; // Mindestzeichenanzahl für Suche
      const VIRTUAL_SCROLL_THRESHOLD = 50; // Ab dieser Anzahl von Elementen virtuelles Scrolling aktivieren
      const FUZZY_MATCH_THRESHOLD = 0.6; // Schwellenwert für Fuzzy-Matching (0-1)

      // Optimierungsvariablen
      let currentSearchOperation: { cancel: () => void } | null = null;
      let isSearching = false;
      let lastSearchTerm = "";
      let lastVisibleCount = playlistCards.length;
      let searchIndex: Array<{
        element: Element;
        searchable: string;
        decade: string;
        tokens: string[];
      }> = [];

      // Erstelle optimierten Suchindex
      function buildSearchIndex() {
        searchIndex = Array.from(playlistCards).map(card => {
          const searchable = (card.getAttribute("data-searchable") || "").toLowerCase();
          const decade = card.getAttribute("data-decade") || "";
          // Tokenisiere den Suchtext für bessere Suche
          const tokens = searchable
            .split(/\s+/)
            .filter(token => token.length > 1);
          
          return { element: card, searchable, decade, tokens };
        });
      }

      // Initialisiere den Suchindex
      buildSearchIndex();

      /**
       * Verbesserte Debounce-Funktion mit Promise und Abbruchmöglichkeit
       * @param {Function} func - Zu debouncende Funktion
       * @param {number} delay - Verzögerung in Millisekunden
       * @returns {Function} Debounced Funktion mit Abbruchmöglichkeit
       */
      function debouncedPromise<T>(func: (...args: any[]) => Promise<T>, delay: number) {
        let timeoutId: number | null = null;
        let isCanceled = false;

        return {
          execute: (...args: any[]): Promise<T> => {
            return new Promise((resolve, reject) => {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }

              isCanceled = false;

              timeoutId = window.setTimeout(() => {
                if (isCanceled) {
                  reject(new Error("Operation cancelled"));
                  return;
                }

                func(...args)
                  .then(resolve)
                  .catch(reject)
                  .finally(() => {
                    timeoutId = null;
                  });
              }, delay);
            });
          },
          cancel: () => {
            if (timeoutId) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            isCanceled = true;
          }
        };
      }

      /**
       * Berechnet die Levenshtein-Distanz zwischen zwei Strings
       * für Fuzzy-Matching
       */
      function levenshteinDistance(a: string, b: string): number {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;

        const matrix = Array(a.length + 1).fill(null).map(() =>
          Array(b.length + 1).fill(null)
        );

        for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
        for (let j = 0; j <= b.length; j++) matrix[0][j] = j;

        for (let i = 1; i <= a.length; i++) {
          for (let j = 1; j <= b.length; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
              matrix[i - 1][j] + 1,      // Löschen
              matrix[i][j - 1] + 1,      // Einfügen
              matrix[i - 1][j - 1] + cost // Ersetzen
            );
          }
        }

        return matrix[a.length][b.length];
      }

      /**
       * Berechnet die Ähnlichkeit zwischen zwei Strings (0-1)
       */
      function stringSimilarity(a: string, b: string): number {
        if (!a || !b) return 0;
        const maxLength = Math.max(a.length, b.length);
        if (maxLength === 0) return 1;
        const distance = levenshteinDistance(a, b);
        return 1 - distance / maxLength;
      }

      /**
       * Prüft, ob ein String einen anderen mit Fuzzy-Matching enthält
       */
      function fuzzyIncludes(text: string, query: string, threshold = FUZZY_MATCH_THRESHOLD): boolean {
        if (!query) return true;
        if (!text) return false;
        
        // Exakte Übereinstimmung hat Priorität
        if (text.includes(query)) return true;
        
        // Für kurze Queries prüfen wir Token für Token
        if (query.length <= 3) {
          const tokens = text.split(/\s+/);
          return tokens.some(token => stringSimilarity(token, query) >= threshold);
        }
        
        // Für längere Queries prüfen wir Teilstrings
        for (let i = 0; i <= text.length - query.length; i++) {
          const substring = text.substr(i, query.length + 2); // Etwas mehr für Fuzzy-Matching
          if (stringSimilarity(substring, query) >= threshold) {
            return true;
          }
        }
        
        return false;
      }

      /**
       * Berechnet einen Relevanz-Score für Suchergebnisse
       */
      function calculateRelevance(item: typeof searchIndex[0], searchTerm: string): number {
        if (!searchTerm) return 1;
        
        // Exakte Übereinstimmung hat höchste Priorität
        if (item.searchable.includes(searchTerm)) return 2;
        
        // Prüfe Token-Übereinstimmungen
        const tokenMatches = item.tokens.filter(token =>
          fuzzyIncludes(token, searchTerm)
        ).length;
        
        if (tokenMatches > 0) {
          return 1 + (tokenMatches / item.tokens.length);
        }
        
        // Fuzzy-Matching als Fallback
        return fuzzyIncludes(item.searchable, searchTerm) ? 0.7 : 0;
      }

      /**
       * Filtert Playlists basierend auf Sucheingabe mit optimierter Performance
       * Verwendet DocumentFragment für Batch-DOM-Updates
       */
      async function filterPlaylists(): Promise<number> {
        if (!searchInput || isSearching) return lastVisibleCount;

        isSearching = true;
        const searchTerm = searchInput.value.toLowerCase().trim();

        // Überspringe Suche bei zu kurzen Suchbegriffen
        if (searchTerm.length > 0 && searchTerm.length < MIN_SEARCH_LENGTH) {
          isSearching = false;
          return lastVisibleCount;
        }

        // Überspringe, wenn sich nichts geändert hat
        if (searchTerm === lastSearchTerm) {
          isSearching = false;
          return lastVisibleCount;
        }

        lastSearchTerm = searchTerm;

        // Verwende DocumentFragment für Batch-DOM-Updates
        return new Promise(resolve => {
          // Verwende requestAnimationFrame für flüssige UI-Updates
          requestAnimationFrame(() => {
            let visibleCount = 0;
            const totalCount = searchIndex.length;
            
            // Für große Listen: Virtuelles Rendering vorbereiten
            const useVirtualScroll = totalCount > VIRTUAL_SCROLL_THRESHOLD;
            const fragment = useVirtualScroll ? document.createDocumentFragment() : null;
            
            // Filtere und sortiere nach Relevanz
            const filteredItems = searchIndex
              .map(item => {
                const relevance = calculateRelevance(item, searchTerm);
                return { item, relevance };
              })
              .filter(({ relevance }) => relevance > 0)
              .sort((a, b) => b.relevance - a.relevance);
            
            // Verstecke alle Elemente zuerst (verhindert Layout-Thrashing)
            if (!useVirtualScroll) {
              searchIndex.forEach(({ element }) => {
                (element as HTMLElement).classList.add("hidden");
              });
            }
            
            // Zeige relevante Elemente
            filteredItems.forEach(({ item }) => {
              if (useVirtualScroll && fragment) {
                // Bei virtuellem Scrolling: Füge zum Fragment hinzu
                fragment.appendChild(item.element.cloneNode(true));
              } else {
                // Normaler Modus: Zeige Element
                (item.element as HTMLElement).classList.remove("hidden");
              }
              visibleCount++;
            });
            
            // Bei virtuellem Scrolling: Ersetze Grid-Inhalt mit Fragment
            if (useVirtualScroll && fragment && playlistGrid) {
              // Speichere Scroll-Position
              const scrollTop = window.scrollY;
              
              // Leere Grid und füge Fragment hinzu
              playlistGrid.innerHTML = '';
              playlistGrid.appendChild(fragment);
              
              // Stelle Scroll-Position wieder her
              window.scrollTo(0, scrollTop);
            }
            
            // Zeige/verstecke "Keine Ergebnisse"-Nachricht
            if (noResultsElement) {
              noResultsElement.classList.toggle("hidden", visibleCount > 0);
            }
            
            // Aktualisiere ARIA-Live-Region mit präzisen Informationen
            if (searchStatusElement) {
              if (searchTerm && visibleCount > 0) {
                searchStatusElement.textContent = `${visibleCount} von ${totalCount} Playlists gefunden für "${searchTerm}"`;
              } else if (searchTerm && visibleCount === 0) {
                searchStatusElement.textContent = `Keine Playlists gefunden für "${searchTerm}". Versuchen Sie einen anderen Suchbegriff.`;
              } else {
                searchStatusElement.textContent = `Alle ${totalCount} Playlists werden angezeigt`;
              }
            }
            
            lastVisibleCount = visibleCount;
            isSearching = false;
            resolve(visibleCount);
          });
        });
      }

      // Erstelle debounced Suchfunktion mit Abbruchmöglichkeit
      const debouncedSearch = debouncedPromise(filterPlaylists, DEBOUNCE_DELAY);

      // Event-Listener für Suche mit optimiertem Debouncing
      if (searchInput) {
        searchInput.addEventListener("input", function() {
          // Breche vorherige Suche ab, wenn eine neue beginnt
          if (currentSearchOperation) {
            currentSearchOperation.cancel();
          }
          
          // Starte neue Suche
          currentSearchOperation = debouncedSearch;
          debouncedSearch.execute()
            .catch(err => {
              if (err.message !== "Operation cancelled") {
                console.error("Fehler bei der Suche:", err);
              }
            });
        });

        // Keyboard-Events für Zugänglichkeit
        searchInput.addEventListener("keydown", function(e) {
          if (e.key === "Escape") {
            searchInput.value = "";
            filterPlaylists();
          }
        });
      }

      // Zurücksetzen der Suche und Filter
      if (resetSearchButton) {
        resetSearchButton.addEventListener("click", function() {
          if (searchInput) searchInput.value = "";
          filterPlaylists();
          
          // Ankündigung für Screen-Reader
          if (searchStatusElement) {
            searchStatusElement.textContent = "Suchfilter wurden zurückgesetzt";
          }
          
          // Fokus zurück zum Sucheingabefeld für bessere Keyboard-UX
          searchInput?.focus();
        });
      }

      // "Zurück nach oben"-Button mit IntersectionObserver für Performance
      if (backToTopButton) {
        const observer = new IntersectionObserver(
          ([entry]) => {
            backToTopButton.classList.toggle("visible", !entry.isIntersecting);
          },
          { threshold: 0, rootMargin: "-200px 0px 0px 0px" }
        );
        
        // Beobachte den Seitenkopf, um Button ein-/auszublenden
        const pageHeader = document.querySelector("h1");
        if (pageHeader) observer.observe(pageHeader);
        
        backToTopButton.addEventListener("click", function() {
          // Verwende scrollIntoView mit behavior: smooth für bessere Performance als scrollTo
          document.body.scrollIntoView({
            behavior: "smooth",
            block: "start"
          });
          
          // Ankündigung für Screen-Reader
          if (searchStatusElement) {
            searchStatusElement.textContent = "Zum Seitenanfang gescrollt";
          }
        });
        
        // Stelle sicher, dass Tastaturbenutzer nach "Zurück nach oben" zum Hauptinhalt gelangen können
        backToTopButton.addEventListener("keydown", function(e) {
          if (e.key === "Tab" && !e.shiftKey) {
            searchInput?.focus();
            e.preventDefault();
          }
        });
      }

      // Initialisiere den Filter beim Laden der Seite
      filterPlaylists();

      // Erweiterte Keyboard-Navigation
      document.addEventListener("keydown", function(e) {
        // '/' drücken, um Suche zu fokussieren
        if (e.key === "/" && document.activeElement?.tagName !== "INPUT") {
          e.preventDefault();
          searchInput?.focus();
        }
        
        // 'Alt+R' drücken, um Suche zurückzusetzen
        if (e.key === "r" && e.altKey) {
          e.preventDefault();
          if (searchInput) searchInput.value = "";
          filterPlaylists();
          searchInput?.focus();
        }
        
        // 'Alt+T' drücken, um zum Seitenanfang zu scrollen
        if (e.key === "t" && e.altKey) {
          e.preventDefault();
          document.body.scrollIntoView({
            behavior: "smooth",
            block: "start"
          });
        }
      });
    });
  </script>
</Layout>
