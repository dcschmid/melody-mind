---
import Layout from "@layouts/Layout.astro";
import ShowCoins from "@components/Shared/ShowCoins.astro";
import GameHeadline from "@components/Game/GameHeadline.astro";
import EndOverlay from "@components/Overlays/EndOverlay.astro";
import LoadingSpinner from "@components/Game/LoadingSpinner.astro";
import ErrorMessage from "@components/Shared/ErrorMessage.astro";
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import { Icon } from "astro-icon/components";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
const { category } = Astro.params;

let categories;
try {
  categories = await import(`@json/${lang}_categories.json`);
} catch (error) {
  categories = await import(`@json/de_categories.json`);
}

const currentCategoryData = categories.default.find(
  (cat: any) => cat.slug === category,
);

const user = { id: "guest" };
---

<Layout title="Cover Puzzle" showHeader={false} showCoins={false}>
  <EndOverlay id="endgame-popup" data-score="0" data-category="Cover Puzzle" />
  <ErrorMessage />
  <LoadingSpinner />

  <!-- Tastaturlegende für Barrierefreiheit -->
  <div
    class="keyboard-shortcuts sr-only"
    aria-live="polite"
    id="keyboard-shortcuts"
  >
    <h2>{t("keyboard.shortcuts")}</h2>
    <dl>
      <dt>{t("key.tab")}</dt>
      <dd>{t("keyboard.navigation")}</dd>
      <dt>{t("key.space")}</dt>
      <dd>{t("keyboard.activate")}</dd>
      <dt>{t("key.arrows")}</dt>
      <dd>{t("keyboard.arrows")}</dd>
      <dt>{t("key.numbers")}</dt>
      <dd>{t("keyboard.numbers")}</dd>
      <dt>{t("key.s")}</dt>
      <dd>{t("keyboard.speed")}</dd>
      <dt>{t("key.n")}</dt>
      <dd>{t("keyboard.next")}</dd>
      <dt>{t("key.h")}</dt>
      <dd>{t("keyboard.help")}</dd>
    </dl>
  </div>

  <div class="game-container max-w-4xl mx-auto px-4" aria-live="polite">
    <!-- Verbesserte Bedienleiste mit Zugänglichkeitsfunktionen -->
    <div class="accessibility-controls flex justify-end mb-2">
      <button
        id="show-keyboard-shortcuts"
        class="text-xs bg-zinc-800 hover:bg-zinc-700 text-zinc-300 px-2 py-1 rounded-md flex items-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-zinc-900 focus:ring-purple-500"
        aria-expanded="false"
      >
        <Icon name="keyboard" class="h-4 w-4 mr-1.5" />
        <span>{t("keyboard.shortcuts.show")}</span>
      </button>
    </div>

    <!-- Game instructions -->
    <div
      class="game-instructions mb-6 p-4 bg-zinc-800 border border-zinc-700 rounded-lg text-left"
    >
      <details>
        <summary
          class="cursor-pointer text-zinc-200 font-medium focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-zinc-800 rounded-md p-1"
        >
          <span class="text-purple-400"
            >{t("game.instructions.title") || "Spielanleitung"}</span
          >
        </summary>
        <div class="mt-3 text-zinc-300 text-sm">
          <p>
            {
              t("game.instructions.puzzle") ||
                "Versuche das Album zu erraten, während das Cover nach und nach aufgedeckt wird. Je schneller du richtig rätst, desto mehr Punkte erhältst du."
            }
          </p>
        </div>
      </details>
    </div>

    <!-- Game status area (nur Timer und Speed-Button) -->
    <div
      class="flex flex-col md:flex-row items-center justify-between gap-4 mb-6"
    >
      <div
        class="flex items-center justify-center gap-4 text-xl font-bold"
        aria-live="polite"
      >
        <div class="flex items-center bg-zinc-800 px-4 py-2 rounded-lg">
          <span class="sr-only"
            >{t("game.time.remaining") || "Verbleibende Zeit:"}</span
          >
          <Icon name="clock" class="h-5 w-5 text-purple-400 mr-2" />
          <span class="timer text-zinc-100">60</span>s
        </div>
      </div>
      <div class="flex items-center">
        <Icon name="coins" class="h-5 w-5 text-purple-400 mr-2" />
        <span class="font-bold">{t("game.score") || "Punktestand"}:</span>
        <span class="score-display text-purple-400 font-bold ml-2">0</span>
      </div>
      <div class="flex items-center">
        <Icon name="hashtag" class="h-5 w-5 text-purple-400 mr-2" />
        <span class="font-bold">{t("game.round") || "Runde"}:</span>
        <span class="round text-purple-400 font-bold ml-2">1/10</span>
      </div>
      <div class="game-controls">
        <button
          id="game-speed-toggle"
          class="bg-zinc-800 hover:bg-zinc-700 text-zinc-300 px-3 py-1.5 rounded-md text-sm flex items-center focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-zinc-900"
          aria-pressed="false"
          accesskey="s"
        >
          <Icon name="clock" class="h-4 w-4 mr-1.5" />
          <span>{t("game.slower.speed") || "Langsameres Spiel"}</span>
        </button>
      </div>
    </div>

    <div
      id="question-container"
      class="w-full mx-auto text-center transition-opacity duration-500 opacity-100 data-[hidden=true]:opacity-0"
      role="main"
      aria-label={t("game.area.label")}
      data-userID={user.id}
      data-category={category}
    >
      <div class="max-w-xl mx-auto">
        <div
          id="cover-puzzle"
          class="relative w-full aspect-square mb-6 bg-zinc-900 rounded-lg overflow-hidden shadow-lg border border-zinc-800"
          aria-label={t("game.puzzle.label") || "Album Cover Puzzle"}
          role="img"
        >
          <!-- Puzzle grid will be created by JavaScript -->
          <div class="sr-only" id="puzzle-description" aria-live="polite">
            {t("game.puzzle.loading") || "Puzzle wird geladen..."}
          </div>
        </div>

        <fieldset
          id="options"
          class="grid sm:grid-cols-2 gap-3 mt-6"
          aria-label={t("game.options.label")}
          role="radiogroup"
        >
          <legend class="sr-only"
            >{
              t("game.options.legend") || "Wähle das richtige Album aus"
            }</legend
          >
        </fieldset>

        <div class="mt-6 space-y-4">
          <button
            id="next-round-button"
            class="hidden px-8 py-3 bg-purple-600 hover:bg-purple-500 rounded-lg text-white font-medium transition-colors mx-auto block focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-zinc-900"
            aria-label={t("game.next.round") || "Nächste Runde starten"}
            accesskey="n"
          >
            {t("game.next")}
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Skip to answer button für Tastaturnutzer -->
  <div class="sr-only">
    <button
      id="skip-to-answers"
      class="focus:not-sr-only focus:absolute focus:z-50 focus:p-3 focus:bg-purple-600 focus:text-white focus:left-4 focus:top-32"
    >
      {t("game.skip.to.answers") || "Zu den Antwortmöglichkeiten springen"}
    </button>
  </div>
</Layout>

<script>
  import { ErrorHandler } from "@utils/error/errorHandler";
  import { handleEndGame, restartGame } from "@utils/game/endGameUtils";
  import { getLangFromUrl, useTranslations } from "@utils/i18n";
  import type { Album } from "src/types/game";

  /**
   * Cover Puzzle Game - Main Script
   *
   * This game presents a gradually revealing album cover image.
   * Players must identify the correct album from four options
   * before the entire cover is revealed.
   */

  // Get language and translations
  const lang = getLangFromUrl(
    new URL(window.location.pathname, window.location.origin),
  );
  const t = useTranslations(lang);

  // Game configuration constants
  const TOTAL_ROUNDS = 10; // Total number of rounds to play
  const ROUND_TIME = 60; // Time in seconds per round
  const GRID_SIZE = 8; // Puzzle grid dimensions (8x8)
  const BASE_POINTS = 200; // Base points for correct answers
  const TOTAL_PIECES = GRID_SIZE * GRID_SIZE; // Total puzzle pieces
  const REVEAL_INTERVAL = 850; // Time between piece reveals (ms)
  const PIECE_ANIMATION_DURATION = 300; // Animation time for each piece (ms)
  const LAST_PIECE_BUFFER = 3; // Buffer seconds at the end of round

  // Configuration for accessibility
  let isSlowerSpeed = false; // Toggle for slower game speed
  const SLOWER_SPEED_FACTOR = 1.5; // Factor to slow down piece reveals
  const SLOWER_TIME_BONUS = 15; // Additional seconds when slower speed is activated

  // Calculate how many pieces to reveal per second to complete just before time ends
  const PIECES_PER_SECOND =
    (TOTAL_PIECES - 1) / (ROUND_TIME - LAST_PIECE_BUFFER);

  /**
   * Interface for accessing all game-related DOM elements
   */
  interface GameElements {
    score: HTMLSpanElement;
    round: HTMLSpanElement;
    timer: HTMLSpanElement;
    coverPuzzle: HTMLDivElement;
    options: HTMLFieldSetElement;
    container: HTMLDivElement;
    nextRoundButton: HTMLButtonElement;
    restartButton: HTMLButtonElement;
    loadingSpinner: HTMLElement;
    gameSpeedToggle: HTMLButtonElement;
    puzzleDescription: HTMLDivElement;
    skipToAnswersButton: HTMLButtonElement;
    keyboardShortcutsBtn: HTMLButtonElement;
    keyboardShortcutsPanel: HTMLDivElement;
  }

  /**
   * Cache all game DOM elements for better performance
   */
  function cacheElements(): GameElements {
    return {
      score: document.querySelector(".score-display") as HTMLSpanElement,
      round: document.querySelector(".round") as HTMLSpanElement,
      timer: document.querySelector(".timer") as HTMLSpanElement,
      coverPuzzle: document.getElementById("cover-puzzle") as HTMLDivElement,
      options: document.getElementById("options") as HTMLFieldSetElement,
      container: document.getElementById(
        "question-container",
      ) as HTMLDivElement,
      nextRoundButton: document.getElementById(
        "next-round-button",
      ) as HTMLButtonElement,
      restartButton: document.getElementById(
        "restart-button",
      ) as HTMLButtonElement,
      loadingSpinner: document.getElementById("loading-spinner") as HTMLElement,
      gameSpeedToggle: document.getElementById(
        "game-speed-toggle",
      ) as HTMLButtonElement,
      puzzleDescription: document.getElementById(
        "puzzle-description",
      ) as HTMLDivElement,
      skipToAnswersButton: document.getElementById(
        "skip-to-answers",
      ) as HTMLButtonElement,
      keyboardShortcutsBtn: document.getElementById(
        "show-keyboard-shortcuts",
      ) as HTMLButtonElement,
      keyboardShortcutsPanel: document.getElementById(
        "keyboard-shortcuts",
      ) as HTMLDivElement,
    };
  }

  // Initialize game state
  const elements = cacheElements();
  let score = 0; // Player's total score
  let roundIndex = 0; // Current round (0-based)
  let correctAnswers = 0; // Number of correct answers
  let timeLeft = ROUND_TIME; // Current round time remaining
  let timerInterval: ReturnType<typeof setInterval>; // Timer reference
  let currentAlbum: Album | null = null; // Current album to guess
  let isRoundActive = false; // Whether the round is currently active
  let revealedPieces = 0; // Counter for revealed pieces
  let currentFocusIndex = -1; // Index of currently focused answer option

  // Set initial round display
  elements.round.textContent = `1/${TOTAL_ROUNDS}`;

  /**
   * Creates the puzzle grid with individual pieces
   * @param container - DOM element to contain the puzzle
   * @param imageUrl - URL of the album cover image
   * @returns Array of HTML elements representing puzzle pieces
   */
  function createPuzzleGrid(
    container: HTMLElement,
    imageUrl: string,
  ): HTMLElement[] {
    container.innerHTML = "";
    const pieces: HTMLElement[] = [];
    const pieceSize = 100 / GRID_SIZE; // Size as percentage of container

    // Create a grid of pieces, each showing a portion of the album cover
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        const piece = document.createElement("div");
        piece.className =
          "absolute bg-cover transition-all duration-300 ease-out transform hover:brightness-110";

        // Set ARIA attributes for accessibility
        piece.setAttribute("role", "presentation");

        // Position and size the piece
        piece.style.width = `${pieceSize}%`;
        piece.style.height = `${pieceSize}%`;
        piece.style.left = `${x * pieceSize}%`;
        piece.style.top = `${y * pieceSize}%`;

        // Set the background to show the correct portion of the album cover
        piece.style.backgroundImage = `url(${imageUrl})`;
        piece.style.backgroundPosition = `${(x * 100) / (GRID_SIZE - 1)}% ${
          (y * 100) / (GRID_SIZE - 1)
        }%`;
        piece.style.backgroundSize = `${GRID_SIZE * 100}%`;

        // Initially hide all pieces
        piece.style.opacity = "0";
        piece.style.filter = "brightness(0.8)";

        container.appendChild(piece);
        pieces.push(piece);
      }
    }
    return pieces;
  }

  /**
   * Reveals a specified number of random hidden puzzle pieces
   * @param pieces - Array of all puzzle pieces
   * @param count - Number of pieces to reveal
   * @returns Boolean indicating if all pieces are now revealed
   */
  function revealRandomPieces(pieces: HTMLElement[], count: number): boolean {
    const hiddenPieces = pieces.filter((piece) => piece.style.opacity === "0");
    const piecesToReveal = hiddenPieces
      .sort(() => Math.random() - 0.5) // Shuffle the pieces
      .slice(0, count); // Take only the number we need

    // Reveal each piece with a slight delay for animation effect
    piecesToReveal.forEach((piece, index) => {
      setTimeout(() => {
        piece.style.opacity = "1";
        piece.style.filter = "brightness(1)";

        // Update revealed pieces count
        revealedPieces++;

        // Update screen reader description on milestone percentages
        updatePuzzleDescription(revealedPieces, TOTAL_PIECES);
      }, index * PIECE_ANIMATION_DURATION);
    });

    // Return true if all pieces are now revealed or will be after this batch
    return hiddenPieces.length - count <= 0;
  }

  /**
   * Updates the puzzle description for screen readers
   * @param revealed - Number of revealed pieces
   * @param total - Total number of pieces
   */
  function updatePuzzleDescription(revealed: number, total: number) {
    const percentage = Math.floor((revealed / total) * 100);

    // Only announce at milestones to avoid too many announcements
    if (percentage % 25 === 0 || percentage === 10 || percentage === 90) {
      const description =
        t("game.puzzle.revealed")?.replace(
          "{percent}",
          percentage.toString(),
        ) || `${percentage}% des Albumcovers wurde aufgedeckt`;

      elements.puzzleDescription.textContent = description;
    }
  }

  /**
   * Shuffles an array using Fisher-Yates algorithm
   * @param array - The array to shuffle
   * @returns A new shuffled array
   */
  function shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  /**
   * Reveals the entire album cover immediately
   */
  function revealFullCover() {
    const pieces = Array.from(elements.coverPuzzle.children) as HTMLElement[];
    pieces.forEach((piece) => {
      piece.style.opacity = "1";
      piece.style.filter = "brightness(1)";
    });
  }

  /**
   * Calculates score based on remaining time
   * @param timeLeft - Seconds remaining in the round
   * @returns The calculated score
   */
  function calculateScore(timeLeft: number): number {
    return Math.round((BASE_POINTS * timeLeft) / ROUND_TIME);
  }

  /**
   * Handles player's answer selection
   * @param selectedAnswer - The album name selected by the player
   */
  function handleAnswer(selectedAnswer: string) {
    if (!isRoundActive || !currentAlbum) return;

    isRoundActive = false;
    clearInterval(timerInterval);
    revealFullCover();

    const isCorrect = selectedAnswer === currentAlbum.album;

    // Handle button states and styling
    const buttons = Array.from(
      elements.options.children,
    ) as HTMLButtonElement[];
    buttons.forEach((button) => {
      if (button.dataset.answer === selectedAnswer) {
        // Style clicked button based on correctness
        button.style.backgroundColor = isCorrect ? "#059669" : "#dc2626";
        button.style.borderColor = isCorrect ? "#047857" : "#b91c1c";

        // Add state for screen readers
        button.setAttribute("aria-selected", "true");
      } else if (button.dataset.answer === currentAlbum?.album && !isCorrect) {
        // Show correct answer in green if player was wrong
        button.style.backgroundColor = "#059669";
        button.style.borderColor = "#047857";

        // Add state for screen readers
        button.setAttribute(
          "aria-label",
          `${t("game.correct.answer") || "Richtige Antwort"}: ${button.textContent}`,
        );
      }
      // Disable all buttons after answer
      button.disabled = true;
      if (!button.style.backgroundColor) {
        button.style.opacity = "0.5";
      }
    });

    // Update feedback for screen readers
    elements.puzzleDescription.textContent = isCorrect
      ? t("game.answer.correct") || "Richtig! Gut gemacht!"
      : (t("game.answer.wrong") || "Falsch. Die richtige Antwort war: ") +
        `${currentAlbum.artist} - ${currentAlbum.album}`;

    // Update feedback and score
    if (isCorrect) {
      correctAnswers++;
      const roundScore = calculateScore(timeLeft);
      score += roundScore;
      elements.score.textContent = score.toString();
    }

    // Show feedback and next button
    elements.nextRoundButton.classList.remove("hidden");
    elements.nextRoundButton.focus();
  }

  /**
   * Creates answer options buttons, including the correct answer and decoys
   * @param correctAlbum - The album to be guessed
   * @param allAlbums - Array of all albums to choose decoys from
   * @param container - DOM element to contain the options
   */
  function createOptions(
    correctAlbum: Album,
    allAlbums: Album[],
    container: HTMLElement,
  ) {
    container.innerHTML = "";

    // Get wrong options - select random albums excluding the correct one
    const otherAlbums = allAlbums.filter(
      (album) => album.album !== correctAlbum.album,
    );
    const wrongOptions = shuffleArray(otherAlbums).slice(0, 3);

    // Combine correct and wrong options, then shuffle
    const options = shuffleArray([correctAlbum, ...wrongOptions]);

    // Create buttons for each option
    options.forEach((album, index) => {
      const button = document.createElement("button");
      button.className =
        "w-full p-4 bg-zinc-800 hover:bg-zinc-700 rounded-lg text-zinc-100 transition-all duration-300 text-sm sm:text-base border-2 border-zinc-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-zinc-900";
      button.textContent = `${album.artist} - ${album.album}`;
      button.dataset.answer = album.album;
      button.id = `answer-option-${index + 1}`;
      button.setAttribute(
        "aria-label",
        `${t("game.option.choose") || "Wähle"}: ${album.artist} - ${album.album}`,
      );

      // WCAG - Setze role für Tastaturnavigation
      button.setAttribute("role", "radio");
      button.setAttribute("aria-checked", "false");

      // Zahlen 1-4 als Accesskeys setzen
      button.setAttribute("accesskey", (index + 1).toString());

      // Füge Shortcut-Hint im Text hinzu
      const shortcutSpan = document.createElement("span");
      shortcutSpan.className = "sr-only";
      shortcutSpan.textContent = ` (Drücke ${index + 1})`;
      button.appendChild(shortcutSpan);

      // First option gets focus when options appear
      if (index === 0) {
        button.setAttribute("tabindex", "0");
        currentFocusIndex = 0;
      } else {
        button.setAttribute("tabindex", "-1");
      }

      container.appendChild(button);
    });

    // Announce to screen readers that options are available
    elements.puzzleDescription.textContent =
      t("game.options.available") ||
      "Antwortmöglichkeiten sind jetzt verfügbar";
  }

  /**
   * Updates the focused option with arrow key navigation
   * @param direction - 1 for right/down, -1 for left/up
   */
  function moveFocus(direction: number) {
    const options = Array.from(
      elements.options.children,
    ) as HTMLButtonElement[];

    if (!options.length) return;

    // Calculate next focus index with wrap-around
    const newIndex =
      (currentFocusIndex + direction + options.length) % options.length;

    // Update tabindex and focus
    options.forEach((opt, idx) => {
      opt.setAttribute("tabindex", idx === newIndex ? "0" : "-1");
    });

    currentFocusIndex = newIndex;
    (options[newIndex] as HTMLElement).focus();
  }

  /**
   * Starts the countdown timer for the current round
   */
  function startTimer() {
    // Adjust time based on accessibility settings
    timeLeft = isSlowerSpeed ? ROUND_TIME + SLOWER_TIME_BONUS : ROUND_TIME;
    elements.timer.textContent = timeLeft.toString();
    isRoundActive = true;

    timerInterval = setInterval(() => {
      timeLeft--;
      elements.timer.textContent = timeLeft.toString();

      // Announce time warnings for accessibility
      if (timeLeft === 30 || timeLeft === 10 || timeLeft === 5) {
        elements.puzzleDescription.textContent =
          t("game.time.remaining.seconds")?.replace(
            "{seconds}",
            timeLeft.toString(),
          ) || `Noch ${timeLeft} Sekunden übrig`;
      }

      if (timeLeft <= 0) {
        clearInterval(timerInterval);
        handleTimeout();
      }
    }, 1000);
  }

  /**
   * Handles timeout when the player fails to answer in time
   */
  function handleTimeout() {
    if (!isRoundActive) return;
    isRoundActive = false;
    revealFullCover();

    // Update for screen readers
    elements.puzzleDescription.textContent =
      t("game.time.up") ||
      "Zeit ist um! Das korrekte Album war: " +
        (currentAlbum ? `${currentAlbum.artist} - ${currentAlbum.album}` : "");

    // Highlight correct answer
    const buttons = Array.from(
      elements.options.children,
    ) as HTMLButtonElement[];

    buttons.forEach((button) => {
      if (button.dataset.answer === currentAlbum?.album) {
        button.style.backgroundColor = "#059669";
        button.style.borderColor = "#059669";
      }

      // Disable all buttons
      button.disabled = true;
      if (!button.style.backgroundColor) {
        button.style.opacity = "0.5";
      }
    });

    elements.nextRoundButton.classList.remove("hidden");
    elements.nextRoundButton.focus();
  }

  /**
   * Loads albums for the current category from JSON file
   * @returns Promise with the album data or null if error
   */
  async function loadAlbums() {
    try {
      const category = elements.container.getAttribute("data-category");
      if (!category) throw new Error(t("error.no.category"));

      try {
        // First try to load albums in the current language
        const response = await fetch(`/json/genres/${lang}/${category}.json`);
        if (!response.ok)
          throw new Error(`HTTP error! Status: ${response.status}`);
        const albumsData = await response.json();
        if (!albumsData?.length) throw new Error(t("error.no.albums.found"));
        return albumsData;
      } catch (error) {
        console.error("Initial load failed:", error);
        // Fallback to German if current language not available
        const fallback = await fetch(`/json/genres/de/${category}.json`);
        if (!fallback.ok) throw new Error(t("error.loading.albums"));
        return await fallback.json();
      }
    } catch (error) {
      console.error("Error loading albums:", error);
      ErrorHandler.handleApiError(
        error instanceof Error ? error : new Error(String(error)),
      );
      return null;
    }
  }

  /**
   * Prepares and starts a new round
   */
  async function loadNewRound() {
    elements.loadingSpinner.classList.remove("hidden");
    elements.container.setAttribute("data-hidden", "true");

    // Reset for the new round
    revealedPieces = 0;

    // Load album data for the current category
    const albums = await loadAlbums();
    if (!albums) return;

    // Randomly select an album for this round
    currentAlbum = albums[Math.floor(Math.random() * albums.length)];
    if (!currentAlbum) {
      console.error("No album selected for round");
      return;
    }

    // Create puzzle grid and answer options
    const pieces = createPuzzleGrid(
      elements.coverPuzzle,
      currentAlbum.coverSrc,
    );
    createOptions(currentAlbum, albums, elements.options);

    // Preload the cover image before showing the puzzle
    const image = new Image();
    image.src = currentAlbum.coverSrc;

    image.onload = () => {
      // Show the puzzle once image is loaded
      elements.container.removeAttribute("data-hidden");
      elements.loadingSpinner.classList.add("hidden");
      elements.nextRoundButton.classList.add("hidden");

      startTimer();

      // Set up gradual revealing of puzzle pieces as time passes
      const revealInterval = setInterval(() => {
        const timeElapsed = ROUND_TIME - timeLeft;
        const shouldReveal = Math.floor(timeElapsed * PIECES_PER_SECOND);
        const currentlyRevealed = pieces.filter(
          (piece: HTMLElement) => piece.style.opacity === "1",
        ).length;

        // Reveal more pieces if needed based on elapsed time
        if (
          shouldReveal > currentlyRevealed &&
          currentlyRevealed < pieces.length
        ) {
          revealRandomPieces(pieces, 1);
        }

        // Stop revealing if all pieces are visible or time is up
        if (currentlyRevealed >= pieces.length || timeLeft <= 0) {
          clearInterval(revealInterval);
        }
      }, REVEAL_INTERVAL);
    };

    image.onerror = () => {
      console.error("Failed to load album cover");
      ErrorHandler.handleApiError(new Error("Failed to load album cover"));
    };
  }

  /**
   * Ends the game and displays final score
   */
  function endGame() {
    const config = {
      userId: elements.container.getAttribute("data-userID") || "",
      categoryName: "Cover Puzzle",
      difficulty: "medium",
      totalRounds: TOTAL_ROUNDS,
      correctAnswers,
      score,
      language: lang,
    };

    const ui = {
      showEndgamePopup: (score: number) => {
        const popup = document.getElementById("endgame-popup");
        const scoreElement = popup?.querySelector("#popup-score");
        if (popup && scoreElement) {
          scoreElement.textContent = score.toString();
          popup.setAttribute("data-score", score.toString());
          popup.classList.remove("hidden");
        }
      },
    };

    handleEndGame(config, ui, {
      onError: (error) => {
        ErrorHandler.handleSaveError(error, "score", {
          userId: config.userId,
          category: config.categoryName,
        });
      },
    });
  }

  /**
   * Toggles keyboard shortcuts panel visibility
   */
  function toggleKeyboardShortcuts() {
    const isExpanded =
      elements.keyboardShortcutsBtn.getAttribute("aria-expanded") === "true";
    elements.keyboardShortcutsBtn.setAttribute(
      "aria-expanded",
      (!isExpanded).toString(),
    );

    // Toggle visibility
    if (isExpanded) {
      elements.keyboardShortcutsPanel.classList.add("sr-only");
      const spanElement = elements.keyboardShortcutsBtn.querySelector("span");
      if (spanElement) {
        spanElement.textContent = t("keyboard.shortcuts.show");
      }
    } else {
      elements.keyboardShortcutsPanel.classList.remove("sr-only");
      const spanElement = elements.keyboardShortcutsBtn.querySelector("span");
      if (spanElement) {
        spanElement.textContent = t("keyboard.shortcuts.hide");
      }
    }
  }

  // === Event Listeners ===

  // Option selection handler
  elements.options.addEventListener("click", (event: Event) => {
    const button = (event.target as HTMLElement).closest("button");
    if (button && !button.style.backgroundColor) {
      // Only handle clicks on unanswered buttons
      handleAnswer(button.dataset.answer || "");
    }
  });

  // Restart button handler
  elements.restartButton?.addEventListener("click", restartGame);

  // Next round button handler
  elements.nextRoundButton.onclick = () => {
    if (roundIndex < TOTAL_ROUNDS - 1) {
      roundIndex++;
      elements.round.textContent = `${roundIndex + 1}/${TOTAL_ROUNDS}`;
      loadNewRound();
    } else {
      endGame();
    }
  };

  // Toggle game speed for accessibility
  elements.gameSpeedToggle.addEventListener("click", () => {
    isSlowerSpeed = !isSlowerSpeed;

    // Update the button appearance and aria-pressed state
    elements.gameSpeedToggle.setAttribute(
      "aria-pressed",
      isSlowerSpeed.toString(),
    );

    if (isSlowerSpeed) {
      elements.gameSpeedToggle.classList.add("bg-purple-700");
      elements.gameSpeedToggle.classList.remove("bg-zinc-800");
      const normalSpeedSpan = elements.gameSpeedToggle.querySelector("span");
      if (normalSpeedSpan) {
        normalSpeedSpan.textContent =
          t("game.normal.speed") || "Normale Geschwindigkeit";
      }
    } else {
      elements.gameSpeedToggle.classList.remove("bg-purple-700");
      elements.gameSpeedToggle.classList.add("bg-zinc-800");
      const slowerSpeedSpan = elements.gameSpeedToggle.querySelector("span");
      if (slowerSpeedSpan) {
        slowerSpeedSpan.textContent =
          t("game.slower.speed") || "Langsameres Spiel";
      }
    }

    // If in active round, adjust remaining time
    if (isRoundActive) {
      clearInterval(timerInterval);

      // Adjust time based on new setting
      if (isSlowerSpeed) {
        timeLeft += SLOWER_TIME_BONUS;
      }
      startTimer();
    }
  });

  // Skip to answers button for keyboard users
  elements.skipToAnswersButton.addEventListener("click", () => {
    const firstOption = document.getElementById("answer-option-1");
    if (firstOption) {
      firstOption.focus();
    }
  });

  // Keyboard shortcuts button
  elements.keyboardShortcutsBtn.addEventListener(
    "click",
    toggleKeyboardShortcuts,
  );

  // Initialize game if all required elements are available
  if (
    elements.container &&
    elements.coverPuzzle &&
    elements.options &&
    elements.score &&
    elements.round &&
    elements.timer
  ) {
    loadNewRound();
  } else {
    console.error(t("error.missing.elements"));
  }

  // Enhanced keyboard navigation
  document.addEventListener("keydown", (event) => {
    // Skip if in text input
    if (
      event.target instanceof HTMLInputElement ||
      event.target instanceof HTMLTextAreaElement
    ) {
      return;
    }

    // Nur verarbeiten, wenn eine Spielrunde aktiv ist
    if (isRoundActive) {
      // Arrow keys for option navigation
      if (event.key === "ArrowRight" || event.key === "ArrowDown") {
        moveFocus(1);
        event.preventDefault();
      } else if (event.key === "ArrowLeft" || event.key === "ArrowUp") {
        moveFocus(-1);
        event.preventDefault();
      }

      // Number keys 1-4 to select answers
      if (event.key >= "1" && event.key <= "4") {
        const optionIndex = parseInt(event.key) - 1;
        const options = Array.from(
          elements.options.children,
        ) as HTMLButtonElement[];

        if (options[optionIndex] && !options[optionIndex].disabled) {
          options[optionIndex].click();
          event.preventDefault();
        }
      }

      // S key for game speed toggle
      if (event.key === "s" || event.key === "S") {
        elements.gameSpeedToggle.click();
        event.preventDefault();
      }
    }

    // N key for next round
    if (
      (event.key === "n" || event.key === "N") &&
      !elements.nextRoundButton.classList.contains("hidden")
    ) {
      elements.nextRoundButton.click();
      event.preventDefault();
    }

    // H key to toggle keyboard shortcuts help
    if (event.key === "h" || event.key === "H") {
      toggleKeyboardShortcuts();
      event.preventDefault();
    }
  });
</script>

<style is:global>
  #cover-puzzle > div {
    transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);
    will-change: opacity, transform;
  }

  /* Verbesserte Focus-Stile für WCAG AAA */
  button:focus-visible,
  [role="radio"]:focus-visible {
    outline: 3px solid #a855f7;
    outline-offset: 3px;
    box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.5);
  }

  /* Animation for correct/wrong answers */
  @keyframes pulse {
    0%,
    100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.05);
    }
  }

  [aria-selected="true"] {
    animation: pulse 0.5s ease-in-out;
  }

  /* WCAG AAA Kontraste (7:1 Mindestverhältnis) */
  .text-zinc-300 {
    color: #d9d9d9; /* Verbessert von #d4d4d8 für höheren Kontrast */
  }

  .text-zinc-100 {
    color: #ffffff; /* Maximaler Kontrast */
  }

  .bg-zinc-800 {
    background-color: #27272a;
  }

  /* Add smooth card-hover effect */
  #options button {
    transition: all 300ms ease-in-out;
    transform: translateY(0);
    position: relative; /* Hinzugefügt für fokusierte Elemente */
  }

  #options button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }

  /* Visuelles Feedback für Tastaturnavigation */
  #options button:focus-visible::before {
    content: "▶";
    position: absolute;
    left: -1.5rem;
    color: #a855f7;
  }

  /* Animation für Tastaturnavigation */
  @keyframes focusIn {
    from {
      transform: scale(0.95);
      opacity: 0.8;
    }
    to {
      transform: scale(1);
      opacity: 1;
    }
  }

  #options button:focus-visible {
    animation: focusIn 0.2s ease-out forwards;
    z-index: 5;
  }

  /* Tastaturkürzelpanel */
  #keyboard-shortcuts {
    position: absolute;
    top: 70px;
    right: 20px;
    background-color: #18181b;
    border: 2px solid #a855f7;
    padding: 1rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    max-width: 300px;
    z-index: 50;
  }

  #keyboard-shortcuts.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  #keyboard-shortcuts h2 {
    color: #ffffff;
    margin-bottom: 0.75rem;
    font-size: 1.1rem;
    font-weight: 600;
  }

  #keyboard-shortcuts dl {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.5rem 1rem;
  }

  #keyboard-shortcuts dt {
    font-weight: 600;
    color: #a855f7;
  }

  #keyboard-shortcuts dd {
    color: #ffffff;
  }
</style>
