---
import Layout from "@layouts/Layout.astro";
import ShowCoins from "@components/Shared/ShowCoins.astro";
import GameHeadline from "@components/Game/GameHeadline.astro";
import EndOverlay from "@components/Overlays/EndOverlay.astro";
import LoadingSpinner from "@components/Game/LoadingSpinner.astro";
import ErrorMessage from "@components/Shared/ErrorMessage.astro";
import { getLangFromUrl, useTranslations } from "@utils/i18n";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
const { category } = Astro.params;

let categories;
try {
  categories = await import(`@json/${lang}_categories.json`);
} catch (error) {
  categories = await import(`@json/de_categories.json`);
}

const currentCategoryData = categories.default.find(
  (cat: any) => cat.slug === category,
);

const user = { id: "guest" };
---

<Layout title="Cover Puzzle" showCoins={true}>
  <div slot="left-headercol">
    <ShowCoins />
  </div>

  <EndOverlay id="endgame-popup" data-score="0" data-category="Cover Puzzle" />
  <GameHeadline headline={`${currentCategoryData?.headline} Cover Puzzle`} />
  <ErrorMessage />
  <LoadingSpinner />

  <div class="flex items-center justify-center mb-4">
    <div class="text-xl font-bold text-zinc-300">
      Time: <span class="timer">60</span>s
    </div>
  </div>

  <div
    id="question-container"
    class="w-full mx-auto p-6 text-center transition-opacity duration-500 opacity-100 data-[hidden=true]:opacity-0"
    role="main"
    aria-label={t("game.area.label")}
    data-userID={user.id}
    data-category={category}
  >
    <div class="max-w-xl mx-auto">
      <div
        id="cover-puzzle"
        class="relative w-full aspect-square mb-6 bg-zinc-900"
      >
        <!-- Puzzle grid will be created by JavaScript -->
      </div>

      <div
        id="options"
        class="grid sm:grid-cols-2 gap-3 mt-6"
        role="radiogroup"
        aria-label={t("game.options.label")}
      >
      </div>

      <div class="mt-6 space-y-4">
        <button
          id="next-round-button"
          class="hidden px-8 py-3 bg-purple-600 hover:bg-purple-500 rounded-lg text-white font-medium transition-colors mx-auto block"
        >
          {t("game.next")}
        </button>
      </div>
    </div>
  </div>
</Layout>

<script>
  import { ErrorHandler } from "@utils/error/errorHandler";
  import { handleEndGame, restartGame } from "@utils/game/endGameUtils";
  import { getLangFromUrl, useTranslations } from "@utils/i18n";
  import type { Album } from "src/types/game";

  /**
   * Cover Puzzle Game - Main Script
   *
   * This game presents a gradually revealing album cover image.
   * Players must identify the correct album from four options
   * before the entire cover is revealed.
   */

  // Get language and translations
  const lang = getLangFromUrl(
    new URL(window.location.pathname, window.location.origin),
  );
  const t = useTranslations(lang);

  // Game configuration constants
  const TOTAL_ROUNDS = 10; // Total number of rounds to play
  const ROUND_TIME = 60; // Time in seconds per round
  const GRID_SIZE = 8; // Puzzle grid dimensions (8x8)
  const BASE_POINTS = 200; // Base points for correct answers
  const TOTAL_PIECES = GRID_SIZE * GRID_SIZE; // Total puzzle pieces
  const REVEAL_INTERVAL = 850; // Time between piece reveals (ms)
  const PIECE_ANIMATION_DURATION = 300; // Animation time for each piece (ms)
  const LAST_PIECE_BUFFER = 3; // Buffer seconds at the end of round

  // Calculate how many pieces to reveal per second to complete just before time ends
  const PIECES_PER_SECOND =
    (TOTAL_PIECES - 1) / (ROUND_TIME - LAST_PIECE_BUFFER);

  /**
   * Interface for accessing all game-related DOM elements
   */
  interface GameElements {
    score: HTMLParagraphElement;
    round: HTMLParagraphElement;
    timer: HTMLSpanElement;
    coverPuzzle: HTMLDivElement;
    options: HTMLDivElement;
    container: HTMLDivElement;
    nextRoundButton: HTMLButtonElement;
    restartButton: HTMLButtonElement;
    loadingSpinner: HTMLElement;
  }

  /**
   * Cache all game DOM elements for better performance
   */
  function cacheElements(): GameElements {
    return {
      score: document.querySelector(".coinsCount") as HTMLParagraphElement,
      round: document.querySelector(".round") as HTMLParagraphElement,
      timer: document.querySelector(".timer") as HTMLSpanElement,
      coverPuzzle: document.getElementById("cover-puzzle") as HTMLDivElement,
      options: document.getElementById("options") as HTMLDivElement,
      container: document.getElementById(
        "question-container",
      ) as HTMLDivElement,
      nextRoundButton: document.getElementById(
        "next-round-button",
      ) as HTMLButtonElement,
      restartButton: document.getElementById(
        "restart-button",
      ) as HTMLButtonElement,
      loadingSpinner: document.getElementById("loading-spinner") as HTMLElement,
    };
  }

  // Initialize game state
  const elements = cacheElements();
  let score = 0; // Player's total score
  let roundIndex = 0; // Current round (0-based)
  let correctAnswers = 0; // Number of correct answers
  let timeLeft = ROUND_TIME; // Current round time remaining
  let timerInterval: ReturnType<typeof setInterval>; // Timer reference
  let currentAlbum: Album | null = null; // Current album to guess
  let isRoundActive = false; // Whether the round is currently active

  /**
   * Creates the puzzle grid with individual pieces
   * @param container - DOM element to contain the puzzle
   * @param imageUrl - URL of the album cover image
   * @returns Array of HTML elements representing puzzle pieces
   */
  function createPuzzleGrid(
    container: HTMLElement,
    imageUrl: string,
  ): HTMLElement[] {
    container.innerHTML = "";
    const pieces: HTMLElement[] = [];
    const pieceSize = 100 / GRID_SIZE; // Size as percentage of container

    // Create a grid of pieces, each showing a portion of the album cover
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        const piece = document.createElement("div");
        piece.className =
          "absolute bg-cover transition-all duration-300 ease-out transform hover:brightness-110";

        // Position and size the piece
        piece.style.width = `${pieceSize}%`;
        piece.style.height = `${pieceSize}%`;
        piece.style.left = `${x * pieceSize}%`;
        piece.style.top = `${y * pieceSize}%`;

        // Set the background to show the correct portion of the album cover
        piece.style.backgroundImage = `url(${imageUrl})`;
        piece.style.backgroundPosition = `${(x * 100) / (GRID_SIZE - 1)}% ${
          (y * 100) / (GRID_SIZE - 1)
        }%`;
        piece.style.backgroundSize = `${GRID_SIZE * 100}%`;

        // Initially hide all pieces
        piece.style.opacity = "0";
        piece.style.filter = "brightness(0.8)";

        container.appendChild(piece);
        pieces.push(piece);
      }
    }
    return pieces;
  }

  /**
   * Reveals a specified number of random hidden puzzle pieces
   * @param pieces - Array of all puzzle pieces
   * @param count - Number of pieces to reveal
   * @returns Boolean indicating if all pieces are now revealed
   */
  function revealRandomPieces(pieces: HTMLElement[], count: number): boolean {
    const hiddenPieces = pieces.filter((piece) => piece.style.opacity === "0");
    const piecesToReveal = hiddenPieces
      .sort(() => Math.random() - 0.5) // Shuffle the pieces
      .slice(0, count); // Take only the number we need

    // Reveal each piece with a slight delay for animation effect
    piecesToReveal.forEach((piece, index) => {
      setTimeout(() => {
        piece.style.opacity = "1";
        piece.style.filter = "brightness(1)";
      }, index * PIECE_ANIMATION_DURATION);
    });

    // Return true if all pieces are now revealed or will be after this batch
    return hiddenPieces.length - count <= 0;
  }

  /**
   * Shuffles an array using Fisher-Yates algorithm
   * @param array - The array to shuffle
   * @returns A new shuffled array
   */
  function shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  /**
   * Reveals the entire album cover immediately
   */
  function revealFullCover() {
    const pieces = Array.from(elements.coverPuzzle.children) as HTMLElement[];
    pieces.forEach((piece) => {
      piece.style.opacity = "1";
      piece.style.filter = "brightness(1)";
    });
  }

  /**
   * Calculates score based on remaining time
   * @param timeLeft - Seconds remaining in the round
   * @returns The calculated score
   */
  function calculateScore(timeLeft: number): number {
    return Math.round((BASE_POINTS * timeLeft) / ROUND_TIME);
  }

  /**
   * Handles player's answer selection
   * @param selectedAnswer - The album name selected by the player
   */
  function handleAnswer(selectedAnswer: string) {
    if (!isRoundActive || !currentAlbum) return;

    isRoundActive = false;
    clearInterval(timerInterval);
    revealFullCover();

    const isCorrect = selectedAnswer === currentAlbum.album;

    // Handle button states and styling
    const buttons = Array.from(
      elements.options.children,
    ) as HTMLButtonElement[];
    buttons.forEach((button) => {
      if (button.dataset.answer === selectedAnswer) {
        // Style clicked button based on correctness
        button.style.backgroundColor = isCorrect ? "#059669" : "#dc2626";
        button.style.borderColor = isCorrect ? "#059669" : "#dc2626";
      } else if (button.dataset.answer === currentAlbum?.album && !isCorrect) {
        // Show correct answer in green if player was wrong
        button.style.backgroundColor = "#059669";
        button.style.borderColor = "#059669";
      }
      // Disable all buttons after answer
      button.disabled = true;
      if (!button.style.backgroundColor) {
        button.style.opacity = "0.5";
      }
    });

    // Update feedback and score
    if (isCorrect) {
      correctAnswers++;
      const roundScore = calculateScore(timeLeft);
      score += roundScore;
      elements.score.textContent = score.toString();
    }

    // Show feedback and next button
    elements.nextRoundButton.classList.remove("hidden");
  }

  /**
   * Creates answer options buttons, including the correct answer and decoys
   * @param correctAlbum - The album to be guessed
   * @param allAlbums - Array of all albums to choose decoys from
   * @param container - DOM element to contain the options
   */
  function createOptions(
    correctAlbum: Album,
    allAlbums: Album[],
    container: HTMLElement,
  ) {
    container.innerHTML = "";

    // Get wrong options - select random albums excluding the correct one
    const otherAlbums = allAlbums.filter(
      (album) => album.album !== correctAlbum.album,
    );
    const wrongOptions = shuffleArray(otherAlbums).slice(0, 3);

    // Combine correct and wrong options, then shuffle
    const options = shuffleArray([correctAlbum, ...wrongOptions]);

    // Create buttons for each option
    options.forEach((album) => {
      const button = document.createElement("button");
      button.className =
        "w-full p-3 bg-zinc-700 hover:bg-zinc-600 rounded-lg text-zinc-100 transition-all duration-300 text-sm sm:text-base border-2 border-transparent";
      button.textContent = `${album.artist} - ${album.album}`;
      button.dataset.answer = album.album;
      container.appendChild(button);
    });
  }

  /**
   * Starts the countdown timer for the current round
   */
  function startTimer() {
    timeLeft = ROUND_TIME;
    elements.timer.textContent = timeLeft.toString();
    isRoundActive = true;

    timerInterval = setInterval(() => {
      timeLeft--;
      elements.timer.textContent = timeLeft.toString();
      if (timeLeft <= 0) {
        clearInterval(timerInterval);
        handleTimeout();
      }
    }, 1000);
  }

  /**
   * Handles timeout when the player fails to answer in time
   */
  function handleTimeout() {
    if (!isRoundActive) return;
    isRoundActive = false;
    revealFullCover();
    elements.nextRoundButton.classList.remove("hidden");
  }

  /**
   * Loads albums for the current category from JSON file
   * @returns Promise with the album data or null if error
   */
  async function loadAlbums() {
    try {
      const category = elements.container.getAttribute("data-category");
      if (!category) throw new Error(t("error.no.category"));

      try {
        // First try to load albums in the current language
        const response = await fetch(`/json/genres/${lang}/${category}.json`);
        if (!response.ok)
          throw new Error(`HTTP error! Status: ${response.status}`);
        const albumsData = await response.json();
        if (!albumsData?.length) throw new Error(t("error.no.albums.found"));
        return albumsData;
      } catch (error) {
        console.error("Initial load failed:", error);
        // Fallback to German if current language not available
        const fallback = await fetch(`/json/genres/de/${category}.json`);
        if (!fallback.ok) throw new Error(t("error.loading.albums"));
        return await fallback.json();
      }
    } catch (error) {
      console.error("Error loading albums:", error);
      ErrorHandler.handleApiError(
        error instanceof Error ? error : new Error(String(error)),
      );
      return null;
    }
  }

  /**
   * Prepares and starts a new round
   */
  async function loadNewRound() {
    elements.loadingSpinner.classList.remove("hidden");
    elements.container.setAttribute("data-hidden", "true");

    // Load album data for the current category
    const albums = await loadAlbums();
    if (!albums) return;

    // Randomly select an album for this round
    currentAlbum = albums[Math.floor(Math.random() * albums.length)];
    if (!currentAlbum) {
      console.error("No album selected for round");
      return;
    }

    // Create puzzle grid and answer options
    const pieces = createPuzzleGrid(
      elements.coverPuzzle,
      currentAlbum.coverSrc,
    );
    createOptions(currentAlbum, albums, elements.options);

    // Preload the cover image before showing the puzzle
    const image = new Image();
    image.src = currentAlbum.coverSrc;

    image.onload = () => {
      // Show the puzzle once image is loaded
      elements.container.removeAttribute("data-hidden");
      elements.loadingSpinner.classList.add("hidden");
      elements.nextRoundButton.classList.add("hidden");

      startTimer();

      // Set up gradual revealing of puzzle pieces as time passes
      const revealInterval = setInterval(() => {
        const timeElapsed = ROUND_TIME - timeLeft;
        const shouldReveal = Math.floor(timeElapsed * PIECES_PER_SECOND);
        const currentlyRevealed = pieces.filter(
          (piece: HTMLElement) => piece.style.opacity === "1",
        ).length;

        // Reveal more pieces if needed based on elapsed time
        if (
          shouldReveal > currentlyRevealed &&
          currentlyRevealed < pieces.length
        ) {
          revealRandomPieces(pieces, 1);
        }

        // Stop revealing if all pieces are visible or time is up
        if (currentlyRevealed >= pieces.length || timeLeft <= 0) {
          clearInterval(revealInterval);
        }
      }, REVEAL_INTERVAL);
    };

    image.onerror = () => {
      console.error("Failed to load album cover");
      ErrorHandler.handleApiError(new Error("Failed to load album cover"));
    };
  }

  /**
   * Ends the game and displays final score
   */
  function endGame() {
    const config = {
      userId: elements.container.getAttribute("data-userID") || "",
      categoryName: "Cover Puzzle",
      difficulty: "medium",
      totalRounds: TOTAL_ROUNDS,
      correctAnswers,
      score,
      language: lang,
    };

    const ui = {
      showEndgamePopup: (score: number) => {
        const popup = document.getElementById("endgame-popup");
        const scoreElement = popup?.querySelector("#popup-score");
        if (popup && scoreElement) {
          scoreElement.textContent = score.toString();
          popup.setAttribute("data-score", score.toString());
          popup.classList.remove("hidden");
        }
      },
    };

    handleEndGame(config, ui, {
      onError: (error) => {
        ErrorHandler.handleSaveError(error, "score", {
          userId: config.userId,
          category: config.categoryName,
        });
      },
    });
  }

  // === Event Listeners ===

  // Option selection handler
  elements.options.addEventListener("click", (event: Event) => {
    const button = (event.target as HTMLElement).closest("button");
    if (button && !button.style.backgroundColor) {
      // Only handle clicks on unanswered buttons
      handleAnswer(button.dataset.answer || "");
    }
  });

  // Restart button handler
  elements.restartButton?.addEventListener("click", restartGame);

  // Next round button handler
  elements.nextRoundButton.onclick = () => {
    if (roundIndex < TOTAL_ROUNDS - 1) {
      roundIndex++;
      elements.round.textContent = `${roundIndex + 1}/${TOTAL_ROUNDS}`;
      loadNewRound();
    } else {
      endGame();
    }
  };

  // Initialize game if all required elements are available
  if (
    elements.container &&
    elements.coverPuzzle &&
    elements.options &&
    elements.score &&
    elements.round &&
    elements.timer
  ) {
    loadNewRound();
  } else {
    console.error(t("error.missing.elements"));
  }
</script>

<style is:global>
  #cover-puzzle > div {
    transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);
  }

  button {
    transition: all 300ms ease-in-out;
  }
</style>
