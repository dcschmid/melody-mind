---
/**
 * @component ChronologyGamePage
 * @description Moderne Chronologie-Spielseite für das MelodyMind-Projekt
 *
 * Funktionen:
 * - Schwierigkeitsgrade (Easy: 4 Alben, Medium: 5 Alben, Hard: 6 Alben)
 * - Intuitive Buttons zum Verschieben der Elemente
 * - Vollständige Tastatursteuerung
 * - Punkteberechnung basierend auf korrekter Reihenfolge
 * - Lösungsoverlay nach jeder Runde
 * - Endoverlay mit Gesamtergebnis
 * - Modernes, ansprechendes Design mit CSS-Variablen
 * - Datenbank-Speicherung der Spielergebnisse
 */

// 1. Imports
import Layout from "@layouts/Layout.astro";
import EndOverlay from "@components/Overlays/EndOverlay.astro";
import LoadingSpinner from "@components/Game/LoadingSpinner.astro";
import ChronologyFeedbackOverlay from "@components/Overlays/ChronologyFeedbackOverlay.astro";
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import { Icon } from "astro-icon/components";
import { requireAuth } from "../../../middleware/auth.js";

// Server-side rendering for cookie-based authentication
export const prerender = false;

/**
 * Generiert statische Pfade für alle unterstützten Sprachen, Kategorien und Schwierigkeitsgrade
 */
export async function getStaticPaths() {
  const supportedLanguages = [
    "de",
    "en",
    "es",
    "fr",
    "it",
    "pt",
    "da",
    "nl",
    "sv",
    "fi",
    "cn",
    "ru",
    "jp",
    "uk",
  ] as const;
  const difficultyLevels = ["easy", "medium", "hard"] as const;
  const paths = [];

  for (const lang of supportedLanguages) {
    let categories;
    try {
      categories = await import(`@json/${lang}_categories.json`);
    } catch {
      categories = await import(`@json/en_categories.json`);
    }

    for (const categoryData of categories.default) {
      for (const difficulty of difficultyLevels) {
        paths.push({
          params: { lang, category: categoryData.slug, difficulty },
          props: { categoryData, lang },
        });
      }
    }
  }

  return paths;
}

// 2. Props und Parameter verarbeitung
interface Props {
  categoryData: { headline: string; slug: string };
  lang: string;
}

const { categoryData } = Astro.props;
const lang = getLangFromUrl(Astro.url) as string;
const t = useTranslations(lang);
const { category, difficulty } = Astro.params;

// 3. Authentifizierung prüfen
const authResult = await requireAuth(Astro.request);
const user = { id: authResult.user?.id || "guest" };

// 4. Meta-Daten für SEO
const metaDescription = `${t("game.chronology.title")} - ${categoryData?.headline} (${t(`difficulty.${difficulty}`)})`;
---

<Layout
  title={`${t("game.chronology.title")} - ${categoryData?.headline}`}
  description={metaDescription}
  showHeader={false}
  showCoins={false}
>
  <!-- Feedback- und End-Overlays -->
  <ChronologyFeedbackOverlay />
  <EndOverlay
    id="endgame-popup"
    data-score="0"
    data-category={categoryData?.headline || ""}
    data-difficulty={difficulty || ""}
  />

  <!-- Loading Spinner -->
  <LoadingSpinner />

  <!-- Spielbereich -->
  <main
    id="chronology-container"
    class="chronology-game"
    data-category={category}
    data-difficulty={difficulty}
    data-user-id={user.id}
    data-category-name={categoryData?.headline || ""}
    aria-label={t("game.chronology.aria.main")}
  >
    <!-- Game Header -->
    <header class="game-header">
      <!-- Game Info Badges -->
      <div class="game-info" role="banner" aria-label={t("game.chronology.info.aria")}>
        <div class="badge">
          <Icon name="trophy" class="badge__icon" />
          <span class="badge__text" id="score-display">0</span>
        </div>
        <div class="badge">
          <Icon name="target" class="badge__icon" />
          <span class="badge__text">
            <span id="round-display">1</span>/10
          </span>
        </div>
        <div class="badge">
          <Icon name="gauge" class="badge__icon" />
          <span class="badge__text">{t(`difficulty.${difficulty}`)}</span>
        </div>
      </div>
    </header>

    <!-- Game Content -->
    <div class="game-content">
      <h1 class="game-title">{t("game.chronology.sort.albums")}</h1>
      <p class="game-description">{t("game.chronology.instructions")}</p>

      <!-- Chronology Container -->
      <div id="chronology-items-container" class="chronology-container">
        <div class="loading-placeholder">
          <Icon name="loader" class="loading-icon" />
          <p>{t("loading.albums")}</p>
        </div>
      </div>

      <!-- Game Controls -->
      <div class="game-controls">
        <!-- Move Buttons -->
        <div class="move-buttons">
          <button
            id="move-up-btn"
            type="button"
            class="move-button"
            disabled
            aria-label={t("game.move.up.aria")}
          >
            <Icon name="chevron-up" class="move-button__icon" />
            {t("game.move.up")}
          </button>
          <button
            id="move-down-btn"
            type="button"
            class="move-button"
            disabled
            aria-label={t("game.move.down.aria")}
          >
            <Icon name="chevron-down" class="move-button__icon" />
            {t("game.move.down")}
          </button>
        </div>

        <!-- Submit Button -->
        <button
          id="submit-btn"
          type="button"
          class="submit-button"
          disabled
          aria-label={t("game.submit.answer.aria")}
        >
          <Icon name="check" class="submit-button__icon" />
          {t("game.submit.answer")}
        </button>
      </div>
    </div>
  </main>
</Layout>

<script type="module">
  // Import EndOverlay utilities for proper animation and display
  import {
    showEndOverlay,
    setupEndOverlay,
    updateEndOverlayScore,
    updateMotivationText,
    animateProgressBar,
  } from "/src/utils/endOverlay.ts";

  // Setup EndOverlay functionality
  setupEndOverlay();

  // Make EndOverlay functions globally available for the game class
  window.showEndOverlay = showEndOverlay;
  window.updateEndOverlayScore = updateEndOverlayScore;
  window.updateMotivationText = updateMotivationText;
  window.animateProgressBar = animateProgressBar;

  // Game implementation with standalone functionality (no external imports)

  // Type definitions as constants to avoid TypeScript syntax issues
  const DIFFICULTY_LEVELS = {
    EASY: "easy",
    MEDIUM: "medium",
    HARD: "hard",
  };

  const ITEMS_PER_DIFFICULTY = {
    [DIFFICULTY_LEVELS.EASY]: 4,
    [DIFFICULTY_LEVELS.MEDIUM]: 5,
    [DIFFICULTY_LEVELS.HARD]: 6,
  };

  // Data loading functions
  async function loadAlbumsData(category, language) {
    try {
      // Try to load from the specified language first
      const response = await fetch(`/json/genres/${language}/${category}.json`);

      if (!response.ok) {
        // Fallback to German if the language-specific file doesn't exist
        console.warn(`No albums found for ${language}/${category}, falling back to German`);
        const fallbackResponse = await fetch(`/json/genres/de/${category}.json`);

        if (!fallbackResponse.ok) {
          throw new Error(`Failed to load albums for category: ${category}`);
        }

        return await fallbackResponse.json();
      }

      return await response.json();
    } catch (error) {
      console.error("Error loading albums data:", error);
      throw error;
    }
  }

  function generateChronologyQuestion(albumsData, difficulty) {
    const itemCount = ITEMS_PER_DIFFICULTY[difficulty] || 4;

    if (!albumsData || albumsData.length === 0) {
      throw new Error("No albums data available");
    }

    // Convert albums data to chronology items format
    const allItems = albumsData.map((album, index) => ({
      id: index + 1,
      artist: album.artist,
      title: album.album,
      year: parseInt(album.year),
    }));

    // Group albums by year to avoid duplicates
    const albumsByYear = new Map();
    allItems.forEach((item) => {
      if (!albumsByYear.has(item.year)) {
        albumsByYear.set(item.year, []);
      }
      albumsByYear.get(item.year).push(item);
    });

    // Get unique years sorted chronologically
    const uniqueYears = Array.from(albumsByYear.keys()).sort((a, b) => a - b);

    // Check if we have enough unique years
    if (uniqueYears.length < itemCount) {
      console.warn(
        `Not enough unique years (${uniqueYears.length}) for difficulty ${difficulty} (needs ${itemCount}). Using available years.`
      );
    }

    // Select one album per year, ensuring unique years
    const selectedItems = [];
    const availableYears = [...uniqueYears];

    for (let i = 0; i < Math.min(itemCount, availableYears.length); i++) {
      // Randomly select a year
      const randomYearIndex = Math.floor(Math.random() * availableYears.length);
      const selectedYear = availableYears.splice(randomYearIndex, 1)[0];

      // Randomly select one album from that year
      const albumsInYear = albumsByYear.get(selectedYear);
      const randomAlbumIndex = Math.floor(Math.random() * albumsInYear.length);
      const selectedAlbum = albumsInYear[randomAlbumIndex];

      selectedItems.push(selectedAlbum);
    }

    // Sort selected items by year to get correct order
    const correctOrderItems = selectedItems.sort((a, b) => a.year - b.year);
    const correctOrder = correctOrderItems.map((item) => item.id);

    // Shuffle the items for display
    const shuffledItems = [...selectedItems].sort(() => Math.random() - 0.5);

    return {
      items: shuffledItems,
      correctOrder: correctOrder,
    };
  }

  // Score evaluation function
  function evaluateChronologyAnswer(userOrder, correctOrder) {
    let correctItems = 0;
    const totalItems = correctOrder.length;

    for (let i = 0; i < totalItems; i++) {
      if (userOrder[i] === correctOrder[i]) {
        correctItems++;
      }
    }

    const score = Math.round((correctItems / totalItems) * 100);

    return {
      score: score,
      correctItems: correctItems,
      totalItems: totalItems,
    };
  }

  // Main game class
  class ChronologyGame {
    constructor() {
      this.container = document.getElementById("chronology-container");
      this.itemsContainer = document.getElementById("chronology-items-container");
      this.moveUpBtn = document.getElementById("move-up-btn");
      this.moveDownBtn = document.getElementById("move-down-btn");
      this.submitBtn = document.getElementById("submit-btn");
      this.scoreDisplay = document.getElementById("score-display");
      this.roundDisplay = document.getElementById("round-display");

      this.difficulty = this.container?.dataset.difficulty || "easy";
      this.category = this.container?.dataset.category || "";
      this.userId = this.container?.dataset.userId || "guest";

      this.currentItems = [];
      this.correctOrder = [];
      this.selectedIndex = -1;
      this.score = 0;
      this.round = 1;
      this.totalRounds = 10;
      this.albumsData = null;

      // Get language from URL
      const urlPath = window.location.pathname;
      const langMatch = urlPath.match(/^\/([a-z]{2})\//);
      this.language = langMatch ? langMatch[1] : "de";

      this.initializeGame();
    }

    async initializeGame() {
      if (!this.container || !this.itemsContainer) {
        console.error("Required DOM elements not found");
        return;
      }

      try {
        // Load albums data first
        await this.loadAlbumsData();
        this.setupEventListeners();
        await this.loadQuestion();
      } catch (error) {
        console.error("Failed to initialize game:", error);
        this.showError("chronology.error.initialization");
      }
    }

    async loadAlbumsData() {
      try {
        this.albumsData = await loadAlbumsData(this.category, this.language);
      } catch (error) {
        console.error("Error loading albums:", error);
        throw error;
      }
    }

    setupEventListeners() {
      this.moveUpBtn?.addEventListener("click", () => this.moveItem(-1));
      this.moveDownBtn?.addEventListener("click", () => this.moveItem(1));
      this.submitBtn?.addEventListener("click", () => this.submitAnswer());
    }

    async loadQuestion() {
      try {
        if (!this.albumsData) {
          throw new Error("Albums data not loaded");
        }

        // Generate question from real data
        const questionData = generateChronologyQuestion(this.albumsData, this.difficulty);
        this.currentItems = questionData.items;
        this.correctOrder = questionData.correctOrder;

        this.renderItems();
        this.updateControls();
      } catch (error) {
        console.error("Error loading question:", error);
        this.showError("chronology.error.question.load");
      }
    }

    renderItems() {
      if (!this.itemsContainer) {
        return;
      }

      this.itemsContainer.innerHTML = "";

      this.currentItems.forEach((item, index) => {
        const itemElement = document.createElement("div");
        itemElement.className = "chronology-item";
        itemElement.dataset.index = index.toString();
        itemElement.setAttribute("tabindex", "0");
        itemElement.setAttribute("role", "button");
        itemElement.setAttribute(
          "aria-label",
          `${item.artist} - ${item.title}, Position ${index + 1}`
        );

        itemElement.innerHTML = `
          <div class="chronology-item__position">${index + 1}</div>
          <div class="chronology-item__content">
            <div class="chronology-item__title">${item.title}</div>
            <div class="chronology-item__artist">${item.artist}</div>
          </div>
        `;

        itemElement.addEventListener("click", () => this.selectItem(index));
        itemElement.addEventListener("keydown", (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            this.selectItem(index);
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            this.moveItem(-1);
          }
          if (event.key === "ArrowDown") {
            event.preventDefault();
            this.moveItem(1);
          }
        });

        this.itemsContainer.appendChild(itemElement);
      });
    }

    selectItem(index) {
      // Remove previous selection
      const items = this.itemsContainer?.querySelectorAll(".chronology-item");
      items?.forEach((item) => item.classList.remove("chronology-item--selected"));

      // Add new selection
      this.selectedIndex = index;
      const selectedItem = items?.[index];
      if (selectedItem) {
        selectedItem.classList.add("chronology-item--selected");
        selectedItem.focus();
      }

      this.updateControls();
    }

    moveItem(direction) {
      if (this.selectedIndex === -1) {
        // Auto-select first item if none selected
        this.selectItem(0);
        return;
      }

      const newIndex = this.selectedIndex + direction;
      if (newIndex < 0 || newIndex >= this.currentItems.length) {
        return;
      }

      // Swap items
      [this.currentItems[this.selectedIndex], this.currentItems[newIndex]] = [
        this.currentItems[newIndex],
        this.currentItems[this.selectedIndex],
      ];

      // Re-render and maintain selection
      this.renderItems();
      this.selectItem(newIndex);
    }

    updateControls() {
      const hasSelection = this.selectedIndex !== -1;
      const canMoveUp = hasSelection && this.selectedIndex > 0;
      const canMoveDown = hasSelection && this.selectedIndex < this.currentItems.length - 1;

      if (this.moveUpBtn) {
        this.moveUpBtn.disabled = !canMoveUp;
      }
      if (this.moveDownBtn) {
        this.moveDownBtn.disabled = !canMoveDown;
      }
      if (this.submitBtn) {
        this.submitBtn.disabled = this.currentItems.length === 0;
      }
    }

    submitAnswer() {
      const userOrder = this.currentItems.map((item) => item.id);
      const result = evaluateChronologyAnswer(userOrder, this.correctOrder);

      this.score += result.score;
      if (this.scoreDisplay) {
        this.scoreDisplay.textContent = this.score.toString();
      }

      // Show feedback
      this.showFeedback(result);

      // Next round or end game
      if (this.round >= this.totalRounds) {
        this.endGame();
      } else {
        setTimeout(() => {
          this.round++;
          if (this.roundDisplay) {
            this.roundDisplay.textContent = this.round.toString();
          }
          this.loadQuestion();
        }, 2000);
      }
    }

    showFeedback(result) {
      // Create detailed feedback with more information
      const correctOrderWithDetails = this.correctOrder.map((id) => {
        const item = this.currentItems.find((i) => i.id === id);
        if (!item) {
          return "";
        }

        // Include artist, title, and year for comprehensive feedback
        return `${item.artist} - ${item.title} (${item.year})`;
      });

      // Create user order for comparison (with current positions)
      const userOrderWithDetails = this.currentItems.map((item, index) => ({
        position: index + 1,
        artist: item.artist,
        title: item.title,
        year: item.year,
        isCorrectPosition: this.correctOrder[index] === item.id,
      }));

      // Calculate additional statistics
      const accuracy = Math.round((result.correctItems / result.totalItems) * 100);
      const scoreGained = result.score;

      // Dispatch enhanced event for feedback overlay
      const event = new CustomEvent("showChronologyFeedback", {
        detail: {
          isCorrect: result.correctItems === result.totalItems,
          isLastRound: this.round >= this.totalRounds,
          correctOrder: correctOrderWithDetails,
          userOrder: userOrderWithDetails,
          accuracy: accuracy,
          scoreGained: scoreGained,
          totalScore: this.score,
          round: this.round,
          totalRounds: this.totalRounds,
          category: this.category,
          difficulty: this.difficulty,
        },
      });
      window.dispatchEvent(event);
    }

    endGame() {
      // Save game result to database first
      this.saveScoreToDatabase()
        .then(() => {
          // Show end overlay with complete data transfer
          this.showEndOverlay();
        })
        .catch((error) => {
          console.error("Failed to save game result:", error);
          // Still show the overlay even if save failed
          this.showEndOverlay();
        });
    }

    showEndOverlay() {
      const endOverlay = document.getElementById("endgame-popup");
      if (endOverlay) {
        // Set all necessary data attributes for EndOverlay
        endOverlay.dataset.score = this.score.toString();
        endOverlay.dataset.category = this.container?.dataset.categoryName || this.category;
        endOverlay.dataset.difficulty = this.difficulty;

        // Show the overlay first
        endOverlay.classList.remove("hidden");

        // Use a small delay to ensure the overlay is visible before updating
        setTimeout(() => {
          // Trigger the EndOverlay animations and score display
          if (typeof window !== "undefined" && window.showEndOverlay) {
            // Use the EndOverlay utility function to properly show the overlay with animations
            window.showEndOverlay(this.score, this.totalRounds * 100); // Max score based on perfect rounds
          } else {
            // Fallback: manually update score and show overlay
            const scoreElement = document.getElementById("popup-score");
            if (scoreElement) {
              scoreElement.textContent = this.score.toString();
            }

            // Also update the data attribute
            endOverlay.setAttribute("data-score", this.score.toString());
          }
        }, 100);

        // Focus management for accessibility
        setTimeout(() => {
          const popupContent = endOverlay.querySelector(".popup__content");
          if (popupContent) {
            popupContent.focus();
          }
        }, 200);
      }
    }

    async saveScoreToDatabase() {
      try {
        // Calculate correct answers based on average score per round
        const averageScorePerRound = this.score / this.totalRounds;
        const estimatedCorrectAnswers = Math.round((averageScorePerRound / 100) * this.totalRounds);

        const gameData = {
          userId: this.userId,
          categoryName: this.container?.dataset.categoryName || this.category,
          difficulty: this.difficulty,
          score: this.score,
          correctAnswers: estimatedCorrectAnswers,
          totalRounds: this.totalRounds,
        };

        // Use the language-specific API path
        const response = await fetch(`/${this.language}/api/game/save-result`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(gameData),
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || "Failed to save game result");
        }

        const responseData = await response.json();
        return responseData;
      } catch (error) {
        console.error("Error saving game result:", error);
        // Don't throw the error, just log it to avoid breaking the game flow
      }
    }

    showError(messageKey) {
      // Get translation based on current language
      const translations = {
        de: {
          "chronology.error.initialization":
            "Spiel konnte nicht geladen werden. Bitte versuchen Sie es erneut.",
          "chronology.error.question.load":
            "Frage konnte nicht geladen werden. Bitte versuchen Sie es erneut.",
        },
        en: {
          "chronology.error.initialization": "Failed to load game data. Please try again.",
          "chronology.error.question.load": "Failed to load question. Please try again.",
        },
      };

      const message =
        translations[this.language]?.[messageKey] || translations.en[messageKey] || messageKey;
      console.error(message);
      alert(message);
    }
  }

  // Initialize game when DOM is loaded
  document.addEventListener("DOMContentLoaded", () => {
    new ChronologyGame();
  });
</script>

<style is:inline>
  /**
   * Chronology Game Styles
   * Uses CSS variables from global.css for consistent theming
   */

  .chronology-game {
    min-height: 100vh;
    background: var(--bg-primary);
    color: var(--text-primary);
    padding: var(--space-lg);
    max-width: 1200px;
    margin: 0 auto;
  }

  /* Game Header */
  .game-header {
    margin-bottom: var(--space-lg);
    text-align: center;
  }

  .game-info {
    display: flex;
    justify-content: center;
    gap: var(--space-md);
    margin-top: var(--space-md);
    flex-wrap: wrap;
  }

  .badge {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    background: var(--bg-secondary);
    padding: var(--space-sm) var(--space-md);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-secondary);
    transition: all 0.2s ease;
  }

  .badge:hover {
    background: var(--bg-tertiary);
    transform: translateY(-1px);
  }

  .badge__icon {
    width: 16px;
    height: 16px;
    color: var(--interactive-primary);
  }

  .badge__text {
    font-weight: var(--font-medium);
    font-size: var(--text-sm);
  }

  /* Game Content */
  .game-content {
    max-width: 800px;
    margin: 0 auto;
  }

  .game-title {
    font-size: var(--text-2xl);
    font-weight: var(--font-bold);
    text-align: center;
    margin-bottom: var(--space-sm);
    background: var(--btn-primary-bg);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .game-description {
    text-align: center;
    color: var(--text-secondary);
    margin-bottom: var(--space-xl);
    line-height: var(--leading-enhanced);
  }

  /* Chronology Container */
  .chronology-container {
    background: var(--bg-secondary);
    border-radius: var(--radius-xl);
    padding: var(--space-lg);
    margin-bottom: var(--space-lg);
    border: 1px solid var(--border-secondary);
    min-height: 400px;
    position: relative;
  }

  .loading-placeholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 200px;
    color: var(--text-secondary);
  }

  .loading-icon {
    width: 32px;
    height: 32px;
    margin-bottom: var(--space-md);
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }

  /* Chronology Items */
  .chronology-item {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    background: var(--card-bg);
    border: 2px solid var(--border-primary);
    border-radius: var(--radius-lg);
    padding: var(--space-md);
    margin-bottom: var(--space-md);
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
  }

  .chronology-item:last-child {
    margin-bottom: 0;
  }

  .chronology-item:hover {
    border-color: var(--interactive-primary);
    transform: translateY(-2px);
    box-shadow: var(--card-shadow-hover);
  }

  .chronology-item:focus {
    outline: none;
    border-color: var(--interactive-primary);
    box-shadow: var(--focus-ring);
  }

  .chronology-item--selected {
    border-color: var(--interactive-primary);
    background: var(--bg-tertiary);
    box-shadow: var(--card-shadow-hover);
  }

  .chronology-item__position {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    background: var(--interactive-primary);
    color: white;
    border-radius: 50%;
    font-weight: var(--font-bold);
    font-size: var(--text-lg);
    flex-shrink: 0;
  }

  .chronology-item--selected .chronology-item__position {
    background: var(--interactive-secondary);
  }

  .chronology-item__content {
    flex: 1;
    min-width: 0;
  }

  .chronology-item__title {
    font-weight: var(--font-semibold);
    font-size: var(--text-lg);
    margin-bottom: 2px;
    color: var(--text-primary);
  }

  .chronology-item__artist {
    color: var(--text-secondary);
    font-size: var(--text-base);
  }

  /* Game Controls */
  .game-controls {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
    align-items: center;
  }

  .move-buttons {
    display: flex;
    gap: var(--space-md);
  }

  .move-button {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    background: var(--bg-secondary);
    border: 2px solid var(--border-secondary);
    color: var(--text-primary);
    padding: var(--space-md) var(--space-lg);
    border-radius: var(--radius-lg);
    font-weight: var(--font-medium);
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 120px;
    justify-content: center;
  }

  .move-button:not(:disabled):hover {
    background: var(--interactive-primary);
    color: white;
    transform: translateY(-2px);
    box-shadow: var(--card-shadow-hover);
  }

  .move-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background: var(--bg-tertiary);
    color: var(--text-tertiary);
  }

  .move-button__icon {
    width: 18px;
    height: 18px;
  }

  .submit-button {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    background: var(--btn-primary-bg);
    border: none;
    color: white;
    padding: var(--space-md) var(--space-xl);
    border-radius: var(--radius-lg);
    font-weight: var(--font-semibold);
    font-size: var(--text-lg);
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 180px;
    justify-content: center;
  }

  .submit-button:not(:disabled):hover {
    transform: translateY(-2px);
    box-shadow: var(--card-shadow-hover);
  }

  .submit-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .submit-button__icon {
    width: 20px;
    height: 20px;
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .chronology-game {
      padding: var(--space-md);
    }

    .game-info {
      flex-direction: column;
      align-items: center;
    }

    .chronology-item {
      flex-direction: column;
      text-align: center;
      gap: var(--space-sm);
    }

    .chronology-item__content {
      order: -1;
    }

    .move-buttons {
      flex-direction: column;
      width: 100%;
    }

    .move-button,
    .submit-button {
      width: 100%;
      min-width: auto;
    }
  }

  @media (max-width: 480px) {
    .game-title {
      font-size: var(--text-xl);
    }

    .chronology-container {
      padding: var(--space-md);
    }

    .chronology-item {
      padding: var(--space-sm);
    }
  }

  /* Accessibility Enhancements */
  @media (prefers-reduced-motion: reduce) {
    .chronology-item,
    .move-button,
    .submit-button,
    .badge {
      transition: none;
    }

    .loading-icon {
      animation: none;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .chronology-item {
      border-width: 3px;
    }

    .chronology-item:focus {
      border-width: 4px;
      box-shadow: 0 0 0 2px var(--interactive-primary);
    }
  }

  /* Focus management for keyboard users */
  .chronology-item:focus-visible,
  .move-button:focus-visible,
  .submit-button:focus-visible {
    outline: 3px solid var(--interactive-primary);
    outline-offset: 2px;
  }
</style>
