---
import Layout from "@layouts/Layout.astro";
import { getTitleBasedOnDifficulty } from "@utils/getTitleBasedOnDifficulty";
import GameHeadline from "@components/Game/GameHeadline.astro";
import EndOverlay from "@components/Overlays/EndOverlay.astro";
import LoadingSpinner from "@components/Game/LoadingSpinner.astro";
import ErrorMessage from "@components/Shared/ErrorMessage.astro";
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import type { Difficulty as GameDifficulty } from "@utils/game/jokerUtils";
import { Icon } from "astro-icon/components";
import ChronologyFeedbackOverlay from "@components/Overlays/ChronologyFeedbackOverlay.astro";
import { requireAuth } from "../../../middleware/auth.js";

const lang = getLangFromUrl(Astro.url) as string;
const t = useTranslations(lang);
const { category, difficulty } = Astro.params;

// Auth-Check: Prüfe, ob der Benutzer angemeldet ist
const authResult = await requireAuth(Astro.request);
if (!authResult.authenticated && authResult.redirectToLogin) {
  return authResult.redirectToLogin;
}

// Dynamic import of categories based on language with optimized error handling
let categories;
try {
  categories = await import(`@json/${lang}_categories.json`);
} catch (error) {
  // Fallback to default language if the specific language file doesn't exist
  categories = await import(`@json/de_categories.json`);
}

// Default user for game functionality
const user = { id: authResult.user?.id || "guest" };

// Find current category data to use in page metadata and title
const currentCategoryData = categories.default.find((cat: any) => cat.slug === category);

// Get custom player title based on difficulty for personalized experience
const playerTitle = getTitleBasedOnDifficulty(difficulty as GameDifficulty);

// Generate SEO-friendly meta description that includes game mode and category
const metaDescription = `${t("game.chronology.meta.description") || "Musik-Chronologie Spiel:"} ${currentCategoryData?.headline || ""} ${t("game.meta.difficulty") || "im Schwierigkeitsgrad"} ${t(`difficulty.${difficulty}`) || difficulty}`;

console.log(
  `User ${user.id} is playing Chronology in category ${category} with difficulty ${difficulty}`
);
---

<Layout
  title={`${t("game.chronology.title")} - ${currentCategoryData?.headline}`}
  showHeader={false}
  showCoins={false}
>
  <ChronologyFeedbackOverlay />

  <EndOverlay
    id="endgame-popup"
    data-score="0"
    data-category={currentCategoryData?.headline || ""}
    data-difficulty={difficulty || ""}
  />

  <div class="mb-6 md:mb-8">
    <GameHeadline headline={currentCategoryData?.headline} />

    <!-- Game info badges -->
    <div class="mt-4 flex flex-wrap items-center justify-center gap-3" aria-live="polite">
      <div
        class="inline-flex items-center rounded-xl border border-zinc-700 bg-gradient-to-r from-zinc-800 to-zinc-900 px-3 py-1 shadow-sm"
      >
        <Icon name="difficulty" class="mr-2 h-4 w-4 text-yellow-400" aria-hidden="true" />
        <span class="text-base font-medium text-zinc-100">
          {t(`difficulty.${difficulty}`)}
        </span>
      </div>

      <div
        class="inline-flex items-center rounded-xl border border-zinc-700 bg-gradient-to-r from-zinc-800 to-zinc-900 px-3 py-1 shadow-sm"
      >
        <Icon name="coins" class="mr-2 h-4 w-4 text-amber-400" aria-hidden="true" />
        <span class="text-base font-medium text-zinc-100">
          <span id="coins-display" class="coinsCount">0</span>
        </span>
      </div>
    </div>
  </div>

  <ErrorMessage />

  <LoadingSpinner />

  <div
    id="chronology-container"
    class="mx-auto w-full max-w-3xl rounded-xl border border-zinc-700 bg-gradient-to-b from-zinc-800 to-zinc-900 p-6 text-center opacity-100 shadow-xl transition-all duration-500 data-[hidden=true]:opacity-0 md:p-8"
    role="main"
    aria-label={t("game.chronology.area.label") || "Chronologie-Spielbereich"}
    data-categoryName={currentCategoryData?.headline}
    data-genre={category}
    data-userID={user.id}
    date-difficulty={difficulty}
  >
    {
      playerTitle && (
        <div class="mb-4 text-center">
          <span class="inline-flex items-center rounded-xl border border-zinc-700 bg-gradient-to-r from-zinc-800 to-zinc-900 px-3 py-1 text-sm shadow-sm">
            <Icon name="trophy" class="mr-2 h-4 w-4 text-yellow-400" aria-hidden="true" />
            <span class="text-zinc-300">{playerTitle}</span>
          </span>
        </div>
      )
    }

    <h2 class="mb-6 text-xl leading-relaxed font-bold text-white md:text-2xl" id="chronology-title">
      {t("game.chronology.title") || "Musik-Chronologie"}
    </h2>

    <p class="mb-6 text-center text-zinc-300" id="chronology-description">
      {
        t("game.chronology.description") ||
          "Ordne diese Alben nach ihrem Erscheinungsjahr (ältestes zuerst)"
      }
    </p>

    <div
      class="chronology-items mb-8 min-h-[300px] space-y-3"
      id="chronology-items-container"
      aria-live="polite"
    >
      <!-- Items werden per JavaScript hinzugefügt -->
      <div class="chronology-placeholder text-center text-zinc-400">
        <Icon name="loader" class="mx-auto h-8 w-8 animate-spin" />
        <p class="mt-2">{t("loading.content")}</p>
      </div>
    </div>

    <div class="flex justify-center">
      <button
        id="chronology-submit"
        class="rounded-full bg-gradient-to-r from-purple-600 to-indigo-600 px-6 py-3 font-bold text-white transition-all hover:scale-105 disabled:cursor-not-allowed disabled:opacity-50"
        disabled
      >
        {t("game.submit.answer") || "Antwort überprüfen"}
      </button>
    </div>
  </div>
</Layout>

<script>
  /**
   * Music Chronology Game Mode
   *
   * This game mode challenges players to correctly order albums/songs chronologically.
   * Players receive points based on accuracy of their ordering and are rewarded for perfectly ordered sequences.
   */
  import { ErrorHandler } from "@utils/error/errorHandler";
  import {
    generateChronologyQuestion,
    evaluateChronologyAnswer,
  } from "@utils/game/chronologyGameMode";
  import { handleEndGame, restartGame } from "@utils/game/endGameUtils";
  import type { Album } from "@utils/game/getRandomQuestion";
  import { Difficulty } from "@utils/game/jokerUtils";
  import { getLangFromUrl, useTranslations } from "@utils/i18n";
  import { QueueManager } from "@utils/queue/queueManager";
  import Sortable from "sortablejs";

  /**
   * Get current language from URL and initialize translations
   */
  const lang = getLangFromUrl(new URL(window.location.pathname, window.location.origin)) as string;
  const t = useTranslations(lang);

  /**
   * Configuration constants for number of rounds based on difficulty level
   * Easy: 10 rounds, Medium: 15 rounds, Hard: 20 rounds
   */
  const ROUNDS_PER_DIFFICULTY = {
    [Difficulty.EASY]: 10,
    [Difficulty.MEDIUM]: 15,
    [Difficulty.HARD]: 20,
  } as const;

  /**
   * Validates and normalizes the difficulty level from URL parameters
   * @param {string|null} diff - The difficulty string from URL
   * @returns {Difficulty} Normalized difficulty enum value
   */
  const validateDifficulty = (diff: string | null): Difficulty => {
    if (diff === "easy") {
      return Difficulty.EASY;
    }
    if (diff === "medium") {
      return Difficulty.MEDIUM;
    }
    if (diff === "hard") {
      return Difficulty.HARD;
    }
    return Difficulty.EASY;
  };

  /**
   * Number of items to be sorted per difficulty level
   * This determines how many albums will be presented for chronological ordering
   */
  const ITEMS_PER_DIFFICULTY = {
    [Difficulty.EASY]: 4,
    [Difficulty.MEDIUM]: 4,
    [Difficulty.HARD]: 4,
  };

  /**
   * Interface for DOM elements required by the game controller
   * Centralizes element references to improve code organization and performance
   */
  interface ChronologyGameElements {
    itemsContainer: HTMLElement;
    submitButton: HTMLButtonElement;
    coinsDisplay: HTMLElement;
    loadingSpinner: HTMLElement;
    chronologyContainer: HTMLElement;
    endGamePopup: HTMLElement;
    roundElement: HTMLElement; // For displaying current round
  }

  /**
   * Caches DOM elements to avoid repeated queries and improve performance
   * @returns {ChronologyGameElements} Object containing all required DOM elements
   */
  function cacheElements(): ChronologyGameElements {
    return {
      itemsContainer: document.getElementById("chronology-items-container") as HTMLElement,
      submitButton: document.getElementById("chronology-submit") as HTMLButtonElement,
      coinsDisplay: document.querySelector(".coinsCount") as HTMLElement,
      loadingSpinner: document.getElementById("loading-spinner") as HTMLElement,
      chronologyContainer: document.getElementById("chronology-container") as HTMLElement,
      endGamePopup: document.getElementById("endgame-popup") as HTMLElement,
      roundElement: document.querySelector(".round") as HTMLElement,
    };
  }

  /**
   * Main controller class for the Chronology game
   * Handles game initialization, state management, user interactions, and scoring
   */
  class ChronologyGameController {
    private elements: ChronologyGameElements;
    private sortable: Sortable | null = null;
    private albums: Album[] = [];
    private currentQuestion: any = null;
    private score: number = 0;
    private roundIndex: number = 0;
    private correctAnswers: number = 0;
    private totalRounds: number = 10;
    private difficulty: Difficulty;
    private category: string;
    private categoryName: string;
    private userId: string;

    /**
     * Constructor initializes the game controller with required DOM elements
     * and sets up game parameters based on URL and container attributes
     * @param {ChronologyGameElements} elements - Cached DOM elements
     */
    constructor(elements: ChronologyGameElements) {
      this.elements = elements;

      const container = this.elements.chronologyContainer;
      this.category = container.getAttribute("data-genre") || "";
      this.userId = container.getAttribute("data-userID") || "guest";
      this.categoryName = container.getAttribute("data-categoryName") || "";
      this.difficulty = validateDifficulty(container.getAttribute("date-difficulty"));

      this.totalRounds = ROUNDS_PER_DIFFICULTY[this.difficulty] || ROUNDS_PER_DIFFICULTY.EASY;

      // Initialize round display
      this.updateRoundDisplay();

      // Check for seasonal events
      this.checkForSeasonalEvent();

      this.initEventListeners();
    }

    /**
     * Checks if there is an active seasonal event based on current date
     * Used for seasonal achievements and special game features
     */
    private checkForSeasonalEvent() {
      // This could come from an API call or configuration
      const currentDate = new Date();
      const month = currentDate.getMonth() + 1; // 1-12

      // Example of seasonal events
      if (month === 12) {
        ChronologyGameController.currentEventId = "winter_2025";
      } else if (month >= 6 && month <= 8) {
        ChronologyGameController.currentEventId = "summer_2025";
      }
    }

    /**
     * Initializes event listeners for game interactions
     * Sets up handlers for button clicks and game restart
     */
    private initEventListeners() {
      // Submit button
      this.elements.submitButton.addEventListener("click", () => this.handleSubmit());

      // Restart button in endgame popup
      const restartButton = document.getElementById("restart-button");
      if (restartButton) {
        restartButton.addEventListener("click", restartGame);
      }
    }

    /**
     * Loads album data for the selected category with language fallback
     * Attempts to load data for current language, falls back to German if unavailable
     * @returns {Promise<boolean>} True if album data was successfully loaded
     */
    public async loadAlbums(): Promise<boolean> {
      try {
        let albumsData;

        try {
          // Versuche zuerst, Alben für die aktuelle Sprache zu laden
          const response = await fetch(`/json/genres/${String(lang)}/${this.category}.json`);

          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          albumsData = await response.json();
        } catch (langError) {
          // Fallback auf Deutsch, wenn die spezifische Sprachdatei nicht existiert
          console.log(`No albums found for ${lang}/${this.category}, falling back to German`);

          const fallbackResponse = await fetch(`/json/genres/de/${this.category}.json`);

          if (!fallbackResponse.ok) {
            throw new Error(`HTTP error for fallback! Status: ${fallbackResponse.status}`);
          }

          albumsData = await fallbackResponse.json();
        }

        this.albums = albumsData;

        if (!this.albums?.length) {
          throw new Error(t("error.no.albums.found"));
        }

        return true;
      } catch (error) {
        console.error("Error loading albums:", error);
        ErrorHandler.handleApiError(error instanceof Error ? error : new Error(String(error)));
        return false;
      }
    }

    /**
     * Starts the game and displays the first question
     * Shows loading spinner during initialization
     */
    public async startGame() {
      this.showLoadingSpinner(true);

      // Alben laden
      const success = await this.loadAlbums();
      if (!success) {
        this.showLoadingSpinner(false);
        return;
      }

      // Erste Frage generieren und anzeigen
      this.loadNextQuestion();

      this.showLoadingSpinner(false);
    }

    /**
     * Shows/hides the loading spinner
     * @param {boolean} show - Whether to show or hide the spinner
     */
    private showLoadingSpinner(show: boolean) {
      if (this.elements.loadingSpinner) {
        if (show) {
          this.elements.loadingSpinner.classList.remove("hidden");
        } else {
          this.elements.loadingSpinner.classList.add("hidden");
        }
      }
    }

    /**
     * Tracking variable for achievement timing
     * Measures time taken to answer questions for speed bonuses
     */
    private questionStartTime: number = 0;

    /**
     * Generates and loads the next chronology question
     * Resets the container, initializes question timer, and renders the question
     */
    private loadNextQuestion() {
      // Alle Items zurücksetzen
      if (this.elements.itemsContainer) {
        this.elements.itemsContainer.innerHTML = "";
      }

      // Startzeit für Achievement-Tracking speichern
      this.questionStartTime = Date.now();

      // Frage für aktuellen Schwierigkeitsgrad generieren
      this.currentQuestion = generateChronologyQuestion(this.albums, this.difficulty);

      if (!this.currentQuestion) {
        ErrorHandler.handleApiError(
          new Error("Keine gültige Chronologie-Frage konnte generiert werden")
        );
        return;
      }

      // Frage anzeigen
      this.renderQuestion();

      // Submit-Button aktivieren
      if (this.elements.submitButton) {
        this.elements.submitButton.disabled = false;
      }

      // Rundenanzeige aktualisieren
      this.updateRoundDisplay();
    }

    /**
     * Renders the chronology question in the container
     * Creates sortable list items representing albums to be ordered
     */
    private renderQuestion() {
      if (!this.elements.itemsContainer || !this.currentQuestion) {
        return;
      }

      const container = this.elements.itemsContainer;
      container.innerHTML = "";

      // Erstelle sortierbare Liste
      const list = document.createElement("ul");
      list.className = "chronology-list space-y-3";
      list.setAttribute("aria-label", "Sortierbare Liste von Alben");

      // Füge Items hinzu
      this.currentQuestion.items.forEach((item: any, index: number) => {
        const li = document.createElement("li");
        li.className =
          "chronology-item bg-zinc-900 p-4 rounded-lg border border-zinc-700 flex items-center cursor-move";
        li.setAttribute("data-id", item.id.toString());
        li.setAttribute("aria-grabbed", "false");
        li.setAttribute("tabindex", "0");

        // Handle-Icon
        const handle = document.createElement("div");
        handle.className = "drag-handle mr-3 text-zinc-400";
        handle.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>`;
        handle.setAttribute("aria-hidden", "true");

        // Content
        const content = document.createElement("div");
        content.className = "flex-1";

        const artistName = document.createElement("div");
        artistName.className = "font-bold text-white";
        artistName.textContent = item.artist;

        const albumTitle = document.createElement("div");
        albumTitle.className = "text-zinc-300";
        albumTitle.textContent = item.title;

        content.appendChild(artistName);
        content.appendChild(albumTitle);

        // Position number (for accessibility)
        const position = document.createElement("div");
        position.className = "chronology-position ml-auto text-xl font-bold text-zinc-500";
        position.textContent = (index + 1).toString();
        position.setAttribute("aria-hidden", "true");

        // Assemble
        li.appendChild(handle);
        li.appendChild(content);
        li.appendChild(position);

        list.appendChild(li);
      });

      container.appendChild(list);

      // Enable Sortable.js
      this.initSortable(list);

      // Announce for screen readers
      const announcement = document.createElement("div");
      announcement.className = "sr-only";
      announcement.setAttribute("aria-live", "polite");
      announcement.textContent = `Neue Aufgabe geladen: ${this.currentQuestion.items.length} Alben in chronologische Reihenfolge bringen.`;
      container.appendChild(announcement);

      // Remove announcement after it's been read
      setTimeout(() => announcement.remove(), 1000);
    }

    /**
     * Initializes the Sortable.js functionality
     * Sets up drag and drop ordering with proper accessibility
     * @param {HTMLElement} element - The container element for sortable items
     */
    private initSortable(element: HTMLElement) {
      this.sortable = new Sortable(element, {
        animation: 150,
        handle: ".drag-handle",
        ghostClass: "sortable-ghost",
        chosenClass: "sortable-chosen",
        dragClass: "sortable-drag",
        onEnd: () => {
          this.updatePositionNumbers();
        },
      });

      // Initial position numbers
      this.updatePositionNumbers();

      // Add keyboard accessibility
      this.addKeyboardSorting(element);
    }

    /**
     * Updates the displayed position numbers
     * Called after drag operations to maintain visual position indicators
     */
    private updatePositionNumbers() {
      if (!this.elements.itemsContainer) {
        return;
      }

      const items = this.elements.itemsContainer.querySelectorAll(".chronology-item");
      items.forEach((item, index) => {
        const position = item.querySelector(".chronology-position");
        if (position) {
          position.textContent = (index + 1).toString();
        }
      });
    }

    /**
     * Adds keyboard support for sorting
     * Enables accessibility for users who navigate with keyboard
     * @param {HTMLElement} listElement - The container for sortable items
     */
    private addKeyboardSorting(listElement: HTMLElement) {
      let items = listElement.querySelectorAll(".chronology-item");

      // Hilfsinstruktionen für Tastaturnutzer hinzufügen
      const keyboardInstructions = document.createElement("div");
      keyboardInstructions.className = "keyboard-instructions text-sm text-zinc-400 mt-2 mb-4";
      keyboardInstructions.innerHTML = `
        <span class="sr-only">${t("game.chronology.drag.help") || "Nutze die Pfeiltasten ↑/↓ oder Drag & Drop zum Sortieren"}</span>
        <div class="flex flex-wrap justify-center gap-2 text-xs">
          <span class="inline-flex items-center px-2 py-1 bg-zinc-800 rounded">
            <kbd class="px-1 py-0.5 mr-1 bg-zinc-700 rounded text-zinc-300">↑</kbd><span>${t("game.chronology.up") || "Nach oben"}</span>
          </span>
          <span class="inline-flex items-center px-2 py-1 bg-zinc-800 rounded">
            <kbd class="px-1 py-0.5 mr-1 bg-zinc-700 rounded text-zinc-300">↓</kbd><span>${t("game.chronology.down") || "Nach unten"}</span>
          </span>
          <span class="inline-flex items-center px-2 py-1 bg-zinc-800 rounded">
            <kbd class="px-1 py-0.5 mr-1 bg-zinc-700 rounded text-zinc-300">1-${items.length}</kbd><span>${t("game.chronology.position") || "Position"}</span>
          </span>
          <span class="inline-flex items-center px-2 py-1 bg-zinc-800 rounded">
            <kbd class="px-1 py-0.5 mr-1 bg-zinc-700 rounded text-zinc-300">Home</kbd><span>${t("game.chronology.start") || "Anfang"}</span>
          </span>
          <span class="inline-flex items-center px-2 py-1 bg-zinc-800 rounded">
            <kbd class="px-1 py-0.5 mr-1 bg-zinc-700 rounded text-zinc-300">End</kbd><span>${t("game.chronology.end") || "Ende"}</span>
          </span>
        </div>
      `;
      listElement.parentNode?.insertBefore(keyboardInstructions, listElement);

      // Jeden Eintrag für Tastatursteuerung vorbereiten
      items.forEach((item) => {
        // Setze Tabindex für Fokussierbarkeit
        item.setAttribute("tabindex", "0");

        // Füge Rollenbeschreibung für Screenreader hinzu
        item.setAttribute("role", "listitem");
        item.setAttribute(
          "aria-label",
          `Element ${item.querySelector(".font-bold")?.textContent} - ${item.querySelector(".text-zinc-300")?.textContent}. Nutze Pfeiltasten zum Umordnen.`
        );

        item.addEventListener("keydown", (e) => {
          const key = (e as KeyboardEvent).key;

          // Aktualisiere die Elementliste vor jeder Operation
          // Dies ist entscheidend, da die DOM-Struktur sich nach Verschiebungen ändert
          items = listElement.querySelectorAll(".chronology-item");
          const currentIndex = Array.from(items).indexOf(item as HTMLElement);

          let newIndex = currentIndex;
          let moved = false;

          // ARIA-Announcement vorbereiten
          const artistName = item.querySelector(".font-bold")?.textContent || "";
          const albumTitle = item.querySelector(".text-zinc-300")?.textContent || "";
          const itemDescription = `${artistName} - ${albumTitle}`;

          // Verhindere Scrollen mit Pfeiltasten
          if (["ArrowUp", "ArrowDown", "Home", "End"].includes(key)) {
            e.preventDefault();
          }

          // Funktion, um ein Element an einer bestimmten Position einzufügen
          const moveToPosition = (targetIndex: number) => {
            // Sicherheitscheck für Index-Grenzen
            if (targetIndex < 0) {
              targetIndex = 0;
            }
            if (targetIndex >= items.length) {
              targetIndex = items.length - 1;
            }

            if (targetIndex === currentIndex) {
              return false;
            } // Keine Änderung nötig

            // DOM-Element für die Zielposition
            const targetElement = items[targetIndex] as HTMLElement;

            if (targetIndex < currentIndex) {
              // Nach oben verschieben - vor das Zielelement einfügen
              listElement.insertBefore(item, targetElement);
            } else {
              // Nach unten verschieben - nach dem Zielelement einfügen
              const nextElement = items[targetIndex + 1] as HTMLElement;
              if (nextElement) {
                listElement.insertBefore(item, nextElement);
              } else {
                listElement.appendChild(item);
              }
            }

            return true;
          };

          if (key === "ArrowUp" && currentIndex > 0) {
            // Nach oben verschieben
            moved = moveToPosition(currentIndex - 1);
            newIndex = currentIndex - 1;
          } else if (key === "ArrowDown" && currentIndex < items.length - 1) {
            // Nach unten verschieben
            moved = moveToPosition(currentIndex + 1);
            newIndex = currentIndex + 1;
          } else if (key === "Home") {
            // An den Anfang verschieben
            moved = moveToPosition(0);
            newIndex = 0;
          } else if (key === "End") {
            // An das Ende verschieben
            moved = moveToPosition(items.length - 1);
            newIndex = items.length - 1;
          } else if (/^[1-9]$/.test(key) && parseInt(key) <= items.length) {
            // Direktes Springen zu einer Position mit Zifferntasten
            // Index ist um 1 verschoben (Benutzer sieht 1-basierte Indizes)
            const targetIndex = parseInt(key) - 1;
            moved = moveToPosition(targetIndex);
            newIndex = targetIndex;
          }

          if (moved) {
            // Aktualisiere Listenelemente nach der Verschiebung
            items = listElement.querySelectorAll(".chronology-item");

            // Neupositionierung visuell anzeigen
            this.updatePositionNumbers();

            // Fokus beibehalten und Element hervorheben
            requestAnimationFrame(() => {
              (item as HTMLElement).focus();
              this.highlightElement(item as HTMLElement);
            });

            // Screenreader-Announcement
            const announcement = document.createElement("div");
            announcement.className = "sr-only";
            announcement.setAttribute("aria-live", "assertive");
            announcement.textContent = `${itemDescription} wurde auf Position ${newIndex + 1} von ${items.length} verschoben.`;
            document.body.appendChild(announcement);

            // Entferne das Announcement nach kurzer Zeit
            setTimeout(() => announcement.remove(), 1000);
          }
        });

        // Visuelles Feedback für Tastatur-Fokus
        item.addEventListener("focus", () => {
          // Setze ARIA-Attribute für bessere Screenreader-Unterstützung
          item.setAttribute("aria-grabbed", "true");

          // Visuelles Feedback
          this.highlightElement(item as HTMLElement);
        });

        item.addEventListener("blur", () => {
          item.setAttribute("aria-grabbed", "false");
          item.classList.remove("ring-2", "ring-purple-500", "ring-offset-1", "bg-purple-900/20");
        });
      });
    }

    /**
     * Visually highlights an element to indicate focus
     * Provides visual feedback for keyboard navigation
     * @param {HTMLElement} element - The element to highlight
     */
    private highlightElement(element: HTMLElement) {
      // Entferne Hervorhebung von allen Elementen
      const allItems = this.elements.itemsContainer?.querySelectorAll(".chronology-item") || [];
      allItems.forEach((item) => {
        item.classList.remove("ring-2", "ring-purple-500", "ring-offset-1", "bg-purple-900/20");
      });

      // Hervorhebung für das fokussierte Element
      element.classList.add("ring-2", "ring-purple-500", "ring-offset-1", "bg-purple-900/20");

      // Pulse-Animation für besseres visuelles Feedback
      element.animate(
        [{ transform: "scale(1)" }, { transform: "scale(1.02)" }, { transform: "scale(1)" }],
        {
          duration: 300,
          easing: "ease-in-out",
        }
      );
    }

    /**
     * Processes the player's submission
     * Evaluates answer, updates score, and handles game progression
     */
    private handleSubmit() {
      if (!this.elements.itemsContainer || !this.currentQuestion) {
        return;
      }

      // Antwortzeit für Achievement-Tracking speichern
      const answerTime = Date.now() - this.questionStartTime;
      this.lastAnswerTime = answerTime;

      const items = this.elements.itemsContainer.querySelectorAll(".chronology-item");
      const userOrder = Array.from(items).map((item) =>
        parseInt(item.getAttribute("data-id") || "0")
      );

      const result = evaluateChronologyAnswer(userOrder, this.currentQuestion.correctOrder);

      // Punktestand aktualisieren
      this.score += result.score;
      this.updateCoinsDisplay(this.score);

      // Wenn perfekte Antwort
      if (result.correctItems === result.totalItems) {
        this.correctAnswers++;
        this.lastAnswerCorrect = true;
      } else {
        this.lastAnswerCorrect = false;
      }

      // Ergebnis anzeigen
      this.showResults(result, userOrder);

      // Submit-Button deaktivieren
      if (this.elements.submitButton) {
        this.elements.submitButton.disabled = true;
      }

      // Sortierbarkeit deaktivieren
      if (this.sortable) {
        this.sortable.option("disabled", true);
      }

      // Nächste Runde oder Spiel beenden
      if (this.roundIndex < this.totalRounds - 1) {
        setTimeout(() => {
          this.roundIndex++;
          // Rundenanzeige wird in loadNextQuestion aktualisiert
          this.loadNextQuestion();
        }, 3000);
      } else {
        setTimeout(() => {
          this.endGame();
        }, 3000);
      }
    }

    /**
     * Updates the coin display with animation for visual feedback
     * @param {number} newScore - The updated score to display
     */
    private updateCoinsDisplay(newScore: number) {
      if (this.elements.coinsDisplay) {
        // Animation-Klasse für visuelles Feedback anwenden
        this.elements.coinsDisplay.classList.add("coins-updated");
        this.elements.coinsDisplay.textContent = newScore.toString();

        // Punkteänderung für Screenreader ankündigen
        const announcement = document.createElement("div");
        announcement.setAttribute("aria-live", "assertive");
        announcement.classList.add("sr-only");
        announcement.textContent = `Neuer Punktestand: ${newScore} Punkte`;
        document.body.appendChild(announcement);

        // Animation-Klasse und Ankündigung entfernen, nachdem sie abgeschlossen sind
        setTimeout(() => {
          this.elements.coinsDisplay.classList.remove("coins-updated");
          announcement.remove();
        }, 1500);
      }
    }

    /**
     * Updates the round display
     * Shows current round number and total rounds
     */
    private updateRoundDisplay() {
      if (this.elements.roundElement) {
        this.elements.roundElement.textContent = `${this.roundIndex + 1}/${this.totalRounds}`;
      }
    }

    /**
     * Displays the results of the chronology task
     * Shows correct/incorrect positions and year information
     * @param {any} result - The evaluation result
     * @param {number[]} userOrder - The order submitted by the user
     */
    private showResults(result: any, userOrder: number[]) {
      if (!this.elements.itemsContainer || !this.currentQuestion) {
        return;
      }

      // Korrekte/falsche Items markieren
      const items = this.elements.itemsContainer.querySelectorAll(".chronology-item");

      items.forEach((item, index) => {
        const id = parseInt(item.getAttribute("data-id") || "0");
        const correctIndex = this.currentQuestion.correctOrder.indexOf(id);

        // Status-Badge hinzufügen
        const badge = document.createElement("div");
        badge.className = "absolute top-2 right-2 text-xs px-2 py-1 rounded-full";

        if (correctIndex === index) {
          // Korrekte Position
          item.classList.add("border-green-500");
          badge.className += " bg-green-500/20 text-green-300";
          badge.textContent = "Korrekt";
        } else {
          // Falsche Position
          item.classList.add("border-red-500");
          badge.className += " bg-red-500/20 text-red-300";
          badge.textContent = `Sollte an Position ${correctIndex + 1} sein`;
        }

        // Jahr anzeigen
        const matchingItem = this.currentQuestion.items.find((i: any) => i.id === id);
        const content = item.querySelector(".chronology-item > div:nth-child(2)");
        if (content && matchingItem) {
          const yearElement = document.createElement("div");
          yearElement.className = "mt-1 text-sm font-bold";
          yearElement.textContent = `${matchingItem.year}`;
          content.appendChild(yearElement);
        }

        // Positionsklasse hinzufügen
        (item as HTMLElement).style.position = "relative";
        item.appendChild(badge);
      });

      // Ergebnis-Box anzeigen
      const resultBox = document.createElement("div");
      resultBox.className = "mt-6 p-4 rounded-lg bg-zinc-900 border border-zinc-700 text-center";

      const scoreHeading = document.createElement("h3");
      scoreHeading.className = "text-lg font-bold";
      scoreHeading.textContent = `Ergebnis: ${result.score} Punkte`;

      const scoreDetails = document.createElement("p");
      scoreDetails.className = "text-zinc-300";
      scoreDetails.textContent = `${result.correctItems} von ${result.totalItems} Alben korrekt platziert`;

      resultBox.appendChild(scoreHeading);
      resultBox.appendChild(scoreDetails);

      this.elements.itemsContainer.appendChild(resultBox);
    }

    /**
     * Variables for achievement tracking
     * Used to track game performance for awarding achievements
     */
    private lastAnswerTime: number = 0;
    private lastAnswerCorrect: boolean = false;
    private static currentEventId?: string;

    /**
     * Ends the game and shows the summary
     * Calculates final score and triggers achievement evaluation
     */
    private endGame() {
      const config = {
        userId: this.userId,
        categoryName: this.categoryName,
        difficulty: this.difficulty,
        totalRounds: this.totalRounds,
        correctAnswers: this.correctAnswers,
        score: this.score,
        language: lang,

        // Erweiterte Eigenschaften für Achievement-Tracking
        genreId: this.category, // Kategorie/Genre-ID für genre_explorer
        lastAnswerTime: this.lastAnswerTime, // Letzte Antwortzeit für quick_answer
        lastAnswerCorrect: this.lastAnswerCorrect, // Ob die letzte Antwort korrekt war
        eventId: ChronologyGameController.currentEventId, // Event-ID für seasonal_event
        endOfSession: true, // Ende der Spielsitzung für game_series
      };

      const ui = {
        showEndgamePopup: (score: number) => {
          if (this.elements.endGamePopup) {
            const scoreElement = this.elements.endGamePopup.querySelector("#popup-score");

            if (scoreElement) {
              scoreElement.textContent = score.toString();
              this.elements.endGamePopup.setAttribute("data-score", score.toString());
              this.elements.endGamePopup.classList.remove("hidden");
            }
          }
        },
      };

      handleEndGame(config, ui, {
        onError: (error) => {
          ErrorHandler.handleSaveError(error, "score", {
            userId: config.userId,
            category: config.categoryName,
          });
        },
      });
    }
  }

  /**
   * Initialize the game when the DOM is ready
   * Creates game controller instance and starts the game
   */
  document.addEventListener("DOMContentLoaded", async () => {
    const elements = cacheElements();

    // Check if all required elements are present
    if (!elements.itemsContainer || !elements.submitButton || !elements.chronologyContainer) {
      console.error("Required DOM elements not found");
      return;
    }

    // Initialize achievement event system
    try {
      // Dynamic import for the achievement system
      const achievementModule = await import("../../../utils/achievements/achievementEvents.js");
      achievementModule.initAchievementEventSystem();
      console.log("Achievement event system initialized for game mode");
    } catch (error) {
      console.error("Error initializing achievement event system:", error);
    }

    // Create and start the game controller
    const gameController = new ChronologyGameController(elements);
    gameController.startGame();

    // Warn before leaving if there is unsaved data
    window.addEventListener("beforeunload", (e) => {
      if (QueueManager.hasUnsavedData()) {
        e.preventDefault();
      }
    });
  });
</script>

<style is:global>
  /* Sortable.js Styling */
  .sortable-ghost {
    opacity: 0.5;
    background-color: rgba(255, 255, 255, 0.1) !important;
  }

  .sortable-chosen {
    background-color: rgba(139, 92, 246, 0.2) !important;
  }

  .chronology-item:focus {
    outline: 2px solid #a855f7;
    outline-offset: 2px;
  }

  /* Reduzierte Bewegung bevorzugt */
  @media (prefers-reduced-motion: reduce) {
    .sortable-ghost,
    .sortable-chosen,
    .sortable-drag {
      transition: none !important;
    }
  }

  /* Siehe auch die anderen Stile aus der Hauptspieldatei, die wiederverwendet werden können */
  .overlay.hidden {
    @apply hidden;
  }

  .popup.hidden {
    @apply hidden;
  }

  /* Für ältere Browser, die data-hidden noch nicht unterstützen */
  #chronology-container.hidden {
    @apply opacity-0;
  }

  /* Disabled button styling */
  button[disabled] {
    @apply cursor-not-allowed opacity-50;
  }

  /* High Contrast Mode Support */
  @media (forced-colors: active) {
    #chronology-container {
      border: 2px solid CanvasText;
    }

    .chronology-item {
      border: 1px solid ButtonText;
      forced-color-adjust: none;
    }

    .chronology-item:focus-visible {
      outline: 3px solid Highlight;
    }

    button[disabled] {
      opacity: 0.6;
    }
  }

  /* Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    *,
    ::before,
    ::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }
  }

  /* Focus styles for better keyboard navigation */
  :focus-visible {
    outline: 3px solid #a855f7 !important;
    outline-offset: 3px !important;
  }

  /* Animation für Coins-Aktualisierung */
  .coins-updated {
    animation: coinPulse 1s ease-in-out;
    color: #fbbf24; /* Helleres Amber für bessere Sichtbarkeit */
  }

  @keyframes coinPulse {
    0% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.25);
      color: #f59e0b;
    }
    100% {
      transform: scale(1);
    }
  }
</style>
