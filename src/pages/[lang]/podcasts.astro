---
import Layout from "@layouts/Layout.astro";
import { useTranslations } from "@utils/i18n";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import AudioPlayer from "@components/AudioPlayer.astro";
import { Icon } from "astro-icon/components";

// Statische Generierung für alle unterstützten Sprachen aktivieren
export const prerender = true;

// Definieren der unterstützten Sprachen und Erstellung der statischen Pfade
export async function getStaticPaths() {
  const supportedLanguages = [
    "de",
    "en",
    "es",
    "fr",
    "it",
    "pt",
    "da",
    "nl",
    "sv",
    "fi",
  ] as const;

  // Vorverarbeiten der Podcast-Daten für jede Sprache
  const paths = await Promise.all(
    supportedLanguages.map(async (lang) => {
      // Versuchen, die Podcast-Daten für die Sprache zu laden
      let podcasts = [];
      try {
        const podcastData = await import(
          `../../../public/json/podcasts/${lang}.json`
        );
        podcasts = podcastData.default;
      } catch (error) {
        // Fallback auf Englisch, wenn die Sprachdatei nicht existiert
        try {
          const fallbackData = await import(
            `../../../public/json/podcasts/en.json`
          );
          podcasts = fallbackData.default;
        } catch (fallbackError) {
          console.error(
            `Fehler beim Laden der Podcast-Daten für ${lang}:`,
            fallbackError,
          );
        }
      }

      return {
        params: { lang },
        props: {
          lang,
          podcasts,
        },
      };
    }),
  );

  return paths;
}

// Typdefinition für die Props
interface Props {
  lang: "de" | "en" | "es" | "fr" | "it" | "pt" | "da" | "nl" | "sv" | "fi";
  podcasts: Podcast[];
}

// Typdefinition für Podcast-Objekte
interface Podcast {
  title: string;
  audioPath: string;
  image?: string;
  duration?: string;
  artist?: string;
  description?: string;
  category?: string;
}

// Daten aus den Props verwenden
const { lang, podcasts = [] } = Astro.props;
const t = useTranslations(lang);

// Alle Kategorien extrahieren (wenn vorhanden)
const allCategories = [
  ...new Set(
    podcasts.map(
      (podcast) => podcast.category || t("podcast.category.uncategorized"),
    ),
  ),
].sort();

// Alphabetische Sortierung der Podcasts
const sortedPodcasts = [...podcasts].sort((a, b) =>
  a.title.localeCompare(b.title, undefined, { sensitivity: "base" }),
);
---

<Layout title={t("podcast.page.title")}>
  <div class="max-w-6xl mx-auto px-4 py-8">
    <!-- Podcast Überschrift und Beschreibung -->
    <div class="text-center mb-12">
      <Headline
        title={t("podcast.page.heading")}
        level="h1"
        className="text-white font-bold text-3xl md:text-4xl mb-4"
      />
      <div class="h-1 w-24 bg-purple-500 rounded-full mx-auto mt-2 mb-6"></div>
      <Paragraph
        description={t("podcast.page.description")}
        className="max-w-2xl mx-auto text-zinc-100"
      />
    </div>

    <!-- Suchleiste und Filter -->
    <div
      class="search-filter-container bg-zinc-800/90 rounded-xl p-6 border border-zinc-700 shadow-lg mb-10"
      role="search"
    >
      <h2 class="sr-only" id="search-heading">
        {t("podcast.search.label")}
      </h2>

      <div class="flex flex-col md:flex-row gap-4 mb-4">
        <!-- Suchfeld -->
        <div class="relative flex-grow">
          <label for="podcast-search" class="sr-only">
            {t("podcast.search.placeholder")}
          </label>
          <div class="relative">
            <div
              class="absolute inset-y-0 left-3 flex items-center pointer-events-none"
            >
              <Icon name="search" class="h-5 w-5 text-purple-400" />
            </div>
            <input
              type="search"
              id="podcast-search"
              placeholder={t("podcast.search.placeholder")}
              class="w-full py-3 pl-10 pr-4 bg-zinc-800 border-2 border-zinc-600
                    rounded-xl text-zinc-50 placeholder-zinc-300
                    focus:outline-none focus:border-purple-500 focus:ring-3
                    focus:ring-purple-500/50 transition-all duration-300"
              aria-controls="podcast-list"
              aria-describedby="search-podcast-description"
            />
            <div id="search-podcast-description" class="sr-only">
              Während der Eingabe werden die Podcasts automatisch gefiltert
            </div>
          </div>
        </div>

        <!-- Kategorie-Filter, nur wenn Kategorien vorhanden sind -->
        {
          allCategories.length > 1 && (
            <div class="md:w-1/3">
              <label for="categoryFilter" class="sr-only">
                Nach Kategorie filtern
              </label>
              <div class="relative">
                <div class="absolute inset-y-0 left-3 flex items-center pointer-events-none">
                  <Icon name="filter" class="h-5 w-5 text-purple-400" />
                </div>
                <select
                  id="categoryFilter"
                  class="w-full py-3 pl-10 pr-4 bg-zinc-800 border-2 border-zinc-600
                      rounded-xl text-zinc-50 appearance-none cursor-pointer
                      focus:outline-none focus:border-purple-500 focus:ring-3
                      focus:ring-purple-500/50 transition-all duration-300"
                  aria-label="Nach Kategorie filtern"
                >
                  <option value="all">{t("podcast.filter.all")}</option>
                  {allCategories.map((category) => (
                    <option value={category}>{category}</option>
                  ))}
                </select>
                <div class="absolute inset-y-0 right-3 flex items-center pointer-events-none">
                  <Icon name="chevron-down" class="h-5 w-5 text-purple-400" />
                </div>
              </div>
            </div>
          )
        }
      </div>

      <!-- Suchstatusanzeige für Screenreader -->
      <div id="search-results-status" class="sr-only" aria-live="polite">
        {t("podcast.search.status.all")}
      </div>
    </div>

    <!-- Keine Ergebnisse Nachricht (anfangs ausgeblendet) -->
    <div
      id="no-results"
      class="hidden flex flex-col items-center justify-center p-12 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl border border-zinc-600 text-center shadow-md mb-10"
      aria-live="polite"
    >
      <Icon name="search-no-results" class="w-16 h-16 text-zinc-300 mb-4" />
      <p class="text-zinc-100 text-lg font-medium">
        {t("podcast.no.results")}
      </p>
      <button
        id="reset-search"
        class="mt-4 px-4 py-2 bg-purple-600 hover:bg-purple-500 text-white rounded-lg focus:outline-none focus:ring-3 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800 transition-all duration-300"
      >
        Suche zurücksetzen
      </button>
    </div>

    <!-- Podcast Grid -->
    <section
      id="podcast-list"
      class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8"
      role="region"
      aria-label={t("podcast.page.heading")}
    >
      {
        sortedPodcasts.map((podcast, index) => (
          <div
            class="podcast-card animate-fadeIn"
            style={{ animationDelay: `${index * 0.05}s` }}
            data-searchable={podcast.title.toLowerCase()}
            data-category={
              podcast.category || t("podcast.category.uncategorized")
            }
          >
            <article class="h-full bg-zinc-800 rounded-xl overflow-hidden border border-zinc-700 shadow-lg transition-all duration-300 hover:shadow-xl hover:translate-y-[-5px]">
              <div class="p-0.5 bg-gradient-to-r from-purple-500 to-indigo-500" />

              <div class="aspect-video relative">
                <AudioPlayer
                  audioSrc={podcast.audioPath}
                  imageSrc={
                    podcast.image || "/images/podcast/default-cover.jpg"
                  }
                  imageAlt={`Cover für ${podcast.title}`}
                  title={podcast.title}
                  artist={podcast.artist || t("podcast.play")}
                />
              </div>

              <div class="p-4">
                <h2
                  id={`podcast-title-${index}`}
                  class="text-lg font-bold text-white mb-2"
                >
                  {podcast.title}
                </h2>
              </div>
            </article>
          </div>
        ))
      }
    </section>

    <button
      id="back-to-top"
      class="fixed bottom-8 right-8 p-3 bg-purple-600 text-white rounded-full shadow-lg opacity-0 invisible transition-all duration-300 hover:bg-purple-500 focus:outline-none focus:ring-3 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800"
      aria-label="Zurück zum Anfang der Seite"
    >
      <Icon name="arrow-up" class="h-6 w-6" />
    </button>
  </div>
</Layout>

<style>
  /* Verbesserter Farbkontrast für WCAG AAA (7:1) */
  :root {
    --text-primary: #ffffff; /* Maximaler Kontrast */
    --text-secondary: #e2e2e7; /* Höherer Kontrast als standard zinc-300 */
    --bg-card: #27272a; /* zinc-800 */
    --border-card: rgba(161, 161, 170, 0.3); /* zinc-400 mit Transparenz */
    --accent-primary: #a855f7; /* purple-500 */
    --accent-secondary: #c084fc; /* purple-400 */
  }

  /* Verbesserte Fokus-Zustände für bessere Tastaturnavigation */
  :focus-visible {
    outline: 3px solid var(--accent-primary);
    outline-offset: 3px;
  }

  /* Animations for cards */
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fadeIn {
    animation: fadeIn 0.5s ease-out forwards;
    opacity: 0;
  }

  /* Verbesserter Back-to-Top Button Animation */
  #back-to-top.visible {
    opacity: 1;
    visibility: visible;
  }

  /* Disable animations if user prefers reduced motion */
  @media (prefers-reduced-motion: reduce) {
    *,
    ::before,
    ::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }

    .animate-fadeIn {
      opacity: 1;
      animation: none;
      transform: translateY(0);
    }

    .podcast-card article:hover {
      transform: none !important;
      box-shadow: none !important;
    }
  }
</style>

<script>
  /**
   * Moderne Podcast-Seiten-Funktionalität
   */
  document.addEventListener("DOMContentLoaded", function () {
    // DOM-Elemente für bessere Performance zwischenspeichern
    const searchInput = document.getElementById(
      "podcast-search",
    ) as HTMLInputElement;
    const categoryFilter = document.getElementById(
      "categoryFilter",
    ) as HTMLSelectElement;
    const podcastCards = document.querySelectorAll(".podcast-card");
    const noResultsElement = document.getElementById("no-results");
    const searchStatusElement = document.getElementById(
      "search-results-status",
    );
    const resetSearchButton = document.getElementById("reset-search");
    const backToTopButton = document.getElementById("back-to-top");

    // Such- und Filterfunktion
    function filterPodcasts() {
      if (!searchInput) return;

      const searchTerm = searchInput.value.toLowerCase().trim();
      const selectedCategory = categoryFilter?.value || "all";

      let visibleCount = 0;

      // Podcast-Karten nach Suchbegriff und Kategorie filtern
      podcastCards.forEach((card) => {
        const searchable = card.getAttribute("data-searchable") || "";
        const category = card.getAttribute("data-category") || "";

        const matchesSearch =
          searchTerm === "" || searchable.includes(searchTerm);
        const matchesCategory =
          selectedCategory === "all" || category === selectedCategory;

        const isVisible = matchesSearch && matchesCategory;

        if (isVisible) {
          card.classList.remove("hidden");
          visibleCount++;
        } else {
          card.classList.add("hidden");
        }
      });

      // "Keine Ergebnisse" Nachricht anzeigen/ausblenden
      if (noResultsElement) {
        noResultsElement.classList.toggle("hidden", visibleCount > 0);
      }

      // Status für Screenreader aktualisieren
      if (searchStatusElement) {
        if (visibleCount === 0) {
          searchStatusElement.textContent = `Keine Podcasts gefunden.`;
        } else if (visibleCount === 1) {
          searchStatusElement.textContent = `1 Podcast gefunden.`;
        } else if (visibleCount === podcastCards.length) {
          searchStatusElement.textContent = `Alle ${visibleCount} Podcasts werden angezeigt.`;
        } else {
          searchStatusElement.textContent = `${visibleCount} von ${podcastCards.length} Podcasts gefunden.`;
        }
      }
    }

    // Event-Listener für Suche und Filter
    if (searchInput) {
      searchInput.addEventListener("input", filterPodcasts);
    }

    if (categoryFilter) {
      categoryFilter.addEventListener("change", filterPodcasts);
    }

    // Suche zurücksetzen
    if (resetSearchButton) {
      resetSearchButton.addEventListener("click", function () {
        if (searchInput) searchInput.value = "";
        if (categoryFilter) categoryFilter.value = "all";
        filterPodcasts();
        searchInput.focus();
      });
    }

    // "Nach oben"-Button Funktionalität
    if (backToTopButton) {
      window.addEventListener("scroll", function () {
        const scrollTop = window.scrollY || document.documentElement.scrollTop;

        if (scrollTop > 500) {
          backToTopButton.classList.add("visible");
        } else {
          backToTopButton.classList.remove("visible");
        }
      });

      backToTopButton.addEventListener("click", function () {
        window.scrollTo({
          top: 0,
          behavior: "smooth",
        });
      });
    }

    // Preload-Strategie für Podcast-Cover
    function setupLazyLoading() {
      const images = document.querySelectorAll(".cover-image img");
      const imagesToPreload = Math.min(3, images.length); // Nur die ersten Bilder vorladen

      // Erst sichtbare Bilder mit hoher Priorität laden
      for (let i = 0; i < imagesToPreload; i++) {
        const img = images[i] as HTMLImageElement;
        if (img && !img.complete) {
          img.loading = "eager";
        }
      }

      // Restliche Bilder mit niedriger Priorität laden
      for (let i = imagesToPreload; i < images.length; i++) {
        const img = images[i] as HTMLImageElement;
        if (img && !img.complete) {
          img.loading = "lazy";
        }
      }
    }

    setupLazyLoading();
  });
</script>
