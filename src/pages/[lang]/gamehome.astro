---
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import PlaylistItem from "@components/PlaylistItem.astro";
import Layout from "@layouts/Layout.astro";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import { extractKeywords, generateMetaDescription } from "@utils/seo";
import { Icon } from "astro-icon/components";

/**
 * Language and translation setup
 * Sets the current language based on URL and loads appropriate translations
 */
const lang = String(getLangFromUrl(Astro.url));
const t = useTranslations(String(lang));

/**
 * Interface defining the structure of a music category
 */
interface Category {
  isPlayable: boolean;
  headline: string;
  categoryUrl?: string;
  imageUrl: string;
  introSubline: string;
  slug: string;
  text: string;
}

/**
 * Asynchronously loads category data with fallback mechanisms
 * First attempts to load using the alias path, then tries relative path if that fails
 * @returns {Promise<Category[]>} Array of category objects
 */
async function loadCategoriesForLanguage(language: string): Promise<Category[]> {
  try {
    // First try using the alias path
    return await import(`@json/${language}_categories.json`)
      .then((module) => module.default)
      .catch(async () => {
        // Fallback to relative path if alias fails
        console.info(`Attempting to load ${language}_categories.json using relative path`);
        return await import(`../../json/${language}_categories.json`)
          .then((module) => module.default)
          .catch((err) => {
            console.error(`Failed to load ${language}_categories.json:`, err);
            return [];
          });
      });
  } catch (error) {
    console.error(`Error loading categories for ${language}:`, error);
    return [];
  }
}

// Load categories and ensure we have a valid array
const categoriesList = await loadCategoriesForLanguage(lang);
const categories = Array.isArray(categoriesList) ? categoriesList : [];

/**
 * Type guard that checks if an item is a valid playable category
 * @param item - The item to check
 * @returns Boolean indicating if item is a valid playable category
 */
function isPlayableCategory(item: any): item is Category & { categoryUrl: string } {
  return (
    item &&
    typeof item === "object" &&
    item.isPlayable === true &&
    typeof item.headline === "string" &&
    typeof item.imageUrl === "string" &&
    typeof item.introSubline === "string" &&
    typeof item.slug === "string" &&
    typeof item.text === "string" &&
    typeof item.categoryUrl === "string" &&
    Boolean(item.categoryUrl)
  );
}

// Filter categories by playability status
const playableCategories = categories.filter(isPlayableCategory);
const nonPlayableCategories = categories.filter((item) => item && !item.isPlayable);

// Combined categories with playable ones first
const sortedCategories = [...playableCategories, ...nonPlayableCategories];

// Generate SEO content
const title = t("game.select");
const description = t("game.welcome");

// Enhanced SEO content using utility functions
const pageContent = `${title} ${description} ${sortedCategories.map((c) => `${c.headline} ${c.introSubline}`).join(" ")}`;

// Generate optimized meta description and keywords
const optimizedDescription = generateMetaDescription(pageContent);
const keywords = extractKeywords(pageContent) || t("meta.keywords");

// Additional structured data parameters for SEO
const pageType = "website";
const publishDate = new Date("2024-01-01");
const modifiedDate = new Date();

// Prepare fallback text for empty states
const emptyCategoriesHeadline = t("game.categories.empty.headline") || "No genres found";
const emptyCategoriesText =
  t("game.categories.empty.text") ||
  "Unfortunately, no categories were found. Please try again later.";
const noPlayableCategoriesHeadline =
  t("game.categories.no.playable.headline") || "No playable genres";
const noPlayableCategoriesText =
  t("game.categories.no.playable.text") ||
  "There are currently no playable categories. Please check back later.";
---

<Layout
  {title}
  description={optimizedDescription}
  {keywords}
  image={`/og-images/social-share-gamehome-${String(lang)}.jpg`}
  type={pageType}
  {publishDate}
  {modifiedDate}
>
  <div class="mx-auto w-full max-w-6xl px-4 py-8" id="main-content">
    <!-- Hero section with improved contrast and accessibility -->
    <section
      class="relative mb-12 overflow-hidden rounded-2xl bg-gradient-to-br from-purple-900 via-indigo-900 to-blue-900 p-8 shadow-xl"
      aria-labelledby="welcome-heading"
    >
      <!-- Decorative background elements with aria-hidden -->
      <div class="absolute inset-0 opacity-10" aria-hidden="true">
        <div class="absolute -top-24 -right-20 h-64 w-64 rounded-full bg-indigo-500"></div>
        <div class="absolute bottom-10 left-10 h-40 w-40 rounded-full bg-purple-500"></div>
        <div class="absolute top-1/2 right-1/4 h-32 w-32 rounded-full bg-blue-500"></div>
      </div>

      <div class="relative z-10 text-center">
        <Headline
          title={`${t("game.welcome")}`}
          level="h1"
          className="mb-4 text-3xl font-bold text-white md:text-4xl"
        />
        <div class="mx-auto mt-2 mb-6 h-1 w-24 rounded-full bg-purple-400"></div>
        <Paragraph className="mx-auto max-w-2xl text-lg leading-relaxed text-zinc-100">
          {t("game.select")}
        </Paragraph>
      </div>
    </section>

    <section class="mt-12" aria-labelledby="playlist-heading">
      <Headline
        level="h2"
        title={t("game.genre.list")}
        className="mb-4 text-center text-2xl font-bold"
      />

      <!-- Search input with improved accessibility and styling -->
      <div class="relative mx-auto my-8 w-full max-w-2xl">
        <div
          class="pointer-events-none absolute inset-y-0 left-4 flex items-center"
          aria-hidden="true"
        >
          <!-- Ersetze inline SVG mit Icon-Komponente -->
          <Icon name="search" class="h-5 w-5 text-zinc-300" />
        </div>
        <label for="filter-input" class="sr-only">
          {t("game.search.label")}
        </label>
        <input
          class="focus:ring-opacity-50 w-full rounded-xl border-2 border-zinc-500 bg-zinc-800 py-4 pr-5 pl-12 text-base leading-relaxed text-zinc-50 placeholder-zinc-300 shadow-lg transition-all duration-300 focus:border-purple-400 focus:ring-2 focus:ring-purple-400/50 focus:outline-none"
          type="search"
          id="filter-input"
          placeholder={t("game.search.label")}
          aria-label={t("game.search.label")}
          aria-controls="playlist-grid"
          aria-describedby="search-description"
          autocomplete="off"
          spellcheck="false"
        />
        <span id="search-description" class="sr-only">
          {t("game.search.description")}
        </span>
      </div>

      <!-- Genre grid with improved card styling and animations -->
      <div
        id="playlist-grid"
        class="xs:grid-cols-2 mx-auto my-8 grid min-h-[200px] w-full max-w-5xl grid-cols-1 gap-6 md:grid-cols-3 md:gap-8 lg:grid-cols-3"
        role="list"
        aria-label={t("game.genre.list")}
        aria-live="polite"
      >
        {
          categories && categories.length > 0 ? (
            playableCategories.length > 0 ? (
              categories.map(
                (item, index) =>
                  item.isPlayable && (
                    <li
                      class="animate-fadeIn h-full list-none"
                      style={{ animationDelay: `${index * 0.05}s` }}
                    >
                      <PlaylistItem
                        headline={item.headline}
                        subheadline={item.introSubline}
                        image={item.imageUrl}
                        imageAlt={`${t("game.genre.image")} ${item.headline}`}
                        href={`/${String(lang)}${item.categoryUrl}`}
                        isDisabled={!item.isPlayable}
                        aria-label={`${item.headline} ${t("game.genre.play.label")}`}
                      />
                      <div
                        class="flex items-center justify-center rounded-b-lg bg-gradient-to-r from-purple-600 to-indigo-600 p-2 text-sm font-medium text-white opacity-0 transition-opacity group-hover:opacity-100"
                        aria-hidden="true"
                      >
                        {t("category.play")} â†’
                      </div>
                    </li>
                  )
              )
            ) : (
              <div class="col-span-full rounded-xl border border-zinc-700 bg-gradient-to-br from-zinc-800 to-zinc-900 px-6 py-12 text-center shadow-md">
                <h3 class="mb-3 text-xl font-bold text-zinc-50">{noPlayableCategoriesHeadline}</h3>
                <p class="text-zinc-300">{noPlayableCategoriesText}</p>
              </div>
            )
          ) : (
            <div class="col-span-full rounded-xl border border-zinc-700 bg-gradient-to-br from-zinc-800 to-zinc-900 px-6 py-12 text-center shadow-md">
              <h3 class="mb-3 text-xl font-bold text-zinc-50">{emptyCategoriesHeadline}</h3>
              <p class="text-zinc-300">{emptyCategoriesText}</p>
            </div>
          )
        }
      </div>
    </section>
  </div>
</Layout>

<script>
  /**
   * Genre Filtering and Search System
   *
   * This module provides search functionality for the genre grid, allowing users
   * to dynamically filter available music genres as they type in the search field.
   * It includes performance optimizations such as debouncing and DOM element caching
   * to ensure a smooth user experience even with large lists.
   *
   */

  import { getLangFromUrl } from "@utils/i18n";

  import { ui } from "../../i18n/ui";

  // =========================================================================
  // CONFIGURATION AND SETUP
  // =========================================================================

  /**
   * Configuration constants that control the behavior of the filtering system
   */
  const CONFIG = {
    DEBOUNCE_DELAY: 250, // MS to wait before applying filter after typing
    ANIMATION_DURATION: 150, // MS for fade animations
    SELECTOR: {
      FILTER_INPUT: "#filter-input",
      GRID: "#playlist-grid",
      LIST_ITEM: "li",
      HEADLINE: ".headline",
      NO_RESULTS: ".no-results",
      FIRST_RESULT: ".first-result",
    },
    ATTRIBUTE: {
      DISABLED: "aria-disabled",
    },
    KEY_CODES: {
      ESCAPE: "Escape",
      ENTER: "Enter",
    },
  };

  /**
   * Load translations for the current language
   * @type {Object} Dictionary of translation keys and values
   */
  const currentLang = getLangFromUrl(new URL(window.location.href));
  const translations = {
    noResults:
      (ui[currentLang] as Record<string, string>)?.["game.no.results"] || "No results found",
    notAvailable:
      (ui[currentLang] as Record<string, string>)?.["game.not.available"] || "Not available",
    resultsCount:
      (ui[currentLang] as Record<string, string>)?.["game.results.count"] || "{count} genres found",
    clearSearch:
      (ui[currentLang] as Record<string, string>)?.["game.search.clear"] || "Clear search",
  };

  /**
   * Cache for DOM elements to avoid repeated queries
   * @type {Object} Stores references to key DOM elements
   */
  const elements = {
    filterInput: document.querySelector(CONFIG.SELECTOR.FILTER_INPUT),
    grid: document.querySelector(CONFIG.SELECTOR.GRID),
    get items() {
      return elements.grid?.querySelectorAll(`${CONFIG.SELECTOR.LIST_ITEM}`) || [];
    },
  };

  // =========================================================================
  // UTILITY FUNCTIONS
  // =========================================================================

  /**
   * Creates a debounced version of a function that delays execution
   * until after the specified wait time has elapsed since the last call
   *
   * @param {Function} func - The function to debounce
   * @param {number} wait - Time in milliseconds to delay execution
   * @return {Function} A debounced version of the input function
   */
  function debounce(func: (...args: unknown[]) => void, wait: number) {
    let timeout: ReturnType<typeof setTimeout> | undefined;
    return function (this: unknown, ...args: unknown[]) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  /**
   * In-memory cache for genre item text content to improve search performance
   * @type {WeakMap<Element, string>} Maps DOM elements to their searchable text
   */
  const textContentCache = new WeakMap();

  /**
   * Announces a message to screen readers using ARIA live region
   * @param {string} message - The message to announce
   */
  function announceToScreenReader(message: string) {
    // Make sure we have an ARIA live region, or create one if needed
    let liveRegion = document.querySelector(".sr-announcements");
    if (!liveRegion) {
      liveRegion = document.createElement("div");
      liveRegion.className = "sr-announcements sr-only";
      liveRegion.setAttribute("aria-live", "polite");
      liveRegion.setAttribute("aria-atomic", "true");
      document.body.appendChild(liveRegion);
    }

    // Set the message content and ensure it's announced
    liveRegion.textContent = message;
  }

  // =========================================================================
  // CORE FUNCTIONALITY
  // =========================================================================

  /**
   * Initializes the genre filtering system
   * Sets up event listeners and prepares the UI
   */
  function initGenreFilter() {
    if (!elements.filterInput || !elements.grid) {
      console.warn("Filter elements not found. Genre filtering disabled.");
      return;
    }

    // Setup event listeners with debounced filtering
    const debouncedFilter = debounce(filterGenres, CONFIG.DEBOUNCE_DELAY);

    elements.filterInput?.addEventListener("input", debouncedFilter);

    // Add keyboard event listeners for enhanced navigation
    elements.filterInput?.addEventListener("keydown", (event: Event) => {
      handleFilterKeydown(event as KeyboardEvent);
    });

    // Create clear search button for improved usability
    addClearButton();

    // Set up disabled items with proper attributes
    document.querySelectorAll(`[${CONFIG.ATTRIBUTE.DISABLED}="true"]`).forEach((item) => {
      item.setAttribute("data-unavailable-text", translations.notAvailable);
    });

    // Add initial ARIA status for screen readers
    const initialCount = elements.items.length;
    announceToScreenReader(translations.resultsCount.replace("{count}", initialCount.toString()));
  }

  /**
   * Creates and adds a clear button for the search input
   */
  function addClearButton() {
    const inputWrapper = elements.filterInput?.parentElement;
    if (!inputWrapper || !elements.filterInput) {
      return;
    }

    const clearButton = document.createElement("button");
    clearButton.className =
      "clear-input absolute right-4 top-1/2 -translate-y-1/2 text-zinc-400 hover:text-white p-1 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-400";
    clearButton.setAttribute("type", "button");
    clearButton.setAttribute("aria-label", translations.clearSearch);
    clearButton.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" 
        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    `;

    clearButton.style.display = "none";

    clearButton.addEventListener("click", () => {
      (elements.filterInput as HTMLInputElement).value = "";
      clearButton.style.display = "none";
      filterGenres();
      (elements.filterInput as HTMLInputElement)?.focus();
    });

    // Show/hide clear button based on input content
    elements.filterInput.addEventListener("input", () => {
      const hasValue = (elements.filterInput as HTMLInputElement).value.length > 0;
      clearButton.style.display = hasValue ? "block" : "none";
    });

    inputWrapper.appendChild(clearButton);
  }

  /**
   * Handles keyboard events on the filter input
   * @param {KeyboardEvent} event - The keyboard event
   */
  function handleFilterKeydown(event: KeyboardEvent) {
    if (event.key === CONFIG.KEY_CODES.ESCAPE) {
      // Clear the search input on Escape
      (event.target as HTMLInputElement).value = "";
      filterGenres();

      // Also hide clear button if it exists
      const clearButton = document.querySelector(".clear-input");
      if (clearButton) {
        (clearButton as HTMLElement).style.display = "none";
      }

      // Prevent default behavior (like closing dialogs)
      event.preventDefault();
    } else if (event.key === CONFIG.KEY_CODES.ENTER) {
      // On Enter, move focus to first visible result if available
      const firstVisibleItem = Array.from(elements.items).find(
        (item) => (item as HTMLElement).style.display !== "none"
      );

      if (firstVisibleItem) {
        const firstLink = firstVisibleItem.querySelector("a");
        if (firstLink) {
          event.preventDefault();
          firstLink.focus();
        }
      }
    }
  }

  /**
   * Filters the genre items based on the search query
   * Shows/hides items according to the match and updates the UI accordingly
   */
  function filterGenres() {
    if (!elements.filterInput || !elements.grid) {
      return;
    }

    const query = (elements.filterInput as HTMLInputElement).value.toLowerCase().trim();
    let visibleCount = 0;
    let firstVisibleItem: Element | null = null;

    // Filter each genre item based on the query
    elements.items.forEach((item) => {
      // Use cached text content or retrieve and cache it
      let itemText = textContentCache.get(item);
      if (!itemText) {
        itemText = item.querySelector(CONFIG.SELECTOR.HEADLINE)?.textContent?.toLowerCase() || "";
        textContentCache.set(item, itemText);
      }

      // Check if item text contains the query
      const isVisible = itemText.includes(query);
      (item as HTMLElement).style.display = isVisible ? "" : "none";

      // Track visible items for accessibility
      if (isVisible) {
        visibleCount++;
        if (!firstVisibleItem) {
          firstVisibleItem = item;
          item.classList.add("first-result");
        } else {
          item.classList.remove("first-result");
        }
      } else {
        item.classList.remove("first-result");
      }
    });

    // Update the UI with a "no results" message if needed
    updateNoResultsMessage(visibleCount > 0);

    // Announce results to screen readers
    announceToScreenReader(translations.resultsCount.replace("{count}", visibleCount.toString()));
  }

  /**
   * Updates the UI to show or hide a "no results" message
   * when the search query returns no matches
   *
   * @param {boolean} hasResults - Whether any genres match the current query
   */
  function updateNoResultsMessage(hasResults: boolean) {
    if (!elements.grid) {
      return;
    }

    let noResultsMessage = elements.grid.querySelector(CONFIG.SELECTOR.NO_RESULTS);

    if (!hasResults) {
      // Create and display "no results" message if it doesn't exist
      if (!noResultsMessage) {
        noResultsMessage = document.createElement("p");
        noResultsMessage.className =
          "col-span-full py-8 px-6 bg-zinc-700 rounded-lg text-zinc-50 text-center font-medium no-results";
        noResultsMessage.setAttribute("role", "status");
        noResultsMessage.setAttribute("aria-live", "polite");
        noResultsMessage.textContent = translations.noResults;
        elements.grid.appendChild(noResultsMessage);
      }
    } else {
      // Remove the "no results" message if results are found
      noResultsMessage?.remove();
    }
  }

  // Initialize the genre filter when the DOM is ready
  document.addEventListener("DOMContentLoaded", initGenreFilter);

  // Immediate initialization as a fallback for when the script loads after DOM content
  if (document.readyState !== "loading") {
    initGenreFilter();
  }
</script>

<style>
  /* Improved contrast for disabled items */
  [aria-disabled="true"] {
    cursor: not-allowed;
    position: relative;
    opacity: 0.9;
    background-color: var(--secondary-color);
  }

  [aria-disabled="true"]::after {
    content: attr(data-unavailable-text);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 1em 1.5em;
    border-radius: 0.5rem;
    font-size: 1rem;
    font-weight: 600;
    color: #fff;
    background: rgba(0, 0, 0, 0.9);
  }

  /* Screen reader only class */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  /* High Contrast Mode Support */
  @media (forced-colors: active) {
    #playlist-grid a {
      border: 2px solid ButtonText;
    }

    input {
      border: 2px solid ButtonText;
    }
  }

  /* Print Styles */
  @media print {
    #filter-input {
      display: none;
    }

    #playlist-grid {
      gap: 1rem;
    }

    #playlist-grid a {
      break-inside: avoid;
      page-break-inside: avoid;
    }
  }

  /* 16:9 Aspect ratio for Genre cards */
  #playlist-grid a {
    display: block;
  }

  #playlist-grid a article > div:first-child {
    aspect-ratio: 16/9;
  }

  /* Improved animations with reduced motion support */
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fadeIn {
    animation: fadeIn 0.5s ease-out forwards;
    opacity: 0;
  }

  /* Focus styles for better keyboard navigation */
  :focus-visible {
    outline: 3px solid #a855f7 !important;
    outline-offset: 3px !important;
  }

  /* Verbesserte Fokus-Stile fÃ¼r bessere ZugÃ¤nglichkeit */
  :focus-visible {
    outline: 3px solid #c026d3;
    outline-offset: 3px;
    border-radius: 0.25rem;
    transition: outline-offset 0.1s ease;
  }

  .category-card:focus-visible {
    transform: translateY(-0.5rem);
  }

  .first-result > a:focus-visible {
    outline-width: 4px !important;
  }

  .clear-input:focus-visible {
    box-shadow: 0 0 0 2px rgba(192, 38, 211, 0.5);
  }

  /* Reduzierte Bewegung fÃ¼r Benutzer, die dies bevorzugen */
  @media (prefers-reduced-motion: reduce) {
    .stagger-item {
      animation: none !important;
      opacity: 1 !important;
      transform: none !important;
    }

    .category-card:hover,
    .category-card:focus {
      transform: none !important;
    }

    .animate-fadeIn {
      animation: none !important;
      opacity: 1;
    }

    .clear-input,
    .skip-to-content,
    :focus-visible {
      transition: none !important;
    }
  }

  /* Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .animate-fadeIn,
    a,
    button,
    input,
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }
  }
</style>
