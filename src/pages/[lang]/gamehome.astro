---
import { getLangFromUrl, useTranslations } from "@utils/i18n";
import PlaylistItem from "@components/PlaylistItem.astro";
import Layout from "@layouts/Layout.astro";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";

/**
 * Language and translation setup
 * Sets the current language based on URL and loads appropriate translations
 */
const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

/**
 * Interface defining the structure of a music category
 */
interface Category {
  isPlayable: boolean;
  headline: string;
  categoryUrl?: string;
  imageUrl: string;
  introSubline: string;
  slug: string;
  text: string;
}

/**
 * Asynchronously loads category data with fallback mechanisms
 * First attempts to load using the alias path, then tries relative path if that fails
 * @returns {Promise<Category[]>} Array of category objects
 */
async function loadCategoriesForLanguage(
  language: string,
): Promise<Category[]> {
  try {
    // First try using the alias path
    return await import(`@json/${language}_categories.json`)
      .then((module) => module.default)
      .catch(async () => {
        // Fallback to relative path if alias fails
        console.info(
          `Attempting to load ${language}_categories.json using relative path`,
        );
        return await import(`../../json/${language}_categories.json`)
          .then((module) => module.default)
          .catch((err) => {
            console.error(`Failed to load ${language}_categories.json:`, err);
            return [];
          });
      });
  } catch (error) {
    console.error(`Error loading categories for ${language}:`, error);
    return [];
  }
}

// Load categories and ensure we have a valid array
const categoriesList = await loadCategoriesForLanguage(lang);
const categories = Array.isArray(categoriesList) ? categoriesList : [];

/**
 * Type guard that checks if an item is a valid playable category
 * @param item - The item to check
 * @returns Boolean indicating if item is a valid playable category
 */
function isPlayableCategory(
  item: any,
): item is Category & { categoryUrl: string } {
  return (
    item &&
    typeof item === "object" &&
    item.isPlayable === true &&
    typeof item.headline === "string" &&
    typeof item.imageUrl === "string" &&
    typeof item.introSubline === "string" &&
    typeof item.slug === "string" &&
    typeof item.text === "string" &&
    typeof item.categoryUrl === "string" &&
    Boolean(item.categoryUrl)
  );
}

// Filter categories by playability status
const playableCategories = categories.filter(isPlayableCategory);
const nonPlayableCategories = categories.filter(
  (item) => item && !item.isPlayable,
);

// Combined categories with playable ones first
const sortedCategories = [...playableCategories, ...nonPlayableCategories];

// Prepare fallback text for empty states
const emptyCategoriesHeadline =
  t("game.categories.empty.headline") || "No genres found";
const emptyCategoriesText =
  t("game.categories.empty.text") ||
  "Unfortunately, no categories were found. Please try again later.";
const noPlayableCategoriesHeadline =
  t("game.categories.no.playable.headline") || "No playable genres";
const noPlayableCategoriesText =
  t("game.categories.no.playable.text") ||
  "There are currently no playable categories. Please check back later.";
---

<Layout title={t("game.select")}>
  <div class="w-full max-w-6xl mx-auto px-4" id="main-content">
    <div class="text-center mb-8">
      <Headline
        title={`${t("game.welcome")}`}
        level="h1"
        className="text-white font-bold"
      />
      <div class="h-1 w-24 bg-gray-500 rounded-full mx-auto mt-2 mb-6"></div>
      <Paragraph className="max-w-2xl mx-auto">
        {t("game.select")}
      </Paragraph>
    </div>

    <section class="mt-8" aria-labelledby="playlist-heading">
      <Headline level="h2" title={t("game.genre.list")} className="sr-only" />

      <div class="my-8 w-full max-w-2xl mx-auto relative">
        <div
          class="absolute inset-y-0 left-4 flex items-center pointer-events-none"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-5 w-5 text-zinc-400"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
        </div>
        <label for="filter-input" class="sr-only">
          {t("game.search.label")}
        </label>
        <input
          class="w-full py-4 pl-12 pr-5 border-2 border-zinc-600 rounded-xl bg-zinc-700/80 text-zinc-50 text-base leading-relaxed placeholder-zinc-400 focus:outline-none focus:border-purple-500 focus:ring-2 focus:ring-purple-500/50 focus:ring-opacity-50 shadow-sm transition-all duration-300"
          type="search"
          id="filter-input"
          placeholder={t("game.search.label")}
          aria-label={t("game.search.label")}
          aria-controls="playlist-grid"
          aria-describedby="search-description"
          autocomplete="off"
          spellcheck="false"
        />
        <span id="search-description" class="sr-only">
          {t("game.search.description")}
        </span>
      </div>

      <div
        id="playlist-grid"
        class="grid grid-cols-1 xs:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 gap-6 md:gap-8 w-full max-w-5xl mx-auto my-8 min-h-[200px]"
        role="list"
        aria-label={t("game.genre.list")}
        aria-live="polite"
      >
        {
          categories && categories.length > 0 ? (
            playableCategories.length > 0 ? (
              categories.map(
                (item, index) =>
                  item.isPlayable && (
                    <li
                      class="h-full list-none animate-fadeIn"
                      style={{ animationDelay: `${index * 0.05}s` }}
                    >
                      <a
                        href={`/${lang}${item.categoryUrl}`}
                        class="block h-full overflow-hidden rounded-xl bg-transparent border-2 border-transparent transition-all duration-300 hover:-translate-y-1 hover:shadow-lg focus:outline-none focus:border-purple-400 focus:ring-2 focus:ring-purple-400 focus:ring-opacity-50"
                        aria-label={
                          item.headline + " " + t("game.genre.play.label")
                        }
                      >
                        <PlaylistItem
                          headline={item.headline}
                          subheadline={item.introSubline}
                          image={item.imageUrl}
                          imageAlt={t("game.genre.image") + " " + item.headline}
                        />
                      </a>
                    </li>
                  ),
              )
            ) : (
              <div class="col-span-full py-12 px-6 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl text-center shadow-md">
                <h3 class="text-xl font-bold text-zinc-50 mb-3">
                  {noPlayableCategoriesHeadline}
                </h3>
                <p class="text-zinc-200">{noPlayableCategoriesText}</p>
              </div>
            )
          ) : (
            <div class="col-span-full py-12 px-6 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl text-center shadow-md">
              <h3 class="text-xl font-bold text-zinc-50 mb-3">
                {emptyCategoriesHeadline}
              </h3>
              <p class="text-zinc-200">{emptyCategoriesText}</p>
            </div>
          )
        }
      </div>
    </section>
  </div>
</Layout>

<script>
  /**
   * Genre Filtering and Search System
   *
   * This module provides search functionality for the genre grid, allowing users
   * to dynamically filter available music genres as they type in the search field.
   * It includes performance optimizations such as debouncing and DOM element caching
   * to ensure a smooth user experience even with large lists.
   *
   */

  import { ui } from "../../i18n/ui";
  import { getLangFromUrl } from "@utils/i18n";

  // =========================================================================
  // CONFIGURATION AND SETUP
  // =========================================================================

  /**
   * Configuration constants that control the behavior of the filtering system
   */
  const CONFIG = {
    DEBOUNCE_DELAY: 250, // MS to wait before applying filter after typing
    ANIMATION_DURATION: 150, // MS for fade animations
    SELECTOR: {
      FILTER_INPUT: "#filter-input",
      GRID: "#playlist-grid",
      LIST_ITEM: "li",
      HEADLINE: ".headline",
      NO_RESULTS: ".no-results",
    },
    ATTRIBUTE: {
      DISABLED: "aria-disabled",
    },
  };

  /**
   * Load translations for the current language
   * @type {Object} Dictionary of translation keys and values
   */
  const currentLang = getLangFromUrl(new URL(window.location.href));
  const translations = {
    noResults: ui[currentLang]?.["game.no.results"] || "No results found",
    notAvailable: ui[currentLang]?.["game.not.available"] || "Not available",
  };

  /**
   * Cache for DOM elements to avoid repeated queries
   * @type {Object} Stores references to key DOM elements
   */
  const elements = {
    filterInput: document.querySelector(CONFIG.SELECTOR.FILTER_INPUT),
    grid: document.querySelector(CONFIG.SELECTOR.GRID),
    get items() {
      return (
        elements.grid?.querySelectorAll(`${CONFIG.SELECTOR.LIST_ITEM}`) || []
      );
    },
  };

  // =========================================================================
  // UTILITY FUNCTIONS
  // =========================================================================

  /**
   * Creates a debounced version of a function that delays execution
   * until after the specified wait time has elapsed since the last call
   *
   * @param {Function} func - The function to debounce
   * @param {number} wait - Time in milliseconds to delay execution
   * @return {Function} A debounced version of the input function
   */
  function debounce(func: (...args: unknown[]) => void, wait: number) {
    let timeout: ReturnType<typeof setTimeout> | undefined;
    return function (this: unknown, ...args: unknown[]) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  /**
   * In-memory cache for genre item text content to improve search performance
   * @type {WeakMap<Element, string>} Maps DOM elements to their searchable text
   */
  const textContentCache = new WeakMap();

  // =========================================================================
  // CORE FUNCTIONALITY
  // =========================================================================

  /**
   * Initializes the genre filtering system
   * Sets up event listeners and prepares the UI
   */
  function initGenreFilter() {
    if (!elements.filterInput || !elements.grid) {
      console.warn("Filter elements not found. Genre filtering disabled.");
      return;
    }

    // Setup event listeners with debounced filtering
    const debouncedFilter = debounce(filterGenres, CONFIG.DEBOUNCE_DELAY);

    elements.filterInput.addEventListener("input", debouncedFilter);

    // Set up disabled items with proper attributes
    document
      .querySelectorAll(`[${CONFIG.ATTRIBUTE.DISABLED}="true"]`)
      .forEach((item) => {
        item.setAttribute("data-unavailable-text", translations.notAvailable);
      });
  }

  /**
   * Filters the genre items based on the search query
   * Shows/hides items according to the match and updates the UI accordingly
   */
  function filterGenres() {
    if (!elements.filterInput || !elements.grid) return;

    const query = (elements.filterInput as HTMLInputElement).value
      .toLowerCase()
      .trim();
    let hasResults = false;

    // Filter each genre item based on the query
    elements.items.forEach((item) => {
      // Use cached text content or retrieve and cache it
      let itemText = textContentCache.get(item);
      if (!itemText) {
        itemText =
          item
            .querySelector(CONFIG.SELECTOR.HEADLINE)
            ?.textContent?.toLowerCase() || "";
        textContentCache.set(item, itemText);
      }

      // Check if item text contains the query
      const isVisible = itemText.includes(query);
      (item as HTMLElement).style.display = isVisible ? "" : "none";

      if (isVisible) hasResults = true;
    });

    // Update the UI with a "no results" message if needed
    updateNoResultsMessage(hasResults);
  }

  /**
   * Updates the UI to show or hide a "no results" message
   * when the search query returns no matches
   *
   * @param {boolean} hasResults - Whether any genres match the current query
   */
  function updateNoResultsMessage(hasResults: boolean) {
    if (!elements.grid) return;

    let noResultsMessage = elements.grid.querySelector(
      CONFIG.SELECTOR.NO_RESULTS,
    );

    if (!hasResults) {
      // Create and display "no results" message if it doesn't exist
      if (!noResultsMessage) {
        noResultsMessage = document.createElement("p");
        noResultsMessage.className =
          "col-span-full py-8 px-6 bg-zinc-700 rounded-lg text-zinc-50 text-center font-medium no-results";
        noResultsMessage.setAttribute("role", "status");
        noResultsMessage.textContent = translations.noResults;
        elements.grid.appendChild(noResultsMessage);
      }
    } else {
      // Remove the "no results" message if results are found
      noResultsMessage?.remove();
    }
  }

  // Initialize the genre filter when the DOM is ready
  document.addEventListener("DOMContentLoaded", initGenreFilter);

  // Immediate initialization as a fallback for when the script loads after DOM content
  if (document.readyState !== "loading") {
    initGenreFilter();
  }
</script>

<style>
  /* Disabled Item Styling */
  [aria-disabled="true"] {
    cursor: not-allowed;
    position: relative;
    opacity: 0.85;
    background-color: var(--secondary-color);
  }

  [aria-disabled="true"]::after {
    content: attr(data-unavailable-text);

    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);

    padding: 1em 1.5em;
    border-radius: 0.5rem;

    font-size: 1rem;
    font-weight: 600;
    color: #fff;

    background: rgb(0 0 0 / 90%);
  }

  /* High Contrast Mode Support */
  @media (forced-colors: active) {
    #playlist-grid a {
      border: 2px solid ButtonText;
    }
  }

  /* Print Styles */
  @media print {
    #filter-input {
      display: none;
    }

    #playlist-grid {
      gap: 1rem;
    }

    #playlist-grid a {
      break-inside: avoid;

      page-break-inside: avoid;
    }
  }

  /* 16:9 Aspektverhältnis für Genre-Karten */
  #playlist-grid a {
    display: block;
  }

  #playlist-grid a article > div:first-child {
    aspect-ratio: 16/9;
  }

  /* Animations */
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fadeIn {
    animation: fadeIn 0.5s ease-out forwards;
    opacity: 0;
  }
</style>
