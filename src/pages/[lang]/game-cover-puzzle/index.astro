---
import Layout from "@layouts/Layout.astro";
import ShowCoins from "@components/Shared/ShowCoins.astro";
import GameHeadline from "@components/Game/GameHeadline.astro";
import FeedbackOverlay from "@components/Overlays/FeedbackOverlay.astro";
import EndOverlay from "@components/Overlays/EndOverlay.astro";
import LoadingSpinner from "@components/Game/LoadingSpinner.astro";
import ErrorMessage from "@components/Shared/ErrorMessage.astro";
import { getLangFromUrl, useTranslations } from "@utils/i18n";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
const category = new URL(Astro.request.url).searchParams.get("category");

// Dynamic import of categories based on language
let categories;
try {
  categories = await import(`@json/${lang}_categories.json`);
} catch (error) {
  // Fallback to default language if the specific language file doesn't exist
  categories = await import(`@json/de_categories.json`);
}

const user = { id: "guest" }; // Default user for game functionality
---

<Layout title="Cover Puzzle" showCoins={true}>
  <div slot="left-headercol">
    <ShowCoins />
  </div>

  <FeedbackOverlay />

  <EndOverlay
    id="endgame-popup"
    data-score="0"
    data-category="Cover Puzzle"
  />

  <GameHeadline headline="Cover Puzzle" />

  <ErrorMessage />

  <LoadingSpinner />

  <div class="flex items-center justify-between mb-4">
    <div class="text-xl text-zinc-300">
      Round: <span class="round">1/10</span>
    </div>
    <div class="text-xl text-zinc-300">
      Time: <span class="timer">60</span>s
    </div>
  </div>

  <div
    id="question-container"
    class="w-full mx-auto p-6 rounded-lg bg-zinc-800 shadow-xl border border-zinc-700 text-center transition-opacity duration-500 opacity-100 data-[hidden=true]:opacity-0"
    role="main"
    aria-label={t("game.area.label")}
    data-userID={user.id}
    data-category={category}
  >
    <div id="cover-puzzle" class="relative w-full aspect-square mb-8 bg-zinc-900">
      <!-- Puzzle grid will be created by JavaScript -->
    </div>

    <div
      id="options"
      class="grid grid-cols-2 gap-4"
      role="radiogroup"
      aria-label={t("game.options.label")}
    >
    </div>
  </div>
</Layout>

<script>
  import { stopAudio } from "@utils/audio/audioControls";
  import { ErrorHandler } from "@utils/error/errorHandler";
  import { handleEndGame, restartGame } from "@utils/game/endGameUtils";
  import { getLangFromUrl, useTranslations } from "@utils/i18n";
  import type { Album } from "src/types/game";

  const lang = getLangFromUrl(
    new URL(window.location.pathname, window.location.origin),
  );
  const t = useTranslations(lang);

  const TOTAL_ROUNDS = 10;
  const ROUND_TIME = 60; // seconds
  const GRID_SIZE = 4; // 4x4 grid
  const BASE_POINTS = 1000;

  interface GameElements {
    score: HTMLParagraphElement;
    round: HTMLParagraphElement;
    timer: HTMLSpanElement;
    feedback: HTMLParagraphElement;
    coverPuzzle: HTMLDivElement;
    options: HTMLDivElement;
    container: HTMLDivElement;
    overlay: HTMLDivElement;
    nextRoundButton: HTMLButtonElement;
    restartButton: HTMLButtonElement;
    loadingSpinner: HTMLElement;
  }

  function cacheElements(): GameElements {
    return {
      score: document.querySelector(".coinsCount") as HTMLParagraphElement,
      round: document.querySelector(".round") as HTMLParagraphElement,
      timer: document.querySelector(".timer") as HTMLSpanElement,
      feedback: document.getElementById("feedback") as HTMLParagraphElement,
      coverPuzzle: document.getElementById("cover-puzzle") as HTMLDivElement,
      options: document.getElementById("options") as HTMLDivElement,
      container: document.getElementById("question-container") as HTMLDivElement,
      overlay: document.getElementById("overlay") as HTMLDivElement,
      nextRoundButton: document.getElementById(
        "next-round-button",
      ) as HTMLButtonElement,
      restartButton: document.getElementById(
        "restart-button",
      ) as HTMLButtonElement,
      loadingSpinner: document.getElementById("loading-spinner") as HTMLElement,
    };
  }

  function createPuzzleGrid(container: HTMLElement, imageUrl: string) {
    container.innerHTML = "";
    const pieces: HTMLElement[] = [];

    // Calculate dimensions
    const pieceSize = 100 / GRID_SIZE;

    // Create puzzle pieces
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        const piece = document.createElement("div");
        piece.className = "absolute bg-cover transition-opacity duration-300";
        piece.style.width = `${pieceSize}%`;
        piece.style.height = `${pieceSize}%`;
        piece.style.left = `${x * pieceSize}%`;
        piece.style.top = `${y * pieceSize}%`;
        piece.style.backgroundImage = `url(${imageUrl})`;
        piece.style.backgroundPosition = `${(x * 100) / (GRID_SIZE - 1)}% ${
          (y * 100) / (GRID_SIZE - 1)
        }%`;
        piece.style.backgroundSize = `${GRID_SIZE * 100}%`;
        piece.style.opacity = "0";

        container.appendChild(piece);
        pieces.push(piece);
      }
    }

    return pieces;
  }

  function revealRandomPieces(pieces: HTMLElement[], count: number) {
    const hiddenPieces = pieces.filter((piece) => piece.style.opacity === "0");
    const piecesToReveal = hiddenPieces
      .sort(() => Math.random() - 0.5)
      .slice(0, count);

    piecesToReveal.forEach((piece) => {
      piece.style.opacity = "1";
    });

    return hiddenPieces.length - count <= 0;
  }

  function shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  function createOptions(
    correctAlbum: Album,
    allAlbums: Album[],
    container: HTMLElement,
  ) {
    container.innerHTML = "";
    const otherAlbums = allAlbums.filter(
      (album) => album.album !== correctAlbum.album,
    );
    const wrongOptions = shuffleArray(otherAlbums).slice(0, 3);
    const options = shuffleArray([correctAlbum, ...wrongOptions]);

    options.forEach((album) => {
      const button = document.createElement("button");
      button.className =
        "w-full p-4 bg-zinc-700 hover:bg-zinc-600 rounded-lg text-zinc-100 transition-colors";
      button.textContent = `${album.artist} - ${album.album}`;
      button.dataset.answer = album.album;
      container.appendChild(button);
    });
  }

  async function initializeGame(elements: GameElements) {
    let score = 0;
    let roundIndex = 0;
    let correctAnswers = 0;
    let timeLeft = ROUND_TIME;
    let timerInterval: ReturnType<typeof setInterval>;
    let currentAlbum: Album | null = null;
    let isRoundActive = false;

    elements.round.textContent = `${roundIndex + 1}/${TOTAL_ROUNDS}`;

    const category = elements.container.getAttribute("data-category");
    
    async function loadAlbums() {
      try {
        let albumsData;
        try {
          if (!category) throw new Error(t("error.no.category"));
          const response = await fetch(`/json/genres/${lang}/${category}.json`);

          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          albumsData = await response.json();
        } catch (error) {
          console.error("Initial load failed:", error);
          // Try German fallback
          const fallback = await fetch(`/json/genres/de/${category}.json`);
          if (!fallback.ok) {
            throw new Error(t("error.loading.albums"));
          }
          albumsData = await fallback.json();
        }

        if (!albumsData?.length) throw new Error(t("error.no.albums.found"));
        return albumsData;
      } catch (error) {
        console.error("Error loading albums:", error);
        ErrorHandler.handleApiError(
          error instanceof Error ? error : new Error(String(error)),
        );
        return null;
      }
    }

    function startTimer() {
      timeLeft = ROUND_TIME;
      elements.timer.textContent = timeLeft.toString();
      isRoundActive = true;

      timerInterval = setInterval(() => {
        timeLeft--;
        elements.timer.textContent = timeLeft.toString();

        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          handleTimeout();
        }
      }, 1000);
    }

    function handleTimeout() {
      if (!isRoundActive) return;
      isRoundActive = false;
      elements.feedback.textContent = t("game.time.up");
      elements.feedback.classList.remove("hidden");
      elements.overlay.classList.remove("hidden");
      revealFullCover();
    }

    function calculateScore(timeLeft: number): number {
      return Math.round((BASE_POINTS * timeLeft) / ROUND_TIME);
    }

    function revealFullCover() {
      const pieces = Array.from(
        elements.coverPuzzle.children,
      ) as HTMLElement[];
      pieces.forEach((piece) => (piece.style.opacity = "1"));
    }

    function handleAnswer(selectedAnswer: string) {
      if (!isRoundActive || !currentAlbum) return;

      isRoundActive = false;
      clearInterval(timerInterval);
      revealFullCover();

      const isCorrect = selectedAnswer === currentAlbum.album;
      if (isCorrect) {
        correctAnswers++;
        const roundScore = calculateScore(timeLeft);
        score += roundScore;
        elements.score.textContent = score.toString();
        elements.feedback.textContent = `${t(
          "game.correct",
        )} +${roundScore} ${t("points")}`;
      } else {
        elements.feedback.textContent = `${t("game.incorrect")} ${
          currentAlbum.artist
        } - ${currentAlbum.album}`;
      }

      elements.feedback.classList.remove("hidden");
      elements.overlay.classList.remove("hidden");
    }

    async function loadNewRound() {
      elements.loadingSpinner.classList.remove("hidden");
      elements.container.setAttribute("data-hidden", "true");

      const albums = await loadAlbums();
      if (!albums) return;

      currentAlbum = albums[Math.floor(Math.random() * albums.length)];
      if (!currentAlbum) {
        console.error("No album selected for round");
        return;
      }

      const pieces = createPuzzleGrid(
        elements.coverPuzzle,
        currentAlbum.coverSrc,
      );
      createOptions(currentAlbum, albums, elements.options);

      // Initial reveal of some pieces
      revealRandomPieces(pieces, Math.floor(pieces.length * 0.3));

      // Set up periodic reveals
      const revealInterval = setInterval(() => {
        const allRevealed = revealRandomPieces(
          pieces,
          Math.floor(pieces.length * 0.1),
        );
        if (allRevealed) clearInterval(revealInterval);
      }, 3000);

      elements.container.removeAttribute("data-hidden");
      elements.loadingSpinner.classList.add("hidden");
      elements.feedback.classList.add("hidden");
      elements.overlay.classList.add("hidden");

      startTimer();
    }

    function endGame() {
      const config = {
        userId: elements.container.getAttribute("data-userID") || "",
        categoryName: "Cover Puzzle",
        difficulty: "medium",
        totalRounds: TOTAL_ROUNDS,
        correctAnswers,
        score,
        language: lang,
      };

      const ui = {
        showEndgamePopup: (score: number) => {
          const popup = document.getElementById("endgame-popup");
          const scoreElement = popup?.querySelector("#popup-score");

          if (popup && scoreElement) {
            scoreElement.textContent = score.toString();
            popup.setAttribute("data-score", score.toString());
            popup.classList.remove("hidden");
          }
        },
      };

      handleEndGame(config, ui, {
        onError: (error) => {
          ErrorHandler.handleSaveError(error, "score", {
            userId: config.userId,
            category: config.categoryName,
          });
        },
      });
    }

    // Event Listeners
    elements.options.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;
      if (target.tagName === "BUTTON") {
        handleAnswer(target.dataset.answer || "");
      }
    });

    elements.restartButton?.addEventListener("click", restartGame);

    elements.nextRoundButton.onclick = () => {
      if (roundIndex < TOTAL_ROUNDS - 1) {
        roundIndex++;
        elements.round.textContent = `${roundIndex + 1}/${TOTAL_ROUNDS}`;
        loadNewRound();
      } else {
        endGame();
      }
    };

    // Start first round
    loadNewRound();

    // Cleanup
    return () => {
      clearInterval(timerInterval);
      elements.restartButton?.removeEventListener("click", restartGame);
      stopAudio();
    };
  }

  document.addEventListener("DOMContentLoaded", () => {
    const elements = cacheElements();
    if (
      !elements.container ||
      !elements.coverPuzzle ||
      !elements.options ||
      !elements.score ||
      !elements.round ||
      !elements.timer
    ) {
      console.error(t("error.missing.elements"));
      return;
    }
    initializeGame(elements);
  });
</script>

<style is:global>
  .overlay.hidden {
    @apply hidden;
  }

  .popup.hidden {
    @apply hidden;
  }

  #question-container.hidden {
    @apply opacity-0;
  }

  /* High Contrast Mode Support */
  @media (forced-colors: active) {
    #question-container {
      border: 2px solid CanvasText;
    }

    #options > button {
      border: 1px solid ButtonText;
    }
  }

  /* Print Styles */
  @media print {
    #question-container {
      break-inside: avoid;
      border: 1px solid #000;
      box-shadow: none;
    }

    #options > button {
      break-inside: avoid;
      border: 1px solid #000;
    }
  }
</style>
