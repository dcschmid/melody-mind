---
/**
 * Knowledge Index Page Component
 *
 * This page displays a searchable and filterable grid of knowledge articles.
 * It's pre-rendered at build time for all supported languages to optimize performance.
 *
 * Accessibility Features:
 * - Semantic HTML with proper ARIA attributes (WCAG AAA compliance)
 * - High contrast text with 7:1 ratio for normal text
 * - Keyboard navigation between articles with arrow keys
 * - Screen reader announcements for search results
 * - Focus management for interactive elements
 * - Reduced motion support for animations
 *
 * Performance Optimizations:
 * - Static pre-rendering (SSG) for fast initial load
 * - Debounced search with batch processing for smooth UI
 * - Efficient DOM updates with requestAnimationFrame
 * - Optimized image loading with responsive sizes
 * - Touch interaction optimizations for mobile devices
 */
import type { AnyCollectionEntry, KnowledgeLanguage } from "astro:content";
import { getCollection } from "astro:content";
import KnowledgeCard from "@components/KnowledgeCard.astro";
import Layout from "@layouts/Layout.astro";
import { ui } from "../../../i18n/ui";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import { Icon } from "astro-icon/components";
import { calculateReadingTime } from "@utils/readingTime";
import { extractKeywords, generateMetaDescription } from "@utils/seo";

// Mark this route for static generation (SSG)
export const prerender = true;

/**
 * Generates static paths for all supported languages
 * This ensures fast page loads as everything is pre-rendered at build time
 * @returns {Array} Array of path objects with params and props
 */
export async function getStaticPaths() {
  // Define all supported languages for type safety
  const supportedLanguages = [
    "de",
    "en",
    "es",
    "fr",
    "it",
    "pt",
    "da",
    "nl",
    "sv",
    "fi",
  ] as const;

  // Process each language to generate static paths
  const paths = await Promise.all(
    supportedLanguages.map(async (lang) => {
      const collectionName = `knowledge-${lang}` as const;
      const articles = await getCollection(collectionName);

      // Extract and deduplicate keywords for filtering
      const allKeywords = [
        ...new Set(articles.flatMap((article) => article.data.keywords || [])),
      ].sort();

      return {
        params: { lang },
        props: { articles, allKeywords },
      };
    }),
  );

  return paths;
}

/**
 * Props interface for the Knowledge Index page
 */
interface Props {
  articles: AnyCollectionEntry[];
  allKeywords: string[];
}

// Get language from URL params and props from getStaticPaths
const { lang } = Astro.params as { lang: KnowledgeLanguage };
const { articles, allKeywords } = Astro.props;

/**
 * Type guard to check if language is a valid UI language
 * @param {KnowledgeLanguage} lang - The language code to check
 * @returns {boolean} True if language is supported in UI
 */
const isUiLanguage = (lang: KnowledgeLanguage): lang is keyof typeof ui => {
  return Object.keys(ui).includes(lang);
};

// Use English as fallback if language is not supported
const uiLang = isUiLanguage(lang) ? lang : "en";

// Calculate reading time for articles if not already provided
const articlesWithReadingTime = articles.map((article) => {
  if (article.data.readingTime === undefined) {
    const articleContent = article.body || article.data.description || "";
    const estimatedTime = calculateReadingTime(articleContent);

    return {
      ...article,
      data: {
        ...article.data,
        readingTime: estimatedTime,
      },
    };
  }
  return article;
});

// Sort articles alphabetically by image path for consistent ordering
const sortedArticles = [...articlesWithReadingTime].sort((a, b) =>
  (a.data.image || "").localeCompare(b.data.image || "", undefined, {
    sensitivity: "base",
  }),
);

// Generate SEO content
const title = ui[uiLang]["knowledge.title"];
const description = ui[uiLang]["knowledge.intro"];

// Enhanced SEO content using utility functions
const pageContent = `${title} ${description} ${sortedArticles.map((a) => `${a.data.title} ${a.data.description}`).join(" ")}`;

// Generate optimized meta description and keywords
const optimizedDescription = generateMetaDescription(pageContent);
const keywords = extractKeywords(pageContent) || ui[uiLang]["meta.keywords"];

// Additional structured data parameters for SEO
const pageType = "website";
const publishDate = new Date("2024-01-01");
const modifiedDate = new Date();

// Create structured data for CollectionPage
const collectionPageStructuredData = {
  "@context": "https://schema.org",
  "@type": "CollectionPage",
  "@id": `${Astro.site}${lang}/knowledge/`,
  "name": title,
  "description": optimizedDescription,
  "inLanguage": lang,
  "datePublished": publishDate.toISOString(),
  "dateModified": modifiedDate.toISOString(),
  "isPartOf": {
    "@type": "WebSite",
    "@id": `${Astro.site}`,
    "name": "Melody Mind",
    "url": Astro.site?.toString() || "https://melodymind.app"
  },
  "hasPart": {
    "@type": "ItemList",
    "itemListElement": sortedArticles.map((article, index) => ({
      "@type": "ListItem",
      "position": index + 1,
      "item": {
        "@type": "Article",
        "@id": `${Astro.site}${lang}/knowledge/${article.slug}`,
        "headline": article.data.title,
        "description": article.data.description,
        "image": article.data.image ? `${Astro.site}${article.data.image.startsWith('/') ? article.data.image : '/' + article.data.image}` : `${Astro.site}/default-cover.jpg`,
        "datePublished": article.data.createdAt instanceof Date ? article.data.createdAt.toISOString() : new Date().toISOString(),
        "dateModified": article.data.updatedAt instanceof Date ? article.data.updatedAt.toISOString() : new Date().toISOString(),
        "author": {
          "@type": "Organization",
          "name": "Melody Mind Team"
        },
        "publisher": {
          "@type": "Organization",
          "name": "Melody Mind",
          "logo": {
            "@type": "ImageObject",
            "url": `${Astro.site}/melody-mind.png`,
            "width": 192,
            "height": 192
          }
        },
        "inLanguage": lang,
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": `${Astro.site}${lang}/knowledge/${article.slug}`
        }
      }
    }))
  }
};

// Generate article structured data for each article
const articlesStructuredData = sortedArticles.map((article) => {
  const createdAt = article.data.createdAt instanceof Date
    ? article.data.createdAt
    : article.data.createdAt
      ? new Date(article.data.createdAt)
      : new Date();
      
  return {
    "@context": "https://schema.org",
    "@type": "Article",
    "@id": `${Astro.site}${lang}/knowledge/${article.slug}`,
    "headline": article.data.title,
    "description": article.data.description,
    "image": article.data.image ? `${Astro.site}${article.data.image.startsWith('/') ? article.data.image : '/' + article.data.image}` : `${Astro.site}/default-cover.jpg`,
    "datePublished": createdAt.toISOString(),
    "dateModified": article.data.updatedAt instanceof Date ? article.data.updatedAt.toISOString() : createdAt.toISOString(),
    "author": {
      "@type": "Organization",
      "name": "Melody Mind Team"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Melody Mind",
      "logo": {
        "@type": "ImageObject",
        "url": `${Astro.site}/melody-mind.png`,
        "width": 192,
        "height": 192
      }
    },
    "inLanguage": lang,
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": `${Astro.site}${lang}/knowledge/${article.slug}`
    }
  };
});
---

<Layout
  title={title}
  description={optimizedDescription}
  keywords={keywords}
  image={`/og-images/social-share-knowledge-${lang}.jpg`}
  type={pageType}
  publishDate={publishDate}
  modifiedDate={modifiedDate}
>
  <main class="max-w-6xl mx-auto px-4 py-8">
    <!-- Breadcrumbs navigation with structured data -->
    <nav aria-label="Breadcrumb" class="mb-6">
      <ol class="flex flex-wrap items-center text-sm text-zinc-300 space-x-2">
        <li class="flex items-center">
          <a
            href={`/${lang}/`}
            class="hover:text-purple-400 focus:text-purple-400 focus:outline-none focus-visible:ring-2 focus-visible:ring-purple-500 focus-visible:ring-offset-2 focus-visible:ring-offset-zinc-900 rounded px-1 py-0.5 transition-colors"
            aria-label={ui[uiLang]["nav.home"] || "Home"}
          >
            <Icon name="home" class="h-4 w-4" aria-hidden="true" />
            <span class="sr-only">{ui[uiLang]["nav.home"] || "Home"}</span>
          </a>
          <span class="mx-2" aria-hidden="true">/</span>
        </li>
        <li class="text-purple-400 font-medium" aria-current="page">
          {ui[uiLang]["knowledge.title"] || "Knowledge"}
        </li>
      </ol>
    </nav>

    <!-- Page header with improved semantic structure -->
    <header class="text-center mb-12">
      <Headline
        title={ui[uiLang]["knowledge.title"]}
        level="h1"
        className="text-white font-bold text-3xl md:text-4xl mb-4"
        id="page-heading"
      />
      <div
        class="h-1 w-24 bg-purple-500 rounded-full mx-auto mt-2 mb-6"
        aria-hidden="true"
      >
      </div>

      <Paragraph
        description={ui[uiLang]["knowledge.intro"]}
        className="max-w-2xl mx-auto text-zinc-100"
      />
    </header>

    <div class="w-full mb-8">
      <!-- Improved search and filtering with enhanced ARIA support -->
      <section
        class="search-filter-container bg-zinc-800/90 rounded-xl p-6 border border-zinc-700 shadow-lg mb-10"
        role="search"
        aria-labelledby="search-heading"
      >
        <h2 class="text-white text-xl font-medium mb-4" id="search-heading">
          {ui[uiLang]["knowledge.search.heading"] || "Search Articles"}
        </h2>

        <div class="flex flex-col md:flex-row gap-4 mb-4">
          <div class="relative flex-grow">
            <label for="searchInput" class="sr-only">
              {
                ui[uiLang]["knowledge.search.label"] ||
                  "Search by title, description or keywords"
              }
            </label>
            <div class="relative">
              <div
                class="absolute inset-y-0 left-3 flex items-center pointer-events-none"
                aria-hidden="true"
              >
                <Icon name="search" class="h-5 w-5 text-purple-400" />
              </div>
              <input
                type="search"
                id="searchInput"
                placeholder={ui[uiLang]["knowledge.search.placeholder"] ||
                  "Search articles..."}
                class="w-full py-3 pl-10 pr-4 bg-zinc-800 border-2 border-zinc-600
                       rounded-xl text-zinc-50 placeholder-zinc-400
                       focus:outline-none focus:border-purple-500 focus:ring-3
                       focus:ring-purple-500/50 transition-all duration-300"
                aria-controls="articlesGrid"
                aria-describedby="search-description"
                role="searchbox"
              />
              <div id="search-description" class="sr-only">
                {
                  ui[uiLang]["knowledge.search.description"] ||
                    "Articles will filter automatically as you type"
                }
              </div>
            </div>
          </div>

          <!-- Reset button for search field - Enhanced accessibility -->
          <button
            id="reset-search-inline"
            class="py-3 px-6 bg-zinc-700 hover:bg-zinc-600 focus:bg-zinc-600 text-zinc-100 rounded-xl focus:outline-none focus:ring-3 focus:ring-purple-500/50 transition-all duration-300 flex items-center justify-center gap-2"
            aria-label={ui[uiLang]["knowledge.search.reset"] || "Reset search"}
            type="button"
            aria-controls="articlesGrid"
          >
            <Icon name="close" class="h-5 w-5" aria-hidden="true" />
            <span>{ui[uiLang]["knowledge.search.reset.text"] || "Reset"}</span>
          </button>
        </div>

        <!-- Search status information for screen readers - Enhanced -->
        <div
          id="search-status"
          class="sr-only"
          aria-live="polite"
          aria-atomic="true"
          role="status"
        >
        </div>
      </section>

      <!-- No results message (initially hidden) - Improved for accessibility -->
      <div
        id="no-results"
        class="hidden transform-gpu bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl border border-zinc-600 text-center shadow-md mb-10"
        role="status"
        aria-live="assertive"
        aria-atomic="true"
      >
        <div class="flex flex-col items-center justify-center p-12">
          <Icon
            name="search-no-results"
            class="w-16 h-16 text-zinc-300 mb-4"
            aria-hidden="true"
            role="presentation"
          />
          <h2 class="text-zinc-100 text-xl font-medium">
            {ui[uiLang]["knowledge.no.results"] || "No articles found"}
          </h2>
          <p class="text-zinc-300 mt-2 mb-4">
            {
              ui[uiLang]["knowledge.no.results.help"] ||
                "Try different search terms or reset your search"
            }
          </p>
          <button
            id="reset-search"
            class="mt-2 px-6 py-3 bg-purple-600 hover:bg-purple-500 focus:bg-purple-500 text-white rounded-lg focus:outline-none focus:ring-3 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800 transition-all duration-300 flex items-center gap-2"
            aria-label="Reset search"
            type="button"
            aria-controls="articlesGrid"
          >
            <Icon name="refresh" class="h-5 w-5" aria-hidden="true" />
            <span>Reset Search</span>
          </button>
        </div>
      </div>

      <!-- Keyboard navigation instructions - Enhanced for screen readers -->
      <div
        class="sr-only"
        aria-live="polite"
        id="keyboard-instructions"
        role="region"
        aria-label="Keyboard navigation instructions"
      >
        <p>
          {
            ui[uiLang]["knowledge.keyboard.instructions"] ||
              "Use arrow keys to navigate between articles. Press Enter to open an article."
          }
        </p>
      </div>

      <!-- Articles grid with improved accessibility -->
      <section aria-labelledby="articles-heading" class="mb-12">
        <h2 id="articles-heading" class="sr-only">
          {ui[uiLang]["knowledge.articles.heading"] || "Knowledge Articles"}
        </h2>

        <ul
          id="articlesGrid"
          class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8"
          aria-labelledby="articles-heading"
        >
          {
            sortedArticles.length > 0 ? (
              sortedArticles.map((article, index) => {
                // Handle image path
                const imagePath = article.data.image || "/default-cover.jpg";

                // Handle date - ensure it's a valid Date object
                const createdAt =
                  article.data.createdAt instanceof Date
                    ? article.data.createdAt
                    : article.data.createdAt
                      ? new Date(article.data.createdAt)
                      : new Date();

                return (
                  <li
                    class="list-none animate-fadeIn"
                    style={`animation-delay: ${Math.min(index * 50, 500)}ms`}
                  >
                    <KnowledgeCard
                      title={article.data.title}
                      description={article.data.description}
                      image={article.data.image as string}
                      createdAt={createdAt}
                      slug={article.slug}
                      lang={lang}
                      readingTime={article.data.readingTime}
                      articleUrl={`/${lang}/knowledge/${article.slug}`}
                      keywords={article.data.keywords?.join(", ")}
                      index={index}
                    />
                  </li>
                );
              })
            ) : (
              <li class="col-span-full">
                <div class="flex flex-col items-center justify-center p-12 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl border border-zinc-600 text-center shadow-md">
                  <Icon
                    name="info"
                    class="w-16 h-16 text-zinc-300 mb-4"
                    aria-hidden="true"
                  />
                  <p class="text-zinc-100 text-lg font-medium">
                    {ui[uiLang]["knowledge.empty"] ||
                      "No articles found for this language"}
                  </p>
                </div>
              </li>
            )
          }
        </ul>
      </section>
    </div>

    <!-- "Back to top" button with enhanced accessibility -->
    <button
      id="back-to-top"
      class="fixed bottom-8 right-8 p-3 bg-purple-600 text-white rounded-full shadow-lg opacity-0 invisible transition-all duration-300 hover:bg-purple-500 focus:bg-purple-500 focus:outline-none focus:ring-3 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800 z-10"
      aria-label={ui[uiLang]["common.back.to.top"] || "Back to top"}
      type="button"
      aria-controls="page-heading"
      aria-hidden="true"
    >
      <Icon name="arrow-up" class="h-6 w-6" aria-hidden="true" />
      <span class="sr-only"
        >{ui[uiLang]["common.back.to.top"] || "Back to top"}</span
      >
    </button>
  </main>

  <!-- Structured Data for CollectionPage -->
  <script type="application/ld+json" set:html={JSON.stringify(collectionPageStructuredData)} />
  
  <!-- Structured Data for Articles -->
  {articlesStructuredData.map((articleData) => (
    <script type="application/ld+json" set:html={JSON.stringify(articleData)} />
  ))}

  <!-- Breadcrumb Structured Data -->
  <script type="application/ld+json">
    {JSON.stringify({
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        {
          "@type": "ListItem",
          "position": 1,
          "name": "Home",
          "item": `${Astro.site}${lang}/`
        },
        {
          "@type": "ListItem",
          "position": 2,
          "name": ui[uiLang]["knowledge.title"] || "Knowledge",
          "item": `${Astro.site}${lang}/knowledge/`
        }
      ]
    })}
  </script>

  <!-- Optimized Image Loading Script -->
  <script>
    // Use Intersection Observer for lazy loading images
    document.addEventListener('DOMContentLoaded', () => {
      const lazyImages = document.querySelectorAll('.lazy-image');
      
      if ('IntersectionObserver' in window) {
        const imageObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target as HTMLImageElement;
              img.style.opacity = '1';
              imageObserver.unobserve(img); // Stop observing once loaded
            }
          });
        }, {
          rootMargin: '50px 0px', // Load images a bit before they enter viewport
          threshold: 0.01
        });
        
        lazyImages.forEach(img => imageObserver.observe(img));
      } else {
        // Fallback for browsers that don't support Intersection Observer
        lazyImages.forEach(img => {
          (img as HTMLImageElement).style.opacity = '1';
        });
      }
    });
  </script>

  <!-- Optimized Search Function -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Cache DOM elements to avoid repeated queries
      const searchInput = document.getElementById('searchInput') as HTMLInputElement;
      const articlesGrid = document.getElementById('articlesGrid');
      const noResults = document.getElementById('no-results');
      const searchStatus = document.getElementById('search-status');
      const resetButtons = document.querySelectorAll('#reset-search, #reset-search-inline');
      
      if (!searchInput || !articlesGrid || !noResults || !searchStatus) return;
      
      // Cache all article elements for faster access
      const allArticles = Array.from(articlesGrid.querySelectorAll('li'));
      const totalArticles = allArticles.length;
      
      // Define types for article data
      type ArticleData = {
        element: HTMLElement;
        searchText: string;
      };
      
      // Create a Map for faster lookups during search
      const articleDataMap = new Map<HTMLElement, ArticleData>();
      
      // Pre-process article data once
      allArticles.forEach(article => {
        const card = article.querySelector('[data-testid="knowledge-card"]');
        if (card) {
          const title = card.getAttribute('data-title') || '';
          const description = card.getAttribute('data-description') || '';
          const keywords = card.getAttribute('data-keywords') || '';
          
          // Store pre-processed lowercase text for faster comparison
          articleDataMap.set(article as HTMLElement, {
            element: article as HTMLElement,
            searchText: `${title} ${description} ${keywords}`.toLowerCase()
          });
        }
      });
      
      // Debounce function to limit search frequency
      function debounce<F extends (...args: any[]) => any>(func: F, wait = 300) {
        let timeout: ReturnType<typeof setTimeout> | undefined;
        return function executedFunction(...args: Parameters<F>) {
          const later = () => {
            if (timeout) clearTimeout(timeout);
            func(...args);
          };
          if (timeout) clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      
      // Optimized search function with batch processing
      const performSearch = debounce((searchTerm: string) => {
        // Use requestAnimationFrame for smoother UI updates
        requestAnimationFrame(() => {
          const term = searchTerm.toLowerCase().trim();
          
          // Skip processing if search term is empty
          if (!term) {
            allArticles.forEach(article => {
              (article as HTMLElement).style.display = '';
            });
            noResults.classList.add('hidden');
            updateSearchStatus(totalArticles);
            return;
          }
          
          let visibleCount = 0;
          
          // Process in smaller batches for better responsiveness
          const batchSize = 10;
          const batches = Math.ceil(articleDataMap.size / batchSize);
          
          function processBatch(batchIndex: number) {
            if (batchIndex >= batches) {
              // All batches processed, update UI
              if (noResults) {
                if (visibleCount === 0) {
                  noResults.classList.remove('hidden');
                } else {
                  noResults.classList.add('hidden');
                }
              }
              
              updateSearchStatus(visibleCount);
              return;
            }
            
            const start = batchIndex * batchSize;
            const end = Math.min(start + batchSize, articleDataMap.size);
            
            // Process current batch
            Array.from(articleDataMap.entries())
              .slice(start, end)
              .forEach(([article, data]) => {
                const isMatch = data.searchText.includes(term);
                article.style.display = isMatch ? '' : 'none';
                if (isMatch) visibleCount++;
              });
            
            // Schedule next batch
            requestAnimationFrame(() => {
              processBatch(batchIndex + 1);
            });
          }
          
          // Start batch processing
          processBatch(0);
        });
      }, 250);
      
      // Update screen reader status
      function updateSearchStatus(count: number) {
        const message = count === 1
          ? '1 article found'
          : `${count} articles found`;
        
        if (searchStatus) {
          searchStatus.textContent = message;
        }
      }
      
      // Event listeners
      searchInput.addEventListener('input', (e) => {
        const target = e.target as HTMLInputElement;
        if (target) {
          performSearch(target.value);
        }
      });
      
      resetButtons.forEach(button => {
        button.addEventListener('click', () => {
          searchInput.value = '';
          performSearch('');
          searchInput.focus();
        });
      });
      
      // Initialize with empty search to ensure proper state
      performSearch('');
      
      // Keyboard navigation for articles
      document.addEventListener('keydown', (e) => {
        // Only handle arrow keys when focus is within the articles grid
        if (!articlesGrid.contains(document.activeElement)) return;
        
        const visibleArticles = allArticles.filter(
          article => (article as HTMLElement).style.display !== 'none'
        );
        
        if (visibleArticles.length === 0) return;
        
        const currentIndex = visibleArticles.findIndex(
          article => article.contains(document.activeElement as Node)
        );
        
        if (currentIndex === -1) return;
        
        let nextIndex: number;
        
        switch (e.key) {
          case 'ArrowRight':
            nextIndex = (currentIndex + 1) % visibleArticles.length;
            e.preventDefault();
            break;
          case 'ArrowLeft':
            nextIndex = (currentIndex - 1 + visibleArticles.length) % visibleArticles.length;
            e.preventDefault();
            break;
          case 'ArrowDown':
            // Move to the article below (assuming 3 columns)
            nextIndex = (currentIndex + 3) < visibleArticles.length
              ? currentIndex + 3
              : currentIndex;
            e.preventDefault();
            break;
          case 'ArrowUp':
            // Move to the article above (assuming 3 columns)
            nextIndex = (currentIndex - 3) >= 0
              ? currentIndex - 3
              : currentIndex;
            e.preventDefault();
            break;
          default:
            return;
        }
        
        // Focus the link in the next article
        const nextArticle = visibleArticles[nextIndex];
        const focusableElement = nextArticle.querySelector('a') || nextArticle;
        if (focusableElement && 'focus' in focusableElement) {
          (focusableElement as HTMLElement).focus();
        }
      });
      
      // Back to top button functionality
      const backToTopButton = document.getElementById('back-to-top');
      if (backToTopButton) {
        // Show/hide button based on scroll position
        window.addEventListener('scroll', () => {
          if (window.scrollY > 300) {
            backToTopButton.classList.remove('opacity-0', 'invisible');
          } else {
            backToTopButton.classList.add('opacity-0', 'invisible');
          }
        });
        
        // Scroll to top when clicked
        backToTopButton.addEventListener('click', () => {
          window.scrollTo({
            top: 0,
            behavior: 'smooth'
          });
        });
      }
    });
  </script>
</Layout>

<style>
  /* Improved color contrast for WCAG AAA (7:1) */
  :root {
    --text-primary: #ffffff; /* Maximum contrast */
    --text-secondary: #e2e2e7; /* Higher contrast than standard zinc-300 */
    --bg-card: #27272a; /* zinc-800 */
    --border-card: rgba(161, 161, 170, 0.3); /* zinc-400 with transparency */
    --accent-primary: #a855f7; /* purple-500 */
    --accent-secondary: #c084fc; /* purple-400 */
  }

  /* Animations for cards */
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fadeIn {
    animation: fadeIn 0.5s ease-out forwards;
    opacity: 0;
  }

  /* Enhanced keyboard focus styles for WCAG AAA */
  :focus-visible {
    outline: 3px solid var(--accent-primary) !important;
    outline-offset: 3px !important;
    box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.4) !important;
  }

  /* Verbesserter Hover-Effekt */
  .knowledge-card-container:hover {
    transform: translateY(-4px);
    transition:
      transform 0.3s ease-out,
      box-shadow 0.3s ease-out;
  }

  /* Verbesserte Back-to-Top Button Animation */
  #back-to-top.visible {
    opacity: 1;
    visibility: visible;
  }

  /* Verbesserte Touch-Interaktion für mobile Geräte */
  .knowledge-card-container {
    position: relative;
    cursor: pointer;
    transition:
      transform 0.3s ease,
      box-shadow 0.3s ease;
    transform: translateZ(0); /* Aktiviert Hardware-Beschleunigung */
    will-change: transform; /* Optimiert für Animation */
  }

  /* Verbesserte Touch-Interaktion - Entferne Konflikte mit KnowledgeCard */
  .knowledge-card-container a.card-link {
    position: relative;
    z-index: 5;
    display: block;
  }

  /* Entferne das after-Element, das Konflikte verursachen kann */
  .knowledge-card-container a.card-link::after {
    content: none;
  }

  /* Optimierte Touch-Feedback-Stile */
  @media (hover: none) {
    .knowledge-card-container:hover {
      transform: none; /* Verhindert Hover-Effekte auf Touch-Geräten */
    }

    /* Verwende Touch-spezifisches Styling */
    .knowledge-card-container {
      touch-action: manipulation; /* Optimiert für Touch-Interaktionen */
    }

    /* Leichteres Touch-Feedback */
    .touching {
      opacity: 0.8;
    }
  }

  /* Verbesserte Touch-Interaktion für mobile Geräte */
  .knowledge-card-container {
    position: relative;
    cursor: pointer;
    transition:
      transform 0.3s ease,
      box-shadow 0.3s ease;
  }

  .knowledge-card-container:active {
    transform: scale(0.98);
  }

  /* Vergrößerter klickbarer Bereich und verbesserte mobile Zugänglichkeit */
  .knowledge-card-container a.card-link {
    position: static;
  }

  .knowledge-card-container a.card-link::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10; /* Stellt sicher, dass der klickbare Bereich über anderen Elementen liegt */
  }

  /* Reduzierte Hover-Effekte für Touch-Geräte */
  @media (hover: none) {
    .knowledge-card-container:hover {
      transform: none;
    }

    /* Visuelles Feedback bei Berührung */
    .knowledge-card-container:active {
      background-color: rgba(168, 85, 247, 0.1);
    }

    /* Improved scroll vs. tap handling */
    .knowledge-card-container {
      touch-action: pan-y; /* Allow vertical scrolling */
    }
  }

  /* Disable animations if user prefers reduced motion */
  @media (prefers-reduced-motion: reduce) {
    *,
    ::before,
    ::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }

    .animate-fadeIn {
      opacity: 1;
      animation: none;
      transform: translateY(0);
    }

    .knowledge-card-container:hover {
      transform: none;
    }
  }

  /* Improved touch interaction with better scroll handling */
  @media (hover: none) {
    .knowledge-card-container:hover {
      transform: none; /* Prevents hover effects on touch devices */
    }

    /* Enable vertical scrolling */
    .knowledge-card-container {
      touch-action: pan-y;
    }

    /* Simple active state feedback */
    .knowledge-card-container:active {
      opacity: 0.9;
    }
  }

  /* Remove potentially problematic styles that intercept scrolling */
  .knowledge-card-container a.card-link::after {
    content: none;
  }

  /* Basic styles and animations */
  /* Simple hover effects - copied from gamehome approach */
  @media (hover: hover) {
    a:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      border-color: #6d28d9;
    }
  }

  /* Touch-specific styles */
  @media (hover: none) {
    a:active {
      opacity: 0.9;
      background-color: rgba(168, 85, 247, 0.05);
    }
  }

  /* Remove conflicting styles */
  .knowledge-card-container a.card-link::after {
    content: none;
  }

  /* Simple hover effects matching gamehome approach */
  @media (hover: hover) {
    #articlesGrid li a:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      border-color: #6d28d9;
    }
  }

  /* Touch-specific styles */
  @media (hover: none) {
    #articlesGrid li a:active {
      opacity: 0.8;
      background-color: rgba(168, 85, 247, 0.05);
    }
  }

  /* Remove all the old conflicting styles */
  .knowledge-card-container,
  .knowledge-card-container a.card-link,
  .knowledge-card-container a.card-link::after {
    /* Reset any potentially conflicting styles */
    all: unset;
  }

  /* Disable animations if user prefers reduced motion */
  @media (prefers-reduced-motion: reduce) {
    *,
    ::before,
    ::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }

    .animate-fadeIn {
      opacity: 1;
      animation: none;
      transform: translateY(0);
    }
  }
</style>

<script>
  /**
   * Knowledge Articles Search & Filtering System
   *
   * Features:
   * - High-performance search with debouncing and batch DOM updates
   * - Optimized keyboard navigation for WCAG AAA compliance
   * - Responsive touch interactions for mobile devices
   * - Screen reader announcements for search results
   * - Back-to-top functionality with proper focus management
   *
   * Performance Optimizations:
   * - Request Animation Frame for smooth UI updates
   * - Efficient DOM querying with cached selectors
   * - Batched processing for large article collections
   * - Hardware-accelerated animations
   * - Event delegation where appropriate
   */

  // Wait for DOM to be fully loaded
  document.addEventListener("DOMContentLoaded", initializeKnowledgeCenter);

  /**
   * Central configuration for easy maintenance
   */
  const CONFIG = {
    selectors: {
      searchInput: "#searchInput",
      articleGrid: "#articlesGrid",
      articleItems: "#articlesGrid li",
      noResults: "#no-results",
      searchStatus: "#search-status",
      resetSearch: "#reset-search",
      backToTop: "#back-to-top",
      articleLinks: "a.card-link",
      resetSearchInline: "#reset-search-inline",
    },
    timing: {
      debounceMs: 150, // Reduced for more responsive feel
      scrollDuration: 300,
    },
    performance: {
      batchSize: 10,
      frameThreshold: 16, // Target ~60fps (16ms per frame)
    },
    scroll: {
      topButtonThreshold: 400,
    },
    aria: {
      allResults: "All articles are displayed",
      filteredResults: "{count} of {total} articles found",
      noResults: "No articles match your search",
    },
  };

  // Type definitions for better TypeScript support
  interface KnowledgeCard {
    element: HTMLElement;
    title: string;
    description: string;
    keywords: string;
  }

  interface DOMElements {
    searchInput: HTMLInputElement | null;
    articleGrid: HTMLElement | null;
    noResults: HTMLElement | null;
    searchStatus: HTMLElement | null;
    resetButton: HTMLElement | null;
    resetButtonInline: HTMLElement | null;
    backToTopButton: HTMLElement | null;
    articles: HTMLElement[];
  }

  /**
   * Initialize the knowledge center functionality
   */
  function initializeKnowledgeCenter() {
    // Cache DOM elements for better performance
    const elements: DOMElements = {
      searchInput: document.querySelector(
        CONFIG.selectors.searchInput,
      ) as HTMLInputElement,
      articleGrid: document.querySelector(
        CONFIG.selectors.articleGrid,
      ) as HTMLElement,
      noResults: document.querySelector(
        CONFIG.selectors.noResults,
      ) as HTMLElement,
      searchStatus: document.querySelector(
        CONFIG.selectors.searchStatus,
      ) as HTMLElement,
      resetButton: document.querySelector(
        CONFIG.selectors.resetSearch,
      ) as HTMLElement,
      resetButtonInline: document.querySelector(
        CONFIG.selectors.resetSearchInline,
      ) as HTMLElement,
      backToTopButton: document.querySelector(
        CONFIG.selectors.backToTop,
      ) as HTMLElement,
      articles: Array.from(
        document.querySelectorAll(CONFIG.selectors.articleItems),
      ) as HTMLElement[],
    };

    // Skip initialization if required elements are missing
    if (!elements.searchInput || !elements.articleGrid) {
      console.warn(
        "Required elements not found. Knowledge center features disabled.",
      );
      return;
    }

    // Initialize state variables
    let isProcessing = false;
    let debounceTimer: number | null = null;
    let totalArticles = elements.articles.length;

    // Store indexable content for faster searching
    const searchableContent: KnowledgeCard[] = elements.articles.map(
      (article) => {
        const card = article.querySelector(".knowledge-card") as HTMLElement;
        return {
          element: article,
          title: (card?.dataset?.title || "").toLowerCase(),
          description: (card?.dataset?.description || "").toLowerCase(),
          keywords: (card?.dataset?.keywords || "").toLowerCase(),
        };
      },
    );

    // Set up event listeners
    initEventListeners();
    initBackToTopButton();
    initKeyboardNavigation();

    // Expose public API (useful for testing and potential external integrations)
    (window as any).knowledgeCenter = {
      filterByQuery: (query: string) => {
        if (elements.searchInput) {
          elements.searchInput.value = query;
          filterArticles();
        }
      },
      reset: resetSearch,
    };

    /**
     * Initialize all event listeners
     */
    function initEventListeners() {
      // Search input with efficient debounce
      elements.searchInput?.addEventListener("input", () => {
        if (debounceTimer) window.cancelAnimationFrame(debounceTimer);

        debounceTimer = window.requestAnimationFrame(() => {
          debounceTimer = window.requestAnimationFrame(() => {
            filterArticles();
            debounceTimer = null;
          });
        });
      });

      // Reset search button
      elements.resetButton?.addEventListener("click", resetSearch);
      elements.resetButtonInline?.addEventListener("click", resetSearch);

      // Make ESC key reset search
      document.addEventListener("keydown", (event: KeyboardEvent) => {
        if (event.key === "Escape" && elements.searchInput?.value) {
          resetSearch();
          event.preventDefault();
        }
      });
    }

    /**
     * Reset search and filters to default state
     */
    function resetSearch() {
      if (elements.searchInput) {
        elements.searchInput.value = "";
        filterArticles();
        elements.searchInput.focus();
      }
    }

    /**
     * Main filtering function for articles with performance optimizations
     */
    function filterArticles() {
      if (isProcessing) return;
      isProcessing = true;

      const query = elements.searchInput?.value.toLowerCase().trim() || "";

      // Fast path for empty queries - show everything
      if (!query) {
        showAllArticles();
        isProcessing = false;
        return;
      }

      // Use either batch or immediate processing based on collection size
      if (totalArticles > CONFIG.performance.batchSize) {
        processBatchedSearch(query);
      } else {
        processImmediateSearch(query);
      }
    }

    /**
     * Quickly show all articles (optimization for empty search)
     */
    function showAllArticles() {
      searchableContent.forEach((item) => {
        (item.element as HTMLElement).style.display = "";
      });

      updateResultsStatus(totalArticles);

      if (elements.noResults) {
        elements.noResults.classList.add("hidden");
        elements.noResults.classList.remove("flex");
      }
    }

    /**
     * Process search immediately for small collections
     */
    function processImmediateSearch(query: string) {
      let visibleCount = 0;

      // Filter articles based on query
      searchableContent.forEach((item) => {
        // Search in title, description and keywords
        const matches =
          item.title.includes(query) ||
          item.description.includes(query) ||
          item.keywords.includes(query);

        (item.element as HTMLElement).style.display = matches ? "" : "none";
        if (matches) visibleCount++;
      });

      // Update UI and announcements
      updateResultsStatus(visibleCount);
      isProcessing = false;
    }

    /**
     * Process articles in batches for smoother UI with large collections
     */
    function processBatchedSearch(query: string) {
      let index = 0;
      let visibleCount = 0;
      const startTime = performance.now();

      const processNextBatch = () => {
        const batchStartTime = performance.now();
        let batchCount = 0;

        // Process as many items as possible within our frame budget
        while (
          index < totalArticles &&
          performance.now() - batchStartTime <
            CONFIG.performance.frameThreshold &&
          batchCount < CONFIG.performance.batchSize
        ) {
          const item = searchableContent[index];

          // Search in title, description and keywords
          const matches =
            item.title.includes(query) ||
            item.description.includes(query) ||
            item.keywords.includes(query);

          (item.element as HTMLElement).style.display = matches ? "" : "none";
          if (matches) visibleCount++;

          index++;
          batchCount++;
        }

        // If there are more items to process, schedule next batch
        if (index < totalArticles) {
          window.requestAnimationFrame(processNextBatch);
        } else {
          // All batches processed
          updateResultsStatus(visibleCount);
          isProcessing = false;

          // Performance logging in development
          if (import.meta.env?.DEV) {
            console.log(
              `Search completed in ${performance.now() - startTime}ms`,
            );
          }
        }
      };

      // Start batch processing
      window.requestAnimationFrame(processNextBatch);
    }

    /**
     * Update UI and screen reader announcements based on filter results
     */
    function updateResultsStatus(visibleCount: number) {
      // Update screen reader announcements
      if (elements.searchStatus) {
        const statusMessage =
          visibleCount === 0
            ? CONFIG.aria.noResults
            : visibleCount === totalArticles
              ? CONFIG.aria.allResults
              : CONFIG.aria.filteredResults
                  .replace("{count}", String(visibleCount))
                  .replace("{total}", String(totalArticles));

        elements.searchStatus.textContent = statusMessage;
      }

      // Show/hide no results message
      if (elements.noResults) {
        if (visibleCount === 0) {
          elements.noResults.classList.remove("hidden");
          elements.noResults.classList.add("flex");
        } else {
          elements.noResults.classList.add("hidden");
          elements.noResults.classList.remove("flex");
        }
      }

      // Focus handling for accessibility
      if (elements.searchInput?.value) {
        if (visibleCount === 0) {
          // When no results, focus the no results message
          if (elements.noResults) {
            setTimeout(
              () => elements.noResults?.setAttribute("tabindex", "-1"),
              100,
            );
            setTimeout(() => {
              if (elements.noResults instanceof HTMLElement) {
                elements.noResults.focus();
              }
            }, 150);
          }
        } else if (visibleCount < totalArticles) {
          // When filtered, announce result count for screen readers
          const firstVisible = elements.articles.find(
            (a) => (a as HTMLElement).style.display !== "none",
          );
          // Don't auto-focus, just announce for screen readers
          // Let users navigate naturally
        }
      }
    }

    /**
     * Set up the back to top button with performance optimizations
     */
    function initBackToTopButton() {
      if (!elements.backToTopButton) return;

      let isScrolling = false;
      const scrollHandler = () => {
        if (isScrolling) return;
        isScrolling = true;

        window.requestAnimationFrame(() => {
          const showButton = window.scrollY > CONFIG.scroll.topButtonThreshold;
          elements.backToTopButton?.classList.toggle("visible", showButton);
          isScrolling = false;
        });
      };

      // Throttled scroll event
      window.addEventListener("scroll", scrollHandler, { passive: true });

      // Handle click with smooth scroll
      elements.backToTopButton.addEventListener("click", () => {
        // Use native smooth scroll or fallback
        if ("scrollBehavior" in document.documentElement.style) {
          window.scrollTo({ top: 0, behavior: "smooth" });
        } else {
          // Fallback for browsers without smooth scroll
          window.scrollTo(0, 0);
        }

        // Focus management after scroll
        setTimeout(() => {
          elements.searchInput?.focus();
        }, CONFIG.timing.scrollDuration);
      });
    }

    /**
     * Set up keyboard navigation for articles with arrow keys
     */
    function initKeyboardNavigation() {
      elements.articleGrid?.addEventListener(
        "keydown",
        (event: KeyboardEvent) => {
          // Only handle arrow keys
          if (
            !["ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp"].includes(
              event.key,
            )
          )
            return;

          // Focus handling
          const visibleLinks = [
            ...document.querySelectorAll(
              `${CONFIG.selectors.articleItems}:not([style*="display: none"]) a`,
            ),
          ] as HTMLElement[];
          if (!visibleLinks.length) return;

          const currentIndex = visibleLinks.findIndex(
            (link) => link === document.activeElement,
          );
          if (currentIndex === -1) return;

          // Determine number of columns based on viewport width
          const columns =
            window.innerWidth >= 1024 ? 3 : window.innerWidth >= 640 ? 2 : 1;
          let targetIndex = currentIndex;

          // Calculate new target based on arrow key
          switch (event.key) {
            case "ArrowRight":
              targetIndex = Math.min(currentIndex + 1, visibleLinks.length - 1);
              break;
            case "ArrowLeft":
              targetIndex = Math.max(currentIndex - 1, 0);
              break;
            case "ArrowDown":
              targetIndex = Math.min(
                currentIndex + columns,
                visibleLinks.length - 1,
              );
              break;
            case "ArrowUp":
              targetIndex = Math.max(currentIndex - columns, 0);
              break;
          }

          // Move focus if changed
          if (targetIndex !== currentIndex && visibleLinks[targetIndex]) {
            event.preventDefault();
            visibleLinks[targetIndex].focus();
          }
        },
      );
    }
  }
</script>
