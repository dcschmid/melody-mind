---
/**
 * Knowledge Index Page Component
 *
 * This page displays a searchable and filterable grid of knowledge articles.
 * It's pre-rendered at build time for all supported languages to optimize performance.
 *
 * Accessibility Features:
 * - Semantic HTML with proper ARIA attributes (WCAG AAA compliance)
 * - High contrast text with 7:1 ratio for normal text
 * - Keyboard navigation between articles with arrow keys
 * - Screen reader announcements for search results
 * - Focus management for interactive elements
 * - Reduced motion support for animations
 *
 * Performance Optimizations:
 * - Static pre-rendering (SSG) for fast initial load
 * - Debounced search with batch processing for smooth UI
 * - Efficient DOM updates with requestAnimationFrame
 * - Optimized image loading with responsive sizes
 * - Touch interaction optimizations for mobile devices
 */
import type { AnyCollectionEntry, KnowledgeLanguage } from "astro:content";
import { getCollection } from "astro:content";
import KnowledgeCard from "@components/KnowledgeCard.astro";
import Layout from "@layouts/Layout.astro";
import { ui } from "../../../i18n/ui";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import { Icon } from "astro-icon/components";
import { calculateReadingTime } from "@utils/readingTime";
import { extractKeywords, generateMetaDescription } from "@utils/seo";

// Mark this route for static generation (SSG)
export const prerender = true;

/**
 * Generates static paths for all supported languages
 * This ensures fast page loads as everything is pre-rendered at build time
 * @returns {Array} Array of path objects with params and props
 */
export async function getStaticPaths() {
  // Define all supported languages for type safety
  const supportedLanguages = ["de", "en", "es", "fr", "it", "pt", "da", "nl", "sv", "fi"] as const;

  // Process each language to generate static paths
  const paths = await Promise.all(
    supportedLanguages.map(async (lang) => {
      const collectionName = `knowledge-${lang}` as const;
      const articles = await getCollection(collectionName);

      // Extract and deduplicate keywords for filtering
      const allKeywords = [
        ...new Set(articles.flatMap((article) => article.data.keywords || [])),
      ].sort();

      return {
        params: { lang },
        props: { articles, allKeywords },
      };
    })
  );

  return paths;
}

/**
 * Props interface for the Knowledge Index page
 */
interface Props {
  articles: AnyCollectionEntry[];
}

// Get language from URL params and props from getStaticPaths
const { lang } = Astro.params as { lang: KnowledgeLanguage };
const { articles } = Astro.props;

/**
 * Type guard to check if language is a valid UI language
 * @param {KnowledgeLanguage} lang - The language code to check
 * @returns {boolean} True if language is supported in UI
 */
const isUiLanguage = (lang: KnowledgeLanguage): lang is keyof typeof ui => {
  return Object.keys(ui).includes(lang);
};

// Use English as fallback if language is not supported
const uiLang = isUiLanguage(lang) ? lang : "en";

// Calculate reading time for articles if not already provided
const articlesWithReadingTime = articles.map((article) => {
  if (article.data.readingTime === undefined) {
    const articleContent = article.body || article.data.description || "";
    const estimatedTime = calculateReadingTime(articleContent);

    return {
      ...article,
      data: {
        ...article.data,
        readingTime: estimatedTime,
      },
    };
  }
  return article;
});

// Sort articles alphabetically by image path for consistent ordering
const sortedArticles = [...articlesWithReadingTime].sort((a, b) =>
  (a.data.image || "").localeCompare(b.data.image || "", undefined, {
    sensitivity: "base",
  })
);

// Generate SEO content
const title = ui[uiLang]["knowledge.title"];
const description = ui[uiLang]["knowledge.intro"];

// Enhanced SEO content using utility functions
const pageContent = `${title} ${description} ${sortedArticles.map((a) => `${a.data.title} ${a.data.description}`).join(" ")}`;

// Generate optimized meta description and keywords
const optimizedDescription = generateMetaDescription(pageContent);
const keywords = extractKeywords(pageContent) || ui[uiLang]["meta.keywords"];

// Additional structured data parameters for SEO
const pageType = "website";
const publishDate = new Date("2024-01-01");
const modifiedDate = new Date();

// Create structured data for CollectionPage
const collectionPageStructuredData = {
  "@context": "https://schema.org",
  "@type": "CollectionPage",
  "@id": `${Astro.site}${lang}/knowledge/`,
  name: title,
  description: optimizedDescription,
  inLanguage: lang,
  datePublished: publishDate.toISOString(),
  dateModified: modifiedDate.toISOString(),
  isPartOf: {
    "@type": "WebSite",
    "@id": `${Astro.site}`,
    name: "Melody Mind",
    url: Astro.site?.toString() || "https://melodymind.app",
  },
  hasPart: {
    "@type": "ItemList",
    itemListElement: sortedArticles.map((article, index) => ({
      "@type": "ListItem",
      position: index + 1,
      item: {
        "@type": "Article",
        "@id": `${Astro.site}${lang}/knowledge/${article.slug}`,
        headline: article.data.title,
        description: article.data.description,
        image: article.data.image
          ? `${Astro.site}${article.data.image.startsWith("/") ? article.data.image : `/${article.data.image}`}`
          : `${Astro.site}/default-cover.jpg`,
        datePublished:
          article.data.createdAt instanceof Date
            ? article.data.createdAt.toISOString()
            : new Date().toISOString(),
        dateModified:
          article.data.updatedAt instanceof Date
            ? article.data.updatedAt.toISOString()
            : new Date().toISOString(),
        author: {
          "@type": "Organization",
          name: "Melody Mind Team",
        },
        publisher: {
          "@type": "Organization",
          name: "Melody Mind",
          logo: {
            "@type": "ImageObject",
            url: `${Astro.site}/melody-mind.png`,
            width: 192,
            height: 192,
          },
        },
        inLanguage: lang,
        mainEntityOfPage: {
          "@type": "WebPage",
          "@id": `${Astro.site}${lang}/knowledge/${article.slug}`,
        },
      },
    })),
  },
};

// Generate article structured data for each article
const articlesStructuredData = sortedArticles.map((article) => {
  const createdAt =
    article.data.createdAt instanceof Date
      ? article.data.createdAt
      : article.data.createdAt
        ? new Date(article.data.createdAt)
        : new Date();

  return {
    "@context": "https://schema.org",
    "@type": "Article",
    "@id": `${Astro.site}${lang}/knowledge/${article.slug}`,
    headline: article.data.title,
    description: article.data.description,
    image: article.data.image
      ? `${Astro.site}${article.data.image.startsWith("/") ? article.data.image : `/${article.data.image}`}`
      : `${Astro.site}/default-cover.jpg`,
    datePublished: createdAt.toISOString(),
    dateModified:
      article.data.updatedAt instanceof Date
        ? article.data.updatedAt.toISOString()
        : createdAt.toISOString(),
    author: {
      "@type": "Organization",
      name: "Melody Mind Team",
    },
    publisher: {
      "@type": "Organization",
      name: "Melody Mind",
      logo: {
        "@type": "ImageObject",
        url: `${Astro.site}/melody-mind.png`,
        width: 192,
        height: 192,
      },
    },
    inLanguage: lang,
    mainEntityOfPage: {
      "@type": "WebPage",
      "@id": `${Astro.site}${lang}/knowledge/${article.slug}`,
    },
  };
});
---

<Layout
  {title}
  description={optimizedDescription}
  {keywords}
  image={`/og-images/social-share-knowledge-${lang}.jpg`}
  type={pageType}
  {publishDate}
  {modifiedDate}
>
  <!-- Screen reader announcements for dynamic content changes -->
  <div id="sr-announce" class="sr-only" aria-live="polite" aria-atomic="true"></div>

  <main class="mx-auto max-w-6xl px-4 py-8" id="main-content">
    <!-- Breadcrumbs navigation with structured data -->
    <nav aria-label="Breadcrumb" class="mb-6">
      <ol class="flex flex-wrap items-center space-x-2 text-base text-zinc-300">
        <li class="flex items-center">
          <a
            href={`/${String(lang)}/`}
            class="rounded px-2 py-1 transition-colors hover:text-purple-400 focus:text-purple-400 focus:outline-none focus-visible:ring-3 focus-visible:ring-purple-500 focus-visible:ring-offset-3 focus-visible:ring-offset-zinc-900"
            aria-label={ui[uiLang]["nav.home"] || "Home"}
          >
            <Icon name="home" class="h-5 w-5" aria-hidden="true" />
            <span class="sr-only">{ui[uiLang]["nav.home"] || "Home"}</span>
          </a>
          <span class="mx-2" aria-hidden="true">/</span>
        </li>
        <li class="font-medium text-purple-400" aria-current="page">
          {ui[uiLang]["knowledge.title"] || "Knowledge"}
        </li>
      </ol>
    </nav>

    <!-- Page header with improved semantic structure -->
    <header class="mb-12 text-center">
      <Headline
        title={ui[uiLang]["knowledge.title"]}
        level="h1"
        className="mb-4 text-3xl font-bold tracking-wide text-white md:text-4xl"
        id="page-heading"
      />
      <div class="mx-auto mt-2 mb-6 h-1 w-24 rounded-full bg-purple-500" aria-hidden="true"></div>

      <Paragraph
        description={ui[uiLang]["knowledge.intro"]}
        className="mx-auto max-w-2xl text-xl leading-relaxed text-zinc-100"
      />
    </header>

    <div class="mb-8 w-full">
      <!-- Improved search and filtering with enhanced ARIA support -->
      <section
        class="search-filter-container mb-10 rounded-xl border-2 border-zinc-600 bg-zinc-800/90 p-8 shadow-lg"
        role="search"
        aria-labelledby="search-heading"
      >
        <h2 class="mb-6 text-2xl font-medium text-white" id="search-heading">
          {ui[uiLang]["knowledge.search.heading"] || "Search Articles"}
        </h2>
        <div class="mb-4 flex flex-col gap-4 md:flex-row">
          <div class="relative flex-grow">
            <label for="searchInput" class="sr-only">
              {ui[uiLang]["knowledge.search.label"] || "Search by title, description or keywords"}
            </label>
            <div class="relative">
              <div
                class="pointer-events-none absolute inset-y-0 left-3 flex items-center"
                aria-hidden="true"
              >
                <Icon name="search" class="h-6 w-6 text-purple-400" />
              </div>
              <input
                type="search"
                id="searchInput"
                placeholder={ui[uiLang]["knowledge.search.placeholder"] || "Search articles..."}
                class="w-full rounded-xl border-2 border-zinc-600 bg-zinc-800 py-4 pr-4 pl-12 text-lg text-zinc-50 placeholder-zinc-400 transition-all duration-300 focus:border-purple-500 focus:ring-4 focus:ring-purple-500/50 focus:outline-none"
                aria-controls="articlesGrid search-results-region"
                aria-describedby="search-description search-status"
                autocomplete="off"
                aria-autocomplete="list"
                aria-required="false"
                data-search-input
              />
              <div id="search-description" class="sr-only">
                {
                  ui[uiLang]["knowledge.search.description"] ||
                    "Articles will filter automatically as you type. Use arrow keys to navigate between results."
                }
              </div>
            </div>
          </div>

          <!-- Reset button for search field - Enhanced accessibility -->
          <button
            id="reset-search-inline"
            class="flex items-center justify-center gap-3 rounded-xl bg-zinc-700 px-8 py-4 text-lg font-medium text-zinc-100 transition-all duration-300 hover:bg-zinc-600 focus:bg-zinc-600 focus:ring-4 focus:ring-purple-500/50 focus:outline-none"
            aria-label={ui[uiLang]["knowledge.search.reset"] || "Reset search"}
            type="button"
            aria-controls="articlesGrid"
          >
            <Icon name="close" class="h-6 w-6" aria-hidden="true" />
            <span>{ui[uiLang]["knowledge.search.reset.text"] || "Reset"}</span>
          </button>
        </div>

        <!-- Search status information for screen readers - Enhanced -->
        <div
          id="search-status"
          class="sr-only"
          aria-live="polite"
          aria-atomic="true"
          role="status"
          data-search-status
        >
          {ui[uiLang]["knowledge.search.initial"] || "Showing all articles. Type to filter."}
        </div>

        <!-- Additional detailed search status for screen readers -->
        <div
          id="search-details"
          class="sr-only"
          aria-live="polite"
          aria-atomic="true"
          role="status"
        >
          <!-- Will be populated via JavaScript -->
        </div>
      </section>

      <!-- No results message (initially hidden) - Improved for accessibility -->
      <div
        id="no-results"
        class="mb-10 hidden transform-gpu rounded-xl border border-zinc-600 bg-gradient-to-br from-zinc-700 to-zinc-800 text-center shadow-md"
        role="status"
        aria-live="assertive"
        aria-atomic="true"
      >
        <div class="flex flex-col items-center justify-center p-12">
          <Icon
            name="search-no-results"
            class="mb-6 h-20 w-20 text-zinc-300"
            aria-hidden="true"
            role="presentation"
          />
          <h2 class="text-2xl font-medium text-zinc-100">
            {ui[uiLang]["knowledge.no.results"] || "No articles found"}
          </h2>
          <p class="mt-3 mb-6 text-xl text-zinc-300">
            {
              ui[uiLang]["knowledge.no.results.help"] ||
                "Try different search terms or reset your search"
            }
          </p>
          <button
            id="reset-search"
            class="mt-3 flex items-center gap-3 rounded-lg bg-purple-600 px-8 py-4 text-lg font-medium text-white transition-all duration-300 hover:bg-purple-500 focus:bg-purple-500 focus:ring-4 focus:ring-purple-500/50 focus:ring-offset-3 focus:ring-offset-zinc-800 focus:outline-none"
            aria-label={ui[uiLang]["knowledge.search.reset"] || "Reset search"}
            type="button"
            aria-controls="articlesGrid"
          >
            <Icon name="refresh" class="h-6 w-6" aria-hidden="true" />
            <span>{ui[uiLang]["knowledge.search.reset"] || "Reset Search"}</span>
          </button>
        </div>
      </div>

      <!-- Keyboard navigation instructions - Enhanced for screen readers -->
      <div
        class="sr-only"
        aria-live="polite"
        id="keyboard-instructions"
        role="region"
        aria-label="Keyboard navigation instructions"
      >
        <p>
          {
            ui[uiLang]["knowledge.keyboard.instructions"] ||
              "Use arrow keys to navigate between articles. Press Enter to open an article."
          }
        </p>
      </div>

      <!-- Articles grid with improved accessibility -->
      <section aria-labelledby="articles-heading" class="mb-12" id="search-results-region">
        <h2 id="articles-heading" class="sr-only">
          {ui[uiLang]["knowledge.articles.heading"] || "Knowledge Articles"}
        </h2>

        <ul
          id="articlesGrid"
          class="grid grid-cols-1 gap-8 sm:grid-cols-2 md:gap-10 lg:grid-cols-3"
          aria-labelledby="articles-heading"
        >
          {
            sortedArticles.length > 0 ? (
              sortedArticles.map((article, index) => {
                // Handle date - ensure it's a valid Date object
                const createdAt =
                  article.data.createdAt instanceof Date
                    ? article.data.createdAt
                    : article.data.createdAt
                      ? new Date(article.data.createdAt)
                      : new Date();

                return (
                  <li
                    class="translate-y-2 transform list-none opacity-0 motion-safe:animate-[fadeIn_0.5s_ease-out_forwards]"
                    style={`animation-delay: ${Math.min(index * 50, 500)}ms`}
                  >
                    <KnowledgeCard
                      title={article.data.title}
                      description={article.data.description}
                      image={article.data.image as string}
                      createdAt={createdAt}
                      slug={article.slug}
                      lang={lang}
                      readingTime={article.data.readingTime}
                      articleUrl={`/${String(lang)}/knowledge/${article.slug}`}
                      keywords={article.data.keywords?.join(", ")}
                      index={index}
                    />
                  </li>
                );
              })
            ) : (
              <li class="col-span-full">
                <div class="flex flex-col items-center justify-center rounded-xl border border-zinc-600 bg-gradient-to-br from-zinc-700 to-zinc-800 p-12 text-center shadow-md">
                  <Icon name="info" class="mb-6 h-20 w-20 text-zinc-300" aria-hidden="true" />
                  <p class="text-2xl font-medium text-zinc-100">
                    {ui[uiLang]["knowledge.empty"] || "No articles found for this language"}
                  </p>
                </div>
              </li>
            )
          }
        </ul>
      </section>
    </div>

    <!-- "Back to top" button with enhanced accessibility -->
    <button
      id="back-to-top"
      class="invisible fixed right-8 bottom-8 z-10 rounded-full bg-purple-600 p-4 text-white opacity-0 shadow-lg transition-all duration-300 peer-data-[visible]:visible peer-data-[visible]:opacity-100 hover:bg-purple-500 focus:bg-purple-500 focus:ring-4 focus:ring-purple-500/50 focus:ring-offset-3 focus:ring-offset-zinc-800 focus:outline-none"
      aria-label={ui[uiLang]["common.back.to.top"] || "Back to top"}
      type="button"
      aria-controls="page-heading"
      aria-hidden="true"
    >
      <Icon name="arrow-up" class="h-8 w-8" aria-hidden="true" />
      <span class="sr-only">{ui[uiLang]["common.back.to.top"] || "Back to top"}</span>
    </button>
  </main>

  <!-- Structured Data for CollectionPage -->
  <script type="application/ld+json" set:html={JSON.stringify(collectionPageStructuredData)} />

  <!-- Structured Data for Articles -->
  {
    articlesStructuredData.map((articleData) => (
      <script type="application/ld+json" set:html={JSON.stringify(articleData)} />
    ))
  }

  <!-- Breadcrumb Structured Data -->
  <script
    type="application/ld+json"
    set:html={JSON.stringify({
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: "Home",
          item: `${Astro.site}${lang}/`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: ui[uiLang]["knowledge.title"] || "Knowledge",
          item: `${Astro.site}${lang}/knowledge/`,
        },
      ],
    })}
  />

  <!-- Optimized Search Function -->
  <script>
    /**
     * Knowledge Page Search & Interaction Module
     *
     * Features:
     * - High-performance search with debouncing and batch DOM updates
     * - Optimized keyboard navigation for WCAG AAA compliance
     * - Responsive touch interactions for mobile devices
     * - Screen reader announcements for search results
     * - ESC key to reset search
     * - Back-to-top functionality with proper focus management
     *
     * Performance Optimizations:
     * - Request Animation Frame for smooth UI updates
     * - Efficient DOM querying with cached selectors
     * - Batched processing for large article collections
     */

    /**
     * Generic debounce function to limit function call frequency
     * @param {Function} func - The function to debounce
     * @param {number} [wait=300] - The debounce wait time in milliseconds
     * @returns {Function} A debounced version of the input function
     */
    function debounce<T extends unknown[]>(
      func: (...args: T) => unknown,
      wait = 300
    ): (...args: T) => void {
      let timeout: ReturnType<typeof setTimeout> | undefined;
      return function executedFunction(...args: T): void {
        const later = (): void => {
          if (timeout) {
            clearTimeout(timeout);
          }
          func(...args);
        };
        if (timeout) {
          clearTimeout(timeout);
        }
        timeout = setTimeout(later, wait);
      };
    }

    /**
     * Updates the screen reader status with search results count
     * @param {HTMLElement} statusElement - The status element to update
     * @param {number} count - Number of items found
     * @param {number} total - Total number of items
     * @returns {void}
     */
    function updateSearchStatus(
      statusElement: HTMLElement,
      count: number,
      total: number = 0
    ): void {
      let message = "";

      // Static translations for client-side script
      const translations = {
        noArticles: "No articles found",
        oneArticle: "1 article found",
        allArticles: "All {count} articles displayed",
        countArticles: "{count} of {total} articles found",
        resultsFormat:
          'Search results for "{term}": {count} of {total} articles match your search.',
        noResultsFormat: 'No articles match your search for "{term}". Try different keywords.',
        showingAll: "Showing all {total} articles.",
      };

      if (count === 0) {
        message = translations.noArticles;
      } else if (count === 1) {
        message = translations.oneArticle;
      } else if (count === total) {
        message = translations.allArticles.replace("{count}", count.toString());
      } else {
        message = translations.countArticles
          .replace("{count}", count.toString())
          .replace("{total}", total.toString());
      }

      statusElement.textContent = message;

      // Update detailed search information for screen readers
      const searchDetailsElement = document.getElementById("search-details");
      if (searchDetailsElement) {
        const searchInput = document.getElementById("searchInput") as HTMLInputElement;
        const searchTerm = searchInput?.value || "";

        if (searchTerm) {
          const detailedMessage =
            count > 0
              ? translations.resultsFormat
                  .replace("{term}", searchTerm)
                  .replace("{count}", count.toString())
                  .replace("{total}", total.toString())
              : translations.noResultsFormat.replace("{term}", searchTerm);

          searchDetailsElement.textContent = detailedMessage;
        } else {
          searchDetailsElement.textContent = translations.showingAll.replace(
            "{total}",
            total.toString()
          );
        }
      }

      // Update aria-expanded state based on whether we're filtering
      const searchInput = document.getElementById("searchInput") as HTMLInputElement;
      if (searchInput) {
        searchInput.setAttribute("aria-expanded", searchInput.value.length > 0 ? "true" : "false");
      }
    }

    /**
     * Processes a batch of search results for smoother UI updates
     * @param {Object} params - Parameters for batch processing
     * @returns {void}
     */
    function processBatch(params: {
      batchIndex: number;
      batches: number;
      term: string;
      articleDataMap: Map<HTMLElement, { element: HTMLElement; searchText: string }>;
      batchSize: number;
      noResultsElement: HTMLElement;
      statusElement: HTMLElement;
      visibleCount: number;
      firstVisible: HTMLElement | null;
      totalArticles: number;
    }): void {
      const {
        batchIndex,
        batches,
        term,
        articleDataMap,
        batchSize,
        noResultsElement,
        statusElement,
        totalArticles,
      } = params;

      let visibleCount = params.visibleCount;
      let firstVisible = params.firstVisible;

      if (batchIndex >= batches) {
        // All batches processed, update UI
        if (noResultsElement) {
          if (visibleCount === 0) {
            noResultsElement.classList.remove("hidden");
            noResultsElement.classList.add("flex");
          } else {
            noResultsElement.classList.add("hidden");
            noResultsElement.classList.remove("flex");
          }
        }

        updateSearchStatus(statusElement, visibleCount, totalArticles);
        return;
      }

      const start = batchIndex * batchSize;
      const end = Math.min(start + batchSize, articleDataMap.size);

      // Process current batch
      Array.from(articleDataMap.entries())
        .slice(start, end)
        .forEach(([_article, item]) => {
          const matches = item.searchText.includes(term);
          item.element.style.display = matches ? "" : "none";
          if (matches && !firstVisible) {
            firstVisible = item.element;
          }
          if (matches) {
            visibleCount++;
          }
        });

      // Schedule next batch with updated counts
      requestAnimationFrame(() => {
        processBatch({
          ...params,
          batchIndex: batchIndex + 1,
          visibleCount: visibleCount,
          firstVisible: firstVisible,
        });
      });
    }

    /**
     * Creates a search function that processes results in batches
     * @param {Object} params - Parameters for the search function
     * @returns {Function} A debounced search function
     */
    function createSearchFunction(params: {
      allArticles: HTMLElement[];
      totalArticles: number;
      articleDataMap: Map<HTMLElement, { element: HTMLElement; searchText: string }>;
      elements: {
        noResults: HTMLElement;
        searchStatus: HTMLElement;
      };
      config: {
        batchSize: number;
        debounceWait: number;
      };
    }): (searchTerm: string) => void {
      const { allArticles, totalArticles, articleDataMap, elements, config } = params;

      return debounce((searchTerm: string): void => {
        // Use requestAnimationFrame for smoother UI updates
        requestAnimationFrame(() => {
          const term = searchTerm.toLowerCase().trim();

          // Skip processing if search term is empty
          if (!term) {
            allArticles.forEach((article) => {
              article.style.display = "";
            });
            elements.noResults.classList.add("hidden");
            elements.noResults.classList.remove("flex");
            updateSearchStatus(elements.searchStatus, totalArticles, totalArticles);
            return;
          }

          // Start batch processing with initial values
          processBatch({
            batchIndex: 0,
            batches: Math.ceil(articleDataMap.size / config.batchSize),
            term,
            articleDataMap,
            batchSize: config.batchSize,
            noResultsElement: elements.noResults,
            statusElement: elements.searchStatus,
            visibleCount: 0,
            firstVisible: null,
            totalArticles,
          });
        });
      }, config.debounceWait);
    }

    /**
     * Handles keyboard navigation between articles
     * @param {KeyboardEvent} e - Keyboard event
     * @param {HTMLElement} articlesGrid - The articles grid element
     * @param {HTMLElement[]} allArticles - Array of all article elements
     * @returns {void}
     */
    function handleKeyboardNavigation(
      e: KeyboardEvent,
      articlesGrid: HTMLElement,
      allArticles: HTMLElement[]
    ): void {
      // Only handle arrow keys when focus is within the articles grid
      if (!articlesGrid.contains(document.activeElement)) {
        return;
      }

      const visibleArticles = allArticles.filter((article) => article.style.display !== "none");

      if (visibleArticles.length === 0) {
        return;
      }

      const currentIndex = visibleArticles.findIndex((article) =>
        article.contains(document.activeElement as Node)
      );

      if (currentIndex === -1) {
        return;
      }

      let nextIndex: number;

      // Determine number of columns based on viewport width for better navigation
      const columns = window.innerWidth >= 1024 ? 3 : window.innerWidth >= 640 ? 2 : 1;

      switch (e.key) {
        case "ArrowRight":
          nextIndex = (currentIndex + 1) % visibleArticles.length;
          e.preventDefault();
          break;
        case "ArrowLeft":
          nextIndex = (currentIndex - 1 + visibleArticles.length) % visibleArticles.length;
          e.preventDefault();
          break;
        case "ArrowDown":
          // Move to the article below (using responsive column count)
          nextIndex =
            currentIndex + columns < visibleArticles.length ? currentIndex + columns : currentIndex;
          e.preventDefault();
          break;
        case "ArrowUp":
          // Move to the article above (using responsive column count)
          nextIndex = currentIndex - columns >= 0 ? currentIndex - columns : currentIndex;
          e.preventDefault();
          break;
        default:
          return;
      }

      // Focus the link in the next article
      const nextArticle = visibleArticles[nextIndex];
      const focusableElement = nextArticle.querySelector("a") || nextArticle;
      if (focusableElement && "focus" in focusableElement) {
        (focusableElement as HTMLElement).focus();
      }
    }

    // Main initialization function when DOM is ready
    document.addEventListener("DOMContentLoaded", () => {
      // DOM elements and global state
      const elements = {
        searchInput: document.getElementById("searchInput") as HTMLInputElement,
        articlesGrid: document.getElementById("articlesGrid") as HTMLElement,
        noResults: document.getElementById("no-results") as HTMLElement,
        searchStatus: document.getElementById("search-status") as HTMLElement,
        searchDetails: document.getElementById("search-details") as HTMLElement,
        resetButtons: document.querySelectorAll("#reset-search, #reset-search-inline"),
        backToTopButton: document.getElementById("back-to-top") as HTMLElement,
      };

      // Config
      const config = {
        batchSize: 10,
        debounceWait: 150, // Reduced for more responsive feel
        topButtonThreshold: 400,
      };

      // Exit if essential elements are missing
      if (
        !elements.searchInput ||
        !elements.articlesGrid ||
        !elements.noResults ||
        !elements.searchStatus
      ) {
        return;
      }

      // Initialize the knowledge page functionality
      initKnowledgePage(elements, config);
    });

    /**
     * Main function to initialize the knowledge page functionality
     * @param {Object} elements - DOM elements used by the page
     * @param {Object} config - Configuration options
     * @returns {void}
     */
    function initKnowledgePage(
      elements: {
        searchInput: HTMLInputElement;
        articlesGrid: HTMLElement;
        noResults: HTMLElement;
        searchStatus: HTMLElement;
        resetButtons: NodeListOf<Element>;
        backToTopButton: HTMLElement;
      },
      config: {
        batchSize: number;
        debounceWait: number;
        topButtonThreshold: number;
      }
    ): void {
      // Initialize article data for search
      const { allArticles, totalArticles, articleDataMap } = initializeArticleData(
        elements.articlesGrid
      );

      // Initialize all functionality
      initSearchFunctionality(elements, config, allArticles, totalArticles, articleDataMap);
      initKeyboardNavigation(elements.articlesGrid, allArticles);
      initBackToTopButton(elements.backToTopButton, config.topButtonThreshold);

      // Declare the custom property type before using it
      interface KnowledgeCenter {
        filterByQuery: (query: string) => void;
        reset: () => void;
      }

      // Expose public API (useful for testing and potential external integrations)
      (
        window as Window & typeof globalThis & { knowledgeCenter?: KnowledgeCenter }
      ).knowledgeCenter = {
        filterByQuery: (query: string): void => {
          if (elements.searchInput) {
            elements.searchInput.value = query;
            const event = new Event("input", { bubbles: true });
            elements.searchInput.dispatchEvent(event);
          }
        },
        reset: (): void => {
          if (elements.searchInput) {
            elements.searchInput.value = "";
            const event = new Event("input", { bubbles: true });
            elements.searchInput.dispatchEvent(event);
            elements.searchInput.focus();
          }
        },
      };
    }

    /**
     * Initializes article data for search functionality
     * @param {HTMLElement} articlesGrid - The grid element containing all articles
     * @returns {Object} Object containing articles and article data map
     */
    function initializeArticleData(articlesGrid: HTMLElement): {
      allArticles: HTMLElement[];
      totalArticles: number;
      articleDataMap: Map<HTMLElement, { element: HTMLElement; searchText: string }>;
    } {
      // Cache all article elements for faster access
      const allArticles = Array.from(articlesGrid.querySelectorAll("li")) as HTMLElement[];
      const totalArticles = allArticles.length;

      // Create a Map for faster lookups during search
      const articleDataMap = new Map<
        HTMLElement,
        {
          element: HTMLElement;
          searchText: string;
        }
      >();

      // Pre-process article data once
      allArticles.forEach((article) => {
        const card = article.querySelector('[data-testid="knowledge-card"]');
        if (card) {
          const title = card.getAttribute("data-title") || "";
          const description = card.getAttribute("data-description") || "";
          const keywords = card.getAttribute("data-keywords") || "";

          // Store pre-processed lowercase text for faster comparison
          articleDataMap.set(article, {
            element: article,
            searchText: `${title} ${description} ${keywords}`.toLowerCase(),
          });
        }
      });

      return { allArticles, totalArticles, articleDataMap };
    }

    /**
     * Initializes the search functionality with debouncing and batch processing
     * @param {Object} elements - DOM elements used by the search functionality
     * @param {Object} config - Configuration options
     * @param {HTMLElement[]} allArticles - Array of all article elements
     * @param {number} totalArticles - Total number of articles
     * @param {Map} articleDataMap - Map of article elements to their search data
     * @returns {void}
     */
    function initSearchFunctionality(
      elements: {
        searchInput: HTMLInputElement;
        noResults: HTMLElement;
        searchStatus: HTMLElement;
        resetButtons: NodeListOf<Element>;
      },
      config: {
        batchSize: number;
        debounceWait: number;
      },
      allArticles: HTMLElement[],
      totalArticles: number,
      articleDataMap: Map<HTMLElement, { element: HTMLElement; searchText: string }>
    ): void {
      // Create the optimized search function
      const performSearch = createSearchFunction({
        allArticles,
        totalArticles,
        articleDataMap,
        elements: {
          noResults: elements.noResults,
          searchStatus: elements.searchStatus,
        },
        config,
      });

      // Event listeners
      elements.searchInput.addEventListener("input", (e) => {
        const target = e.target as HTMLInputElement;
        if (target) {
          performSearch(target.value);
        }
      });

      elements.resetButtons.forEach((button) => {
        button.addEventListener("click", () => {
          elements.searchInput.value = "";
          performSearch("");
          elements.searchInput.focus();
        });
      });

      // Add ESC key handler to reset search
      document.addEventListener("keydown", (event: KeyboardEvent) => {
        if (event.key === "Escape" && elements.searchInput?.value) {
          elements.searchInput.value = "";
          performSearch("");
          elements.searchInput.focus();
          event.preventDefault();
        }
      });

      // Initialize with empty search to ensure proper state
      performSearch("");
    }

    /**
     * Sets up keyboard navigation for articles with arrow keys
     * @param {HTMLElement} articlesGrid - The articles grid element
     * @param {HTMLElement[]} allArticles - Array of all article elements
     * @returns {void}
     */
    function initKeyboardNavigation(articlesGrid: HTMLElement, allArticles: HTMLElement[]): void {
      document.addEventListener("keydown", (e) => {
        handleKeyboardNavigation(e, articlesGrid, allArticles);
      });
    }

    /**
     * Initializes the back to top button functionality
     * @param {HTMLElement} backToTopButton - The back to top button element
     * @param {number} threshold - Scroll threshold to show the button
     * @returns {void}
     */
    function initBackToTopButton(backToTopButton: HTMLElement, threshold: number): void {
      if (!backToTopButton) {
        return;
      }

      // Performance optimization for scroll events
      let isScrolling = false;

      // Show/hide button based on scroll position
      window.addEventListener(
        "scroll",
        () => {
          if (!isScrolling) {
            isScrolling = true;

            requestAnimationFrame(() => {
              if (window.scrollY > threshold) {
                backToTopButton.setAttribute("data-visible", "true");
              } else {
                backToTopButton.removeAttribute("data-visible");
              }
              isScrolling = false;
            });
          }
        },
        { passive: true }
      );

      // Scroll to top when clicked
      backToTopButton.addEventListener("click", () => {
        // Announce to screen readers
        const srAnnounce = document.getElementById("sr-announce");
        if (srAnnounce) {
          srAnnounce.textContent = "Scrolling to top of page";
        }

        // Get motion preferences (single declaration for the entire function)
        const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        const shouldUseSmooth = !prefersReducedMotion;

        // Use native smooth scroll if supported and not disabled
        if (shouldUseSmooth && "scrollBehavior" in document.documentElement.style) {
          window.scrollTo({
            top: 0,
            behavior: "smooth",
          });
        } else {
          // Immediate scroll for reduced motion or fallback
          window.scrollTo(0, 0);

          // Provide immediate feedback for screen readers when using instant scroll
          if (srAnnounce) {
            srAnnounce.textContent = "Scrolled to top of page";
          }
        }

        // Return focus to the search input after scrolling for better keyboard navigation
        setTimeout(
          () => {
            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
              searchInput.focus();
              // Announce focus to screen readers
              if (srAnnounce) {
                srAnnounce.textContent = "Search input is now focused";
              }
            }
          },
          shouldUseSmooth ? 300 : 0
        );
      });
    }
  </script>

  <style>
    /* Improved color contrast for WCAG AAA (7:1) */
    :root {
      --text-primary: #ffffff; /* Maximum contrast */
      --text-secondary: #e2e2e7; /* Higher contrast than standard zinc-300 */
      --bg-card: #27272a; /* zinc-800 */
      --border-card: rgba(161, 161, 170, 0.3); /* zinc-400 with transparency */
      --accent-primary: #a855f7; /* purple-500 */
      --accent-secondary: #c084fc; /* purple-400 */
      --focus-outline: 3px solid #c084fc; /* Strong focus indicator for AAA compliance */
    }

    /* Animations for cards */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Respect user preference for reduced motion */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.001s !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.001s !important;
        scroll-behavior: auto !important;
      }

      .translate-y-2.transform.motion-safe\:animate-\[fadeIn_0\.5s_ease-out_forwards\] {
        opacity: 1 !important;
        transform: none !important;
        animation: none !important;
      }

      @keyframes fadeIn {
        from {
          opacity: 1;
          transform: translateY(0);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    }

    /* Support for text spacing preferences */
    @media (prefers-increased-text-spacing) {
      p,
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      li,
      input,
      button {
        letter-spacing: 0.12em !important;
        word-spacing: 0.16em !important;
        line-height: 1.8 !important;
      }

      .card-description {
        margin-top: 1.5em !important;
        margin-bottom: 1.5em !important;
      }
    }

    /* Focus styles for better keyboard navigation - WCAG AAA compliance */
    :focus {
      outline: var(--focus-outline);
      outline-offset: 2px;
    }

    /* Ensure interactive elements have adequate touch target size (44x44px) */
    button,
    a[href],
    input,
    select,
    textarea,
    [role="button"] {
      min-height: 44px;
      min-width: 44px;
    }
  </style>
</Layout>
