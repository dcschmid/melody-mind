---
import type { AnyCollectionEntry, KnowledgeLanguage } from "astro:content";
import { getCollection } from "astro:content";
import KnowledgeCard from "@components/KnowledgeCard.astro";
import Layout from "@layouts/Layout.astro";
import { ui } from "../../../i18n/ui";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import { Icon } from "astro-icon/components";
import { calculateReadingTime } from "@utils/readingTime";

export const prerender = true;

export async function getStaticPaths() {
  const supportedLanguages = [
    "de",
    "en",
    "es",
    "fr",
    "it",
    "pt",
    "da",
    "nl",
    "sv",
    "fi",
  ] as const;

  const paths = await Promise.all(
    supportedLanguages.map(async (lang) => {
      const collectionName = `knowledge-${lang}` as const;
      const articles = await getCollection(collectionName);
      const allKeywords = [
        ...new Set(articles.flatMap((article) => article.data.keywords || [])),
      ].sort();

      return {
        params: { lang },
        props: { articles, allKeywords },
      };
    }),
  );

  return paths;
}

interface Props {
  articles: AnyCollectionEntry[];
  allKeywords: string[];
}

const { lang } = Astro.params as { lang: KnowledgeLanguage };
const { articles, allKeywords } = Astro.props;

const isUiLanguage = (lang: KnowledgeLanguage): lang is keyof typeof ui => {
  return Object.keys(ui).includes(lang);
};

const uiLang = isUiLanguage(lang) ? lang : "en";

// Artikel mit berechneter Lesezeit, falls diese fehlt
const articlesWithReadingTime = articles.map((article) => {
  if (article.data.readingTime === undefined) {
    // Berechne Lesezeit basierend auf der Artikellänge
    const articleContent = article.body || article.data.description || "";
    const estimatedTime = calculateReadingTime(articleContent);

    return {
      ...article,
      data: {
        ...article.data,
        readingTime: estimatedTime,
      },
    };
  }
  return article;
});

// Sortiere Artikel alphabetisch nach Titel
const sortedArticles = [...articlesWithReadingTime].sort((a, b) =>
  (a.data.image || "").localeCompare(b.data.image || "", undefined, {
    sensitivity: "base",
  }),
);
---

<Layout title={ui[uiLang]["knowledge.title"]}>
  <div class="max-w-6xl mx-auto px-4 py-8">
    <div class="text-center mb-12">
      <Headline
        title={ui[uiLang]["knowledge.title"]}
        level="h1"
        className="text-white font-bold text-3xl md:text-4xl mb-4"
      />
      <div class="h-1 w-24 bg-purple-500 rounded-full mx-auto mt-2 mb-6"></div>

      <Paragraph
        description={ui[uiLang]["knowledge.intro"]}
        className="max-w-2xl mx-auto text-zinc-100"
      />
    </div>

    <div class="w-full mb-8">
      <!-- Improved search and filtering with ARIA support -->
      <div
        class="search-filter-container bg-zinc-800/90 rounded-xl p-6 border border-zinc-700 shadow-lg mb-10"
        role="search"
      >
        <h2 class="sr-only" id="search-heading">
          {ui[uiLang]["knowledge.search.label"] || "Artikel durchsuchen"}
        </h2>

        <div class="flex flex-col md:flex-row gap-4 mb-4">
          <div class="relative flex-grow">
            <label for="searchInput" class="sr-only">
              {ui[uiLang]["knowledge.search.placeholder"]}
            </label>
            <div class="relative">
              <div
                class="absolute inset-y-0 left-3 flex items-center pointer-events-none"
              >
                <Icon name="search" class="h-5 w-5 text-purple-400" />
              </div>
              <input
                type="search"
                id="searchInput"
                placeholder={ui[uiLang]["knowledge.search.placeholder"]}
                class="w-full py-3 pl-10 pr-4 bg-zinc-800 border-2 border-zinc-600
                       rounded-xl text-zinc-50 placeholder-zinc-300
                       focus:outline-none focus:border-purple-500 focus:ring-3
                       focus:ring-purple-500/50 transition-all duration-300"
                aria-controls="articlesGrid"
                aria-describedby="search-description"
              />
              <div id="search-description" class="sr-only">
                Während der Eingabe werden die Artikel automatisch gefiltert
              </div>
            </div>
          </div>
        </div>

        <!-- Suchstatusanzeige für Screenreader -->
        <div id="search-status" class="sr-only" aria-live="polite"></div>
      </div>

      <!-- No results message (initially hidden) -->
      <div
        id="no-results"
        class="hidden flex flex-col items-center justify-center p-12 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl border border-zinc-600 text-center shadow-md mb-10"
        aria-live="polite"
      >
        <Icon name="search-no-results" class="w-16 h-16 text-zinc-300 mb-4" />
        <p class="text-zinc-100 text-lg font-medium">
          {ui[uiLang]["knowledge.no.results"] || "Keine Artikel gefunden"}
        </p>
        <button
          id="reset-search"
          class="mt-4 px-4 py-2 bg-purple-600 hover:bg-purple-500 text-white rounded-lg focus:outline-none focus:ring-3 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800 transition-all duration-300"
        >
          Suche zurücksetzen
        </button>
      </div>

      <!-- Accessible keyboard focus hints -->
      <div class="focus-instructions sr-only" aria-live="polite">
        <p>
          Use the Tab key to navigate between articles, and press Enter to open
          an article.
        </p>
      </div>

      <div
        id="articlesGrid"
        class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8"
        role="region"
        aria-label={ui[uiLang]["knowledge.title"]}
      >
        {
          sortedArticles.length > 0 ? (
            sortedArticles.map((article, index) => {
              // Handle image path
              const imagePath = article.data.image || "/default-cover.jpg";

              // Handle date - ensure it's a valid Date object
              const createdAt =
                article.data.createdAt instanceof Date
                  ? article.data.createdAt
                  : article.data.createdAt
                    ? new Date(article.data.createdAt)
                    : new Date();

              return (
                <div
                  class="animate-fadeIn knowledge-card-container"
                  style={{ animationDelay: `${index * 0.05}s` }}
                  data-keywords={
                    article.data.keywords?.join(" ").toLowerCase() || ""
                  }
                  data-title={article.data.title.toLowerCase()}
                  data-description={article.data.description.toLowerCase()}
                >
                  <KnowledgeCard
                    title={article.data.title}
                    description={article.data.description}
                    image={article.data.image as string}
                    createdAt={createdAt}
                    slug={article.slug}
                    lang={lang}
                    readingTime={article.data.readingTime}
                  />
                </div>
              );
            })
          ) : (
            <div class="col-span-full flex flex-col items-center justify-center p-12 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl border border-zinc-600 text-center shadow-md">
              <Icon name="info" class="w-16 h-16 text-zinc-300 mb-4" />
              <p class="text-zinc-100 text-lg font-medium">
                {ui[uiLang]["knowledge.empty"] || "Keine Artikel gefunden"}
              </p>
            </div>
          )
        }
      </div>
    </div>

    <!-- "Back to top" button with improved accessibility -->
    <button
      id="back-to-top"
      class="fixed bottom-8 right-8 p-3 bg-purple-600 text-white rounded-full shadow-lg opacity-0 invisible transition-all duration-300 hover:bg-purple-500 focus:outline-none focus:ring-3 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800"
      aria-label="Back to top of page"
    >
      <Icon name="arrow-up" class="h-6 w-6" />
    </button>
  </div>
</Layout>

<style>
  /* Improved color contrast for WCAG AAA (7:1) */
  :root {
    --text-primary: #ffffff; /* Maximum contrast */
    --text-secondary: #e2e2e7; /* Higher contrast than standard zinc-300 */
    --bg-card: #27272a; /* zinc-800 */
    --border-card: rgba(161, 161, 170, 0.3); /* zinc-400 with transparency */
    --accent-primary: #a855f7; /* purple-500 */
    --accent-secondary: #c084fc; /* purple-400 */
  }

  /* Animations for cards */
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fadeIn {
    animation: fadeIn 0.5s ease-out forwards;
    opacity: 0;
  }

  /* Enhanced keyboard focus styles for WCAG AAA */
  :focus-visible {
    outline: 3px solid var(--accent-primary) !important;
    outline-offset: 3px !important;
    box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.4) !important;
  }

  /* Verbesserter Hover-Effekt */
  .knowledge-card-container:hover {
    transform: translateY(-4px);
    transition:
      transform 0.3s ease-out,
      box-shadow 0.3s ease-out;
  }

  /* Verbesserte Back-to-Top Button Animation */
  #back-to-top.visible {
    opacity: 1;
    visibility: visible;
  }

  /* Verbesserte Touch-Interaktion für mobile Geräte */
  .knowledge-card-container {
    position: relative;
    cursor: pointer;
    transition:
      transform 0.3s ease,
      box-shadow 0.3s ease;
    transform: translateZ(0); /* Aktiviert Hardware-Beschleunigung */
    will-change: transform; /* Optimiert für Animation */
  }

  /* Verbesserte Touch-Interaktion - Entferne Konflikte mit KnowledgeCard */
  .knowledge-card-container a.card-link {
    position: relative;
    z-index: 5;
    display: block;
  }

  /* Entferne das after-Element, das Konflikte verursachen kann */
  .knowledge-card-container a.card-link::after {
    content: none;
  }

  /* Optimierte Touch-Feedback-Stile */
  @media (hover: none) {
    .knowledge-card-container:hover {
      transform: none; /* Verhindert Hover-Effekte auf Touch-Geräten */
    }

    /* Verwende Touch-spezifisches Styling */
    .knowledge-card-container {
      touch-action: manipulation; /* Optimiert für Touch-Interaktionen */
    }

    /* Leichteres Touch-Feedback */
    .touching {
      opacity: 0.8;
    }
  }

  /* Verbesserte Touch-Interaktion für mobile Geräte */
  .knowledge-card-container {
    position: relative;
    cursor: pointer;
    transition:
      transform 0.3s ease,
      box-shadow 0.3s ease;
  }

  .knowledge-card-container:active {
    transform: scale(0.98);
  }

  /* Vergrößerter klickbarer Bereich und verbesserte mobile Zugänglichkeit */
  .knowledge-card-container a.card-link {
    position: static;
  }

  .knowledge-card-container a.card-link::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10; /* Stellt sicher, dass der klickbare Bereich über anderen Elementen liegt */
  }

  /* Reduzierte Hover-Effekte für Touch-Geräte */
  @media (hover: none) {
    .knowledge-card-container:hover {
      transform: none;
    }

    /* Visuelles Feedback bei Berührung */
    .knowledge-card-container:active {
      background-color: rgba(168, 85, 247, 0.1);
    }

    /* Improved scroll vs. tap handling */
    .knowledge-card-container {
      touch-action: pan-y; /* Allow vertical scrolling */
    }
  }

  /* Disable animations if user prefers reduced motion */
  @media (prefers-reduced-motion: reduce) {
    *,
    ::before,
    ::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }

    .animate-fadeIn {
      opacity: 1;
      animation: none;
      transform: translateY(0);
    }

    .knowledge-card-container:hover {
      transform: none;
    }
  }

  /* Improved touch interaction with better scroll handling */
  @media (hover: none) {
    .knowledge-card-container:hover {
      transform: none; /* Prevents hover effects on touch devices */
    }

    /* Enable vertical scrolling */
    .knowledge-card-container {
      touch-action: pan-y;
    }

    /* Simple active state feedback */
    .knowledge-card-container:active {
      opacity: 0.9;
    }
  }

  /* Remove potentially problematic styles that intercept scrolling */
  .knowledge-card-container a.card-link::after {
    content: none;
  }
</style>

<script>
  /**
   * Knowledge Articles Search & Filtering System
   *
   * A high-performance article filtering system with WCAG AAA accessibility optimizations:
   * - Efficient search with debouncing and batch processing
   * - Keyboard navigation support for improved accessibility
   * - Touch-friendly interactions for mobile devices
   * - Screen reader announcements for search/filter results
   */

  // Central configuration for easy maintenance and customization
  const CONFIG = {
    selectors: {
      searchInput: "#searchInput",
      categoryFilter: "#categoryFilter",
      articleGrid: "#articlesGrid",
      articleCard: ".knowledge-card-container",
      articleLink: "a.card-link",
      noResults: "#no-results",
      searchStatus: "#search-status",
      resetSearch: "#reset-search",
      backToTop: "#back-to-top",
    },
    timing: {
      debounceMs: 200,
      scrollDuration: 500,
    },
    performance: {
      batchSize: 12,
      animationThreshold: 50,
    },
    scroll: {
      topButtonThreshold: 500,
    },
  };

  /**
   * Initialize the knowledge center functionality when DOM is loaded
   */
  document.addEventListener("DOMContentLoaded", () => {
    const elements = {
      searchInput: document.querySelector(CONFIG.selectors.searchInput),
      categoryFilter: document.querySelector(CONFIG.selectors.categoryFilter),
      articleGrid: document.querySelector(CONFIG.selectors.articleGrid),
      noResults: document.querySelector(CONFIG.selectors.noResults),
      searchStatus: document.querySelector(CONFIG.selectors.searchStatus),
      resetButton: document.querySelector(CONFIG.selectors.resetSearch),
      backToTopButton: document.querySelector(CONFIG.selectors.backToTop),
      articles: Array.from(
        document.querySelectorAll(CONFIG.selectors.articleCard),
      ),
    };

    // Skip initialization if required elements are missing
    if (!elements.searchInput || !elements.articleGrid) {
      console.warn(
        "Required search elements not found. Search functionality disabled.",
      );
      return;
    }

    let isProcessing = false;
    let debounceTimer = null;

    // ===== Event Listeners =====

    // Search input with debounce for better performance
    elements.searchInput.addEventListener("input", () => {
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        filterArticles();
        debounceTimer = null;
      }, CONFIG.timing.debounceMs);
    });

    // Category filter
    if (elements.categoryFilter) {
      elements.categoryFilter.addEventListener("change", filterArticles);
    }

    // Reset search
    if (elements.resetButton) {
      elements.resetButton.addEventListener("click", () => {
        if (elements.searchInput) elements.searchInput.value = "";
        if (elements.categoryFilter) elements.categoryFilter.value = "all";
        filterArticles();
        elements.searchInput.focus();
      });
    }

    // Back to top button
    if (elements.backToTopButton) {
      initBackToTopButton();
    }

    // Setup keyboard navigation between cards
    initKeyboardNavigation();

    // Setup mobile touch interaction
    initTouchInteraction();

    // ===== Core Functions =====

    /**
     * Main filtering function for articles
     */
    function filterArticles() {
      if (isProcessing) return;
      isProcessing = true;

      const query = elements.searchInput.value.toLowerCase().trim();
      const category = elements.categoryFilter?.value || "all";
      let visibleCount = 0;

      // Process in batches for large article collections (improves UI responsiveness)
      if (elements.articles.length > CONFIG.performance.batchSize) {
        processBatchedFilter(query, category);
      } else {
        // Direct processing for smaller collections
        elements.articles.forEach((article) => {
          const isVisible = articleMatchesFilters(article, query, category);
          article.style.display = isVisible ? "" : "none";
          if (isVisible) visibleCount++;
        });

        updateResultsStatus(visibleCount);
        isProcessing = false;

        // Ensure touch interaction works after filtering
        if (visibleCount > 0) {
          setTimeout(initTouchInteraction, 100);
        }
      }
    }

    /**
     * Process articles in batches for smoother UI with large collections
     */
    function processBatchedFilter(query, category) {
      let index = 0;
      let visibleCount = 0;

      const processNextBatch = () => {
        const endIndex = Math.min(
          index + CONFIG.performance.batchSize,
          elements.articles.length,
        );

        for (let i = index; i < endIndex; i++) {
          const isVisible = articleMatchesFilters(
            elements.articles[i],
            query,
            category,
          );
          elements.articles[i].style.display = isVisible ? "" : "none";
          if (isVisible) visibleCount++;
        }

        index = endIndex;

        if (index < elements.articles.length) {
          // Process next batch in next animation frame
          requestAnimationFrame(processNextBatch);
        } else {
          // All batches processed
          updateResultsStatus(visibleCount);
          isProcessing = false;
        }
      };

      requestAnimationFrame(processNextBatch);
    }

    /**
     * Check if an article matches the current search and category filters
     */
    function articleMatchesFilters(article, query, category) {
      // Category filter check
      if (category !== "all") {
        const keywords = article.dataset.keywords || "";
        if (!keywords.includes(category.toLowerCase())) {
          return false;
        }
      }

      // Search query check (if query is provided)
      if (query) {
        const searchableContent = [
          article.dataset.title || "",
          article.dataset.description || "",
          article.dataset.keywords || "",
        ].join(" ");

        return searchableContent.includes(query);
      }

      return true;
    }

    /**
     * Update UI and announcements based on filter results
     */
    function updateResultsStatus(visibleCount) {
      // Update screen reader announcements
      if (elements.searchStatus) {
        elements.searchStatus.textContent =
          visibleCount === elements.articles.length
            ? `All ${visibleCount} articles are displayed`
            : `${visibleCount} of ${elements.articles.length} articles found`;
      }

      // Show/hide no results message
      if (elements.noResults) {
        elements.noResults.classList.toggle("hidden", visibleCount > 0);
      }

      // Focus first result if filtering is active
      if (
        visibleCount > 0 &&
        (elements.searchInput.value || elements.categoryFilter?.value !== "all")
      ) {
        const firstVisible = elements.articles.find(
          (a) => a.style.display !== "none",
        );
        if (firstVisible) {
          const firstLink = firstVisible.querySelector(
            CONFIG.selectors.articleLink,
          );
          if (firstLink) setTimeout(() => firstLink.focus(), 100);
        }
      }
    }

    // ===== Helper Functions =====

    /**
     * Initialize keyboard navigation between article cards
     */
    function initKeyboardNavigation() {
      elements.articleGrid.addEventListener("keydown", (event) => {
        if (
          !["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp"].includes(
            event.key,
          )
        )
          return;

        const cards = Array.from(
          elements.articleGrid.querySelectorAll(CONFIG.selectors.articleLink),
        );
        const currentIndex = cards.findIndex(
          (card) => card === document.activeElement,
        );
        if (currentIndex === -1) return;

        // Calculate grid columns based on viewport width
        const columns =
          window.innerWidth >= 1024 ? 3 : window.innerWidth >= 640 ? 2 : 1;
        let newIndex;

        // Calculate new index based on arrow key direction
        switch (event.key) {
          case "ArrowRight":
            newIndex = (currentIndex + 1) % cards.length;
            break;
          case "ArrowLeft":
            newIndex = (currentIndex - 1 + cards.length) % cards.length;
            break;
          case "ArrowDown":
            newIndex =
              currentIndex + columns < cards.length
                ? currentIndex + columns
                : currentIndex;
            break;
          case "ArrowUp":
            newIndex =
              currentIndex - columns >= 0
                ? currentIndex - columns
                : currentIndex;
            break;
        }

        if (newIndex !== undefined && cards[newIndex]) {
          event.preventDefault();
          cards[newIndex].focus();
        }
      });
    }

    /**
     * Set up the back to top button functionality
     */
    function initBackToTopButton() {
      // Show/hide button based on scroll position
      window.addEventListener("scroll", () => {
        const showButton = window.scrollY > CONFIG.scroll.topButtonThreshold;
        elements.backToTopButton.classList.toggle("visible", showButton);
      });

      // Scroll to top when clicked
      elements.backToTopButton.addEventListener("click", () => {
        window.scrollTo({
          top: 0,
          behavior: "smooth",
        });

        // Return focus to search input for improved keyboard accessibility
        setTimeout(
          () => elements.searchInput.focus(),
          CONFIG.timing.scrollDuration,
        );
      });
    }

    /**
     * Enhance touch interaction for mobile devices
     * with improved reliability and scroll vs. tap detection
     */
    function initTouchInteraction() {
      const cards = document.querySelectorAll(CONFIG.selectors.articleCard);

      cards.forEach((card) => {
        // Remove previous event listeners to avoid conflicts
        const clone = card.cloneNode(true);
        card.parentNode?.replaceChild(clone, card);

        // Find the link in the card
        const link = clone.querySelector(CONFIG.selectors.articleLink);

        if (link) {
          // Ensure the link is "clickable" but don't interfere with scrolling
          link.style.pointerEvents = "auto";

          // Let the card component handle touch interactions
          // This allows us to better detect the difference between scrolling and tapping
        }
      });
    }
  });
</script>
