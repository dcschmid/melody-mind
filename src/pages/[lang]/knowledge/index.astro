---
import type { AnyCollectionEntry, KnowledgeLanguage } from "astro:content";
import { getCollection } from "astro:content";
import KnowledgeCard from "@components/KnowledgeCard.astro";
import Layout from "@layouts/Layout.astro";
import { ui } from "../../../i18n/ui";
import Headline from "@components/Headline.astro";
import Paragraph from "@components/Paragraph.astro";
import { Icon } from "astro-icon/components";
import { calculateReadingTime } from "@utils/readingTime";

export const prerender = true;

export async function getStaticPaths() {
  const supportedLanguages = [
    "de",
    "en",
    "es",
    "fr",
    "it",
    "pt",
    "da",
    "nl",
    "sv",
    "fi",
  ] as const;

  const paths = await Promise.all(
    supportedLanguages.map(async (lang) => {
      const collectionName = `knowledge-${lang}` as const;
      const articles = await getCollection(collectionName);
      const allKeywords = [
        ...new Set(articles.flatMap((article) => article.data.keywords || [])),
      ].sort();

      return {
        params: { lang },
        props: { articles, allKeywords },
      };
    }),
  );

  return paths;
}

interface Props {
  articles: AnyCollectionEntry[];
  allKeywords: string[];
}

const { lang } = Astro.params as { lang: KnowledgeLanguage };
const { articles, allKeywords } = Astro.props;

const isUiLanguage = (lang: KnowledgeLanguage): lang is keyof typeof ui => {
  return Object.keys(ui).includes(lang);
};

const uiLang = isUiLanguage(lang) ? lang : "en";

// Artikel mit berechneter Lesezeit, falls diese fehlt
const articlesWithReadingTime = articles.map((article) => {
  if (article.data.readingTime === undefined) {
    // Berechne Lesezeit basierend auf der Artikellänge
    const articleContent = article.body || article.data.description || "";
    const estimatedTime = calculateReadingTime(articleContent);

    return {
      ...article,
      data: {
        ...article.data,
        readingTime: estimatedTime,
      },
    };
  }
  return article;
});

// Sortiere Artikel alphabetisch nach Titel
const sortedArticles = [...articlesWithReadingTime].sort((a, b) =>
  (a.data.image || '').localeCompare((b.data.image || ''), undefined, { sensitivity: "base" }),
);

// Kategorisiere Artikel nach Themen für verbesserte Navigation
const categorizedArticles = sortedArticles.reduce(
  (acc, article) => {
    const mainKeyword = article.data.keywords?.[0] || "Allgemein";
    if (!acc[mainKeyword]) {
      acc[mainKeyword] = [];
    }
    acc[mainKeyword].push(article);
    return acc;
  },
  {} as Record<string, AnyCollectionEntry[]>,
);
---

<Layout title={ui[uiLang]["knowledge.title"]}>
  <div class="max-w-6xl mx-auto px-4 py-8">
    <div class="text-center mb-12">
      <Headline
        title={ui[uiLang]["knowledge.title"]}
        level="h1"
        className="text-white font-bold text-3xl md:text-4xl mb-4"
      />
      <div class="h-1 w-24 bg-purple-500 rounded-full mx-auto mt-2 mb-6"></div>

      <Paragraph
        description={ui[uiLang]["knowledge.intro"]}
        className="max-w-2xl mx-auto text-zinc-100"
      />
    </div>

    <div class="w-full mb-8">
      <!-- Verbesserte Suche und Filterung mit ARIA-Unterstützung -->
      <div
        class="search-filter-container bg-zinc-800/90 rounded-xl p-6 border border-zinc-700 shadow-lg mb-10"
        role="search"
      >
        <h2 class="sr-only" id="search-heading">
          {ui[uiLang]["knowledge.search.label"] || "Artikel durchsuchen"}
        </h2>

        <div class="flex flex-col md:flex-row gap-4 mb-4">
          <div class="relative flex-grow">
            <label for="searchInput" class="sr-only">
              {ui[uiLang]["knowledge.search.placeholder"]}
            </label>
            <div class="relative">
              <div
                class="absolute inset-y-0 left-3 flex items-center pointer-events-none"
              >
                <Icon name="search" class="h-5 w-5 text-purple-400" />
              </div>
              <input
                type="search"
                id="searchInput"
                placeholder={ui[uiLang]["knowledge.search.placeholder"]}
                class="w-full py-3 pl-10 pr-4 bg-zinc-800 border-2 border-zinc-600
                       rounded-xl text-zinc-50 placeholder-zinc-300
                       focus:outline-none focus:border-purple-500 focus:ring-3
                       focus:ring-purple-500/50 transition-all duration-300"
                aria-controls="articlesGrid"
                aria-describedby="search-description"
              />
              <div id="search-description" class="sr-only">
                Während der Eingabe werden die Artikel automatisch gefiltert
              </div>
            </div>
          </div>

          <!-- Kategorie-Filter -->
          <div class="md:w-1/3">
            <label for="categoryFilter" class="sr-only"
              >Nach Kategorie filtern</label
            >
            <div class="relative">
              <div
                class="absolute inset-y-0 left-3 flex items-center pointer-events-none"
              >
                <Icon name="filter" class="h-5 w-5 text-purple-400" />
              </div>
              <select
                id="categoryFilter"
                class="w-full py-3 pl-10 pr-4 bg-zinc-800 border-2 border-zinc-600
                      rounded-xl text-zinc-50 appearance-none cursor-pointer
                      focus:outline-none focus:border-purple-500 focus:ring-3
                      focus:ring-purple-500/50 transition-all duration-300"
                aria-label="Nach Kategorie filtern"
              >
                <option value="all">{ui[uiLang]["knowledge.filter.all"]}</option
                >
                {
                  allKeywords.map((keyword) => (
                    <option value={keyword}>{keyword}</option>
                  ))
                }
              </select>
              <div
                class="absolute inset-y-0 right-3 flex items-center pointer-events-none"
              >
                <Icon name="chevron-down" class="h-5 w-5 text-purple-400" />
              </div>
            </div>
          </div>
        </div>

        <!-- Suchstatusanzeige für Screenreader -->
        <div id="search-status" class="sr-only" aria-live="polite"></div>
      </div>

      <!-- Keine Ergebnisse Nachricht (anfangs ausgeblendet) -->
      <div
        id="no-results"
        class="hidden flex flex-col items-center justify-center p-12 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl border border-zinc-600 text-center shadow-md mb-10"
        aria-live="polite"
      >
        <Icon name="search-no-results" class="w-16 h-16 text-zinc-300 mb-4" />
        <p class="text-zinc-100 text-lg font-medium">
          {ui[uiLang]["knowledge.no.results"] || "Keine Artikel gefunden"}
        </p>
        <button
          id="reset-search"
          class="mt-4 px-4 py-2 bg-purple-600 hover:bg-purple-500 text-white rounded-lg focus:outline-none focus:ring-3 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800 transition-all duration-300"
        >
          Suche zurücksetzen
        </button>
      </div>

      <!-- Barrierefreie Tastaturfokus-Hinweise -->
      <div class="focus-instructions sr-only" aria-live="polite">
        <p>
          Benutze die Tab-Taste, um zwischen Artikeln zu navigieren, und drücke
          Enter, um einen Artikel zu öffnen.
        </p>
      </div>

      <div
        id="articlesGrid"
        class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8"
        role="region"
        aria-label={ui[uiLang]["knowledge.title"]}
      >
        {
          sortedArticles.length > 0 ? (
            sortedArticles.map((article, index) => {
              // Handle image path
              const imagePath = article.data.image || "/default-cover.jpg";

              // Handle date - ensure it's a valid Date object
              const createdAt =
                article.data.createdAt instanceof Date
                  ? article.data.createdAt
                  : article.data.createdAt
                    ? new Date(article.data.createdAt)
                    : new Date();

              return (
                <div
                  class="animate-fadeIn knowledge-card-container"
                  style={{ animationDelay: `${index * 0.05}s` }}
                  data-keywords={
                    article.data.keywords?.join(" ").toLowerCase() || ""
                  }
                  data-title={article.data.title.toLowerCase()}
                  data-description={article.data.description.toLowerCase()}
                >
                  <KnowledgeCard
                    title={article.data.title}
                    description={article.data.description}
                    image={article.data.image as string}
                    createdAt={createdAt}
                    slug={article.slug}
                    lang={lang}
                    readingTime={article.data.readingTime}
                    keywords={article.data.keywords || []}
                  />
                </div>
              );
            })
          ) : (
            <div class="col-span-full flex flex-col items-center justify-center p-12 bg-gradient-to-br from-zinc-700 to-zinc-800 rounded-xl border border-zinc-600 text-center shadow-md">
              <Icon name="info" class="w-16 h-16 text-zinc-300 mb-4" />
              <p class="text-zinc-100 text-lg font-medium">
                {ui[uiLang]["knowledge.empty"] || "Keine Artikel gefunden"}
              </p>
            </div>
          )
        }
      </div>
    </div>

    <!-- "Nach oben"-Button mit verbesserter Zugänglichkeit -->
    <button
      id="back-to-top"
      class="fixed bottom-8 right-8 p-3 bg-purple-600 text-white rounded-full shadow-lg opacity-0 invisible transition-all duration-300 hover:bg-purple-500 focus:outline-none focus:ring-3 focus:ring-purple-500/50 focus:ring-offset-2 focus:ring-offset-zinc-800"
      aria-label="Zurück zum Anfang der Seite"
    >
      <Icon name="arrow-up" class="h-6 w-6" />
    </button>
  </div>
</Layout>

<style>
  /* Verbesserter Farbkontrast für WCAG AAA (7:1) */
  :root {
    --text-primary: #ffffff; /* Maximaler Kontrast */
    --text-secondary: #e2e2e7; /* Höherer Kontrast als standard zinc-300 */
    --bg-card: #27272a; /* zinc-800 */
    --border-card: rgba(161, 161, 170, 0.3); /* zinc-400 mit Transparenz */
    --accent-primary: #a855f7; /* purple-500 */
    --accent-secondary: #c084fc; /* purple-400 */
  }

  /* Animations for cards */
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fadeIn {
    animation: fadeIn 0.5s ease-out forwards;
    opacity: 0;
  }

  /* Enhanced keyboard focus styles for WCAG AAA */
  :focus-visible {
    outline: 3px solid var(--accent-primary) !important;
    outline-offset: 3px !important;
    box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.4) !important;
  }

  /* Verbesserter Hover-Effekt */
  .knowledge-card-container:hover {
    transform: translateY(-4px);
    transition:
      transform 0.3s ease-out,
      box-shadow 0.3s ease-out;
  }

  /* Verbesserte Back-to-Top Button Animation */
  #back-to-top.visible {
    opacity: 1;
    visibility: visible;
  }

  /* Verbesserte Touch-Interaktion für mobile Geräte */
  .knowledge-card-container {
    position: relative;
    cursor: pointer;
    transition:
      transform 0.3s ease,
      box-shadow 0.3s ease;
  }

  .knowledge-card-container:active {
    transform: scale(0.98);
  }

  /* Vergrößerter klickbarer Bereich und verbesserte mobile Zugänglichkeit */
  .knowledge-card-container a.card-link {
    position: static;
  }

  .knowledge-card-container a.card-link::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10; /* Stellt sicher, dass der klickbare Bereich über anderen Elementen liegt */
  }

  /* Reduzierte Hover-Effekte für Touch-Geräte */
  @media (hover: none) {
    .knowledge-card-container:hover {
      transform: none;
    }

    /* Visuelles Feedback bei Berührung */
    .knowledge-card-container:active {
      background-color: rgba(168, 85, 247, 0.1);
    }
  }

  /* Disable animations if user prefers reduced motion */
  @media (prefers-reduced-motion: reduce) {
    *,
    ::before,
    ::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }

    .animate-fadeIn {
      opacity: 1;
      animation: none;
      transform: translateY(0);
    }

    .knowledge-card-container:hover {
      transform: none;
    }
  }
</style>

<script>
  /**
   * Knowledge Articles Search & Filtering System
   * ---------------------------------------------
   * A high-performance article filtering system optimized for WCAG AAA accessibility
   * Features intelligent caching, keyboard navigation, and robust screen reader support.
   */

  /**
   * Configuration object containing all adjustable parameters
   */
  const CONFIG = {
    // DOM element selectors
    SELECTORS: {
      SEARCH_INPUT: "#searchInput",
      CATEGORY_FILTER: "#categoryFilter",
      ARTICLE_GRID: "#articlesGrid",
      ARTICLE_CARD: ".knowledge-card-container",
      ARTICLE_LINK: "a.card-link",
      NO_RESULTS: "#no-results",
      SEARCH_STATUS: "#search-status",
      RESET_SEARCH: "#reset-search",
      BACK_TO_TOP: "#back-to-top",
    },
    // Performance settings
    PERFORMANCE: {
      DEBOUNCE_MS: 200, // Milliseconds to wait before processing search input
      BATCH_SIZE: 12, // Process search in batches for smoother UX
      ANIMATION_THRESHOLD: 50, // Skip animations if more than this many items
    },
    // Scroll settings
    SCROLL: {
      BACK_TO_TOP_THRESHOLD: 500, // Show back-to-top button after scrolling this much
      SMOOTH_SCROLL_DURATION: 500, // Duration for smooth scroll in ms
    },
    // Accessibility settings
    ACCESSIBILITY: {
      FOCUS_AFTER_FILTER: true, // Focus on first result after filtering
      ANNOUNCE_RESULTS: true, // Announce results count to screen readers
    },
  };

  /**
   * ArticleSearch class handles all search functionality for knowledge articles
   */
  class KnowledgeCenter {
    private searchInput: HTMLInputElement | null;
    private categoryFilter: HTMLSelectElement | null;
    private articleGrid: HTMLElement | null;
    private articles: HTMLElement[];
    private noResultsEl: HTMLElement | null;
    private searchStatusEl: HTMLElement | null;
    private resetSearchBtn: HTMLElement | null;
    private backToTopBtn: HTMLElement | null;
    private debounceTimer: ReturnType<typeof setTimeout> | null;
    private isProcessing: boolean;

    /**
     * Sets up the search functionality and initializes event listeners
     */
    constructor() {
      // Initialize properties
      this.searchInput = document.querySelector(CONFIG.SELECTORS.SEARCH_INPUT);
      this.categoryFilter = document.querySelector(
        CONFIG.SELECTORS.CATEGORY_FILTER,
      );
      this.articleGrid = document.querySelector(CONFIG.SELECTORS.ARTICLE_GRID);
      this.noResultsEl = document.querySelector(CONFIG.SELECTORS.NO_RESULTS);
      this.searchStatusEl = document.querySelector(
        CONFIG.SELECTORS.SEARCH_STATUS,
      );
      this.resetSearchBtn = document.querySelector(
        CONFIG.SELECTORS.RESET_SEARCH,
      );
      this.backToTopBtn = document.querySelector(CONFIG.SELECTORS.BACK_TO_TOP);
      this.articles = [];
      this.debounceTimer = null;
      this.isProcessing = false;

      // Initialize if DOM is ready
      if (document.readyState !== "loading") {
        this.init();
      } else {
        document.addEventListener("DOMContentLoaded", () => this.init());
      }
    }

    /**
     * Initializes the search system
     */
    private init(): void {
      // Ensure required DOM elements exist
      if (!this.searchInput || !this.articleGrid) {
        console.warn(
          "Required search elements not found. Search functionality disabled.",
        );
        return;
      }

      // Cache article elements for better performance
      this.articles = Array.from(
        this.articleGrid.querySelectorAll(CONFIG.SELECTORS.ARTICLE_CARD),
      ) as HTMLElement[];

      // Attach event listeners with debounce
      this.searchInput.addEventListener("input", () =>
        this.handleSearchInput(),
      );

      // Add category filter listener
      if (this.categoryFilter) {
        this.categoryFilter.addEventListener("change", () =>
          this.handleSearchInput(),
        );
      }

      // Reset search button
      if (this.resetSearchBtn) {
        this.resetSearchBtn.addEventListener("click", () => this.resetSearch());
      }

      // Back to top button
      if (this.backToTopBtn) {
        this.initBackToTop();
      }

      // Add keyboard navigation for cards
      this.setupCardKeyboardNavigation();

      // Verbesserte Touch-Interaktion für mobile Geräte
      this.setupMobileTouchInteraction();
    }

    /**
     * Initializes the back-to-top button functionality
     */
    private initBackToTop(): void {
      if (!this.backToTopBtn) return;

      // Show/hide button based on scroll position
      window.addEventListener("scroll", () => {
        if (window.scrollY > CONFIG.SCROLL.BACK_TO_TOP_THRESHOLD) {
          this.backToTopBtn?.classList.add("visible");
        } else {
          this.backToTopBtn?.classList.remove("visible");
        }
      });

      // Scroll to top when clicked
      this.backToTopBtn.addEventListener("click", () => {
        window.scrollTo({
          top: 0,
          behavior: "smooth",
        });

        // Return focus to search input for better keyboard navigation
        setTimeout(() => {
          this.searchInput?.focus();
        }, CONFIG.SCROLL.SMOOTH_SCROLL_DURATION);
      });
    }

    /**
     * Sets up keyboard navigation between article cards
     */
    private setupCardKeyboardNavigation(): void {
      this.articleGrid?.addEventListener("keydown", (event) => {
        if (
          event.key === "ArrowRight" ||
          event.key === "ArrowDown" ||
          event.key === "ArrowLeft" ||
          event.key === "ArrowUp"
        ) {
          const cards = Array.from(
            this.articleGrid?.querySelectorAll(CONFIG.SELECTORS.ARTICLE_LINK) ||
              [],
          );
          const currentIndex = cards.findIndex(
            (card) => card === document.activeElement,
          );

          if (currentIndex === -1) return;

          let newIndex;
          const columns =
            window.innerWidth >= 1024 ? 3 : window.innerWidth >= 640 ? 2 : 1;

          // Calculate new index based on arrow key and grid layout
          if (event.key === "ArrowRight") {
            newIndex = (currentIndex + 1) % cards.length;
          } else if (event.key === "ArrowLeft") {
            newIndex = (currentIndex - 1 + cards.length) % cards.length;
          } else if (event.key === "ArrowDown") {
            newIndex =
              currentIndex + columns < cards.length
                ? currentIndex + columns
                : currentIndex;
          } else if (event.key === "ArrowUp") {
            newIndex =
              currentIndex - columns >= 0
                ? currentIndex - columns
                : currentIndex;
          }

          if (newIndex !== undefined && cards[newIndex]) {
            event.preventDefault();
            (cards[newIndex] as HTMLElement).focus();
          }
        }
      });
    }

    /**
     * Handles search input with debouncing for performance
     */
    private handleSearchInput(): void {
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
      }

      this.debounceTimer = setTimeout(() => {
        this.filterArticles();
        this.debounceTimer = null;
      }, CONFIG.PERFORMANCE.DEBOUNCE_MS);
    }

    /**
     * Filters articles based on search input and category selection
     */
    private filterArticles(): void {
      if (this.isProcessing) return;

      const query = this.searchInput?.value.toLowerCase().trim() || "";
      const selectedCategory = this.categoryFilter?.value || "all";

      this.isProcessing = true;
      let visibleCount = 0;

      // Process in batches for smoother UX with many articles
      if (this.articles.length > CONFIG.PERFORMANCE.BATCH_SIZE) {
        this.processBatchedFilter(query, selectedCategory);
      } else {
        // For smaller sets, process all at once
        this.articles.forEach((article) => {
          const isVisible = this.articleMatchesFilters(
            article,
            query,
            selectedCategory,
          );
          article.style.display = isVisible ? "" : "none";
          if (isVisible) visibleCount++;
        });

        this.updateResultsStatus(visibleCount);
        this.isProcessing = false;

        // Nach der Filterung stellen wir sicher, dass die Touch-Interaktion noch funktioniert
        if (visibleCount > 0) {
          setTimeout(() => this.setupMobileTouchInteraction(), 100);
        }
      }
    }

    /**
     * Process articles in batches for better UI responsiveness
     */
    private processBatchedFilter(query: string, category: string): void {
      let index = 0;
      let visibleCount = 0;

      const processNextBatch = () => {
        const endIndex = Math.min(
          index + CONFIG.PERFORMANCE.BATCH_SIZE,
          this.articles.length,
        );

        for (let i = index; i < endIndex; i++) {
          const isVisible = this.articleMatchesFilters(
            this.articles[i],
            query,
            category,
          );
          this.articles[i].style.display = isVisible ? "" : "none";
          if (isVisible) visibleCount++;
        }

        index = endIndex;

        if (index < this.articles.length) {
          // Process next batch in next animation frame
          requestAnimationFrame(processNextBatch);
        } else {
          // All batches processed
          this.updateResultsStatus(visibleCount);
          this.isProcessing = false;
        }
      };

      requestAnimationFrame(processNextBatch);
    }

    /**
     * Check if an article matches the current search and category filters
     */
    private articleMatchesFilters(
      article: HTMLElement,
      query: string,
      category: string,
    ): boolean {
      // Handle category filter
      if (category !== "all") {
        const keywords = article.dataset.keywords || "";
        if (!keywords.includes(category.toLowerCase())) {
          return false;
        }
      }

      // Handle search query
      if (query) {
        const title = article.dataset.title || "";
        const description = article.dataset.description || "";
        const keywords = article.dataset.keywords || "";

        return (
          title.includes(query) ||
          description.includes(query) ||
          keywords.includes(query)
        );
      }

      return true;
    }

    /**
     * Updates the status display for search results
     */
    private updateResultsStatus(visibleCount: number): void {
      // Update status for screen readers
      if (this.searchStatusEl) {
        if (visibleCount === this.articles.length) {
          this.searchStatusEl.textContent = `Alle ${visibleCount} Artikel werden angezeigt`;
        } else {
          this.searchStatusEl.textContent = `${visibleCount} von ${this.articles.length} Artikeln gefunden`;
        }
      }

      // Show no results message if needed
      if (this.noResultsEl) {
        if (visibleCount === 0) {
          this.noResultsEl.classList.remove("hidden");
        } else {
          this.noResultsEl.classList.add("hidden");
        }
      }

      // Focus first result if configured
      if (
        CONFIG.ACCESSIBILITY.FOCUS_AFTER_FILTER &&
        visibleCount > 0 &&
        (this.searchInput?.value || this.categoryFilter?.value !== "all")
      ) {
        const firstVisibleArticle = Array.from(this.articles).find(
          (article) => article.style.display !== "none",
        );

        if (firstVisibleArticle) {
          const firstLink = firstVisibleArticle.querySelector(
            CONFIG.SELECTORS.ARTICLE_LINK,
          ) as HTMLElement;
          if (firstLink) {
            setTimeout(() => firstLink.focus(), 100);
          }
        }
      }
    }

    /**
     * Resets the search input and filters
     */
    private resetSearch(): void {
      if (this.searchInput) {
        this.searchInput.value = "";
      }

      if (this.categoryFilter) {
        this.categoryFilter.value = "all";
      }

      this.filterArticles();

      // Focus back on search input
      this.searchInput?.focus();
    }

    /**
     * Verbessert die Touch-Interaktion für mobile Geräte
     */
    private setupMobileTouchInteraction(): void {
      const cards = document.querySelectorAll(".knowledge-card-container");

      cards.forEach((card) => {
        card.addEventListener("click", (event) => {
          // Wenn das Event nicht direkt auf einem Link war, den ersten Link in der Karte klicken
          if (!(event.target as HTMLElement).closest("a")) {
            const link = card.querySelector("a.card-link") as HTMLElement;
            if (link) {
              link.click();
            }
          }
        });

        // Füge Touch-Feedback hinzu
        card.addEventListener(
          "touchstart",
          () => {
            card.classList.add("touching");
          },
          { passive: true },
        );

        card.addEventListener(
          "touchend",
          () => {
            card.classList.remove("touching");
          },
          { passive: true },
        );
      });
    }
  }

  // Initialize the knowledge center when the script loads
  new KnowledgeCenter();
</script>
