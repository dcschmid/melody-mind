# MelodyMind Test Generation Instructions

When generating tests for the MelodyMind project, please follow these guidelines based on the official Astro testing documentation.

## General Testing Philosophy

- Write tests that are clear, maintainable, and focused on behavior
- Each test should verify a single aspect of functionality
- Follow the AAA pattern: Arrange, Act, Assert
- Use descriptive test names that explain the behavior being tested

## Testing Framework

- Use Vitest for unit and component testing
- Use Playwright for end-to-end testing
- Configure tests to run in isolation
- Follow Astro's testing best practices

## Component Testing

- Test Astro components using @astrojs/test-utils
- For client-side components, use the appropriate framework testing library
- Test both static and interactive parts of components
- Focus on testing component outputs rather than implementation details

## Test Structure for Astro Components

```typescript
// Component test example for Astro components
import { expect, test } from "@playwright/test";
import { astroComponentFactory } from "@astrojs/test-utils";

const component = await astroComponentFactory(
  "./src/components/ComponentName.astro",
  {
    props: { title: "Test Title" },
  },
);

test("ComponentName renders correctly", async () => {
  const html = await component.render();
  expect(html).toBeTruthy();
  expect(html).toContain("Test Title");
});
```

## Test Structure for Client Components

```typescript
// For client framework components (e.g., React)
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  it('should render with default props', () => {
    render(<ComponentName />);
    expect(screen.getByText('Expected Text')).toBeInTheDocument();
  });
});
```

## End-to-End Testing

- Use Playwright for end-to-end tests
- Test complete user flows from start to finish
- Verify interactions across multiple pages
- Test on multiple browsers for compatibility

```typescript
// E2E test example
import { test, expect } from "@playwright/test";

test("game flow works correctly", async ({ page }) => {
  await page.goto("/");
  await page.getByRole("button", { name: "Start Game" }).click();
  // Test user journey through the game
  await expect(page.getByText("Select a genre")).toBeVisible();
});
```

## Game Logic Testing

- Test score calculation logic thoroughly using Vitest
- Verify timer functionality and bonus point calculations
- Test Joker functionality in different scenarios
- Verify difficulty level implementations
- Test edge cases (zero answers, all correct answers, etc.)

## Testing Utilities

- Create test utilities for common testing scenarios
- Use test data factories for generating test data
- Create custom matchers for specific assertions when needed

## Accessibility Testing

- Include tests for keyboard navigation
- Verify screen reader compatibility
- Test color contrast compliance
- Check for proper ARIA attributes

## Integration Testing

- Focus on testing key user journeys
- Test how components interact with each other
- Use Playwright for page-to-page navigation testing
- Verify data persistence between game stages

## Mocking

- Use vi.mock() for Vitest mocks
- Use Playwright's route interception for E2E test mocks
- Create realistic mock data that represents actual usage
- Mock API and database calls appropriately

## Test Coverage

- Use Vitest's coverage reporting
- Aim for high test coverage, especially for game logic
- Verify all edge cases are covered
- Test error handling thoroughly

## Astro-Specific Test Considerations

- Test SSR rendering vs. client-side hydration
- Test Astro islands behave correctly
- Verify page routing works as expected
- Test that static and dynamic content renders correctly

Remember that tests should serve as documentation and safety nets for future changes.
