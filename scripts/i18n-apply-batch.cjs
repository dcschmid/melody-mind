#!/usr/bin/env node
/**
 * melody-mind/scripts/i18n-apply-batch.cjs
 *
 * Apply a batch of i18n suggestions from a scan report generated by scripts/i18n-scan.cjs
 *
 * Features:
 * - Reads scan report (default: ./i18n-scan-report.json)
 * - Takes a batch (size, offset) of suggestions and:
 *   - Appends keys to src/i18n/locales/en.ts (if not present)
 *   - Optionally populates other locale files with AUTO-TRANSLATED placeholders (MT: prefix)
 *   - Replaces occurrences in source files with translation calls `t("key")` (conservative heuristics)
 * - Creates backups of modified files under .i18n-backups/<timestamp>/
 * - Supports dry-run mode (default) and an explicit --apply to write files
 *
 * WARNING:
 * - This script performs automated text replacements using heuristics.
 * - Always run with no --apply first to inspect the planned changes.
 *
 * Usage:
 *   node scripts/i18n-apply-batch.cjs [--report path] [--batch N] [--offset M] [--apply] [--translate] [--backup-dir path]
 *
 * Examples:
 *   # Dry run first 100 matches
 *   node scripts/i18n-apply-batch.cjs --report i18n-scan-report.json --batch 100
 *
 *   # Actually apply first 200 matches and create MT placeholders in other locales
 *   node scripts/i18n-apply-batch.cjs --report i18n-scan-report.json --batch 200 --apply --translate
 */

const fs = require("fs");
const path = require("path");
const os = require("os");
const util = require("util");

const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);
const mkdir = util.promisify(fs.mkdir);
const stat = util.promisify(fs.stat);

const ROOT = path.resolve(__dirname, "..");
const DEFAULT_REPORT = path.join(ROOT, "i18n-scan-report.json");
const EN_LOCALE = path.join(ROOT, "src", "i18n", "locales", "en.ts");
const LOCALES_DIR = path.join(ROOT, "src", "i18n", "locales");

function parseArgs() {
  const argv = process.argv.slice(2);
  const args = {};
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a.startsWith("--")) {
      const key = a.replace(/^--/, "");
      const val = argv[i + 1] && !argv[i + 1].startsWith("--") ? argv[++i] : "true";
      args[key] = val;
    }
  }
  return args;
}

function escapeForTsString(s) {
  // Use JSON.stringify to escape properly, then strip the surrounding quotes
  return JSON.stringify(String(s));
}

function ensureDirSync(dir) {
  try {
    fs.mkdirSync(dir, { recursive: true });
  } catch (e) {
    // ignore
  }
}

function safeWriteFileSync(filePath, content) {
  ensureDirSync(path.dirname(filePath));
  fs.writeFileSync(filePath, content, "utf8");
}

function regexEscape(str) {
  // Escape for use in a RegExp
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

/**
 * Conservative replacement heuristics:
 * - For text nodes: replace occurrences of `> <text> <` patterns with `>{t("key")}<`
 * - For plain occurrences inside tags: replace `>text<` or `> text <` (trimmed) only
 * - For string literals: replace "text" or 'text' occurrences with t("key") only if the literal matches exactly
 *
 * Returns number of replacements made.
 */
function applyReplacementToContent(content, candidate, key) {
  // candidate.raw may contain whitespace around; candidate.value is trimmed content
  const value = candidate.value;
  if (!value || value.length === 0) return 0;

  let replacedCount = 0;

  // 1) Try replace text node pattern: > ...value... <
  // Build regex that matches > optional whitespace, the exact trimmed value, optional whitespace, <
  const textNodePattern = new RegExp(`>\\s*${regexEscape(value)}\\s*<`, "g");
  const textNodeReplacement = `>{t("${key}")}<`;
  content = content.replace(textNodePattern, function (m) {
    replacedCount++;
    return textNodeReplacement;
  });

  // 2) Try replace text nodes that contain newline variations or HTML entities: search for raw trimmed occurrences between tags
  const raw = candidate.raw ? candidate.raw.trim() : value;
  if (raw && raw !== value) {
    const rawPattern = new RegExp(`>\\s*${regexEscape(raw)}\\s*<`, "g");
    content = content.replace(rawPattern, function (m) {
      replacedCount++;
      return textNodeReplacement;
    });
  }

  // 3) For exact quoted literal occurrences: "value" or 'value' -> replace with t("key")
  // Only replace when the quote content exactly equals the value (trimmed)
  const quotedDouble = new RegExp(`"${regexEscape(value)}"`, "g");
  content = content.replace(quotedDouble, function (m) {
    replacedCount++;
    return `t("${key}")`;
  });

  const quotedSingle = new RegExp(`'${regexEscape(value)}'`, "g");
  content = content.replace(quotedSingle, function (m) {
    replacedCount++;
    return `t("${key}")`;
  });

  // 4) Fallback: if value occurs as a standalone sequence (surrounded by whitespace or punctuation),
  // replace only first occurrence (to avoid accidental broad replacements)
  if (replacedCount === 0) {
    const fallbackPattern = new RegExp(`(^|[>\\s\\n\\r\\t,;:\\(\\[])${regexEscape(value)}($|[<\\s\\n\\r\\t,;:\\)\\]])`, "g");
    content = content.replace(fallbackPattern, function (m, p1, p2) {
      replacedCount++;
      return `${p1}{t("${key}")}${p2}`;
    });
  }

  return { content, replacedCount };
}

async function fileExists(p) {
  try {
    await stat(p);
    return true;
  } catch (e) {
    return false;
  }
}

async function loadReport(reportPath) {
  const p = path.resolve(reportPath || DEFAULT_REPORT);
  if (!(await fileExists(p))) {
    throw new Error(`Scan report not found at ${p}`);
  }
  const raw = await readFile(p, "utf8");
  return JSON.parse(raw);
}

async function loadLocaleFiles(localesDir) {
  const files = fs.readdirSync(localesDir).filter((f) => f.endsWith(".ts"));
  const locales = {};
  for (const f of files) {
    const full = path.join(localesDir, f);
    locales[f] = await readFile(full, "utf8");
  }
  return locales;
}

function addEntriesToEnTs(enContent, additions) {
  // additions: Array<{key, value}>
  // We'll attempt to insert before the final `};` that closes the export default object.
  const closingIndex = enContent.lastIndexOf("};");
  if (closingIndex === -1) {
    throw new Error("Could not find closing '};' in en.ts to insert new keys");
  }

  const before = enContent.slice(0, closingIndex);
  const after = enContent.slice(closingIndex);

  // Build insertion block with a comment marker
  const lines = [];
  lines.push("");
  lines.push("  // AUTO-GENERATED i18n keys - inserted by scripts/i18n-apply-batch.cjs");
  for (const a of additions) {
    const jsonStr = escapeForTsString(a.value);
    // Keep consistent formatting: "key": "value",
    lines.push(`  ${JSON.stringify(a.key)}: ${jsonStr},`);
  }
  lines.push("");

  const newContent = before + "\n" + lines.join("\n") + after;
  return newContent;
}

function addEntriesToOtherLocale(content, additions, localeName) {
  // Prepend AUTO-TRANSLATED marker comment and add keys before final `};`
  const closingIndex = content.lastIndexOf("};");
  if (closingIndex === -1) {
    throw new Error(`Could not find closing '};' in ${localeName}`);
  }
  const before = content.slice(0, closingIndex);
  const after = content.slice(closingIndex);

  const lines = [];
  lines.push("");
  lines.push("  // AUTO-TRANSLATED placeholders (MT:) - please REVIEW");
  for (const a of additions) {
    // Mark machine translations with MT: prefix to make them easy to find later
    const placeholder = `MT: ${a.value}`;
    const jsonStr = escapeForTsString(placeholder);
    lines.push(`  ${JSON.stringify(a.key)}: ${jsonStr},`);
  }
  lines.push("");

  return before + "\n" + lines.join("\n") + after;
}

async function main() {
  try {
    const args = parseArgs();
    const reportPath = args.report || DEFAULT_REPORT;
    const batch = parseInt(args.batch || "100", 10);
    const offset = parseInt(args.offset || "0", 10);
    const doApply = args.apply === "true" || args.apply === true || args.apply === "true";
    const doTranslate = args.translate === "true" || args.translate === true || args.translate === "true";
    const backupBase = args["backup-dir"] ? path.resolve(args["backup-dir"]) : path.join(ROOT, ".i18n-backups");
    const dryRun = !doApply;

    console.log("i18n-apply-batch starting");
    console.log(`report=${reportPath}`);
    console.log(`batch=${batch} offset=${offset} apply=${doApply} translate=${doTranslate} dryRun=${dryRun}`);
    console.log("");

    const report = await loadReport(reportPath);
    const total = report.results ? report.results.length : 0;
    if (total === 0) {
      console.log("No results found in report. Exiting.");
      return;
    }

    const slice = report.results.slice(offset, offset + batch);
    if (slice.length === 0) {
      console.log("No results in the requested slice. Nothing to do.");
      return;
    }

    console.log(`Processing ${slice.length} suggestions (results ${offset}..${offset + slice.length - 1})`);

    // Prepare additions for en.ts
    const additions = [];
    const replacementsByFile = {}; // file -> [{candidate, key, appliedCount}]

    for (const r of slice) {
      const key = r.suggestedKey || (() => {
        // fallback key generation
        const sanitized = r.value ? r.value.split(/\s+/).slice(0,4).join("_").toLowerCase().replace(/[^a-z0-9_]/g, "_") : "text";
        return `auto.${path.basename(r.file).replace(/\.[^.]+$/, "")}.${sanitized}`;
      })();
      additions.push({ key, value: r.value });

      if (!replacementsByFile[r.file]) replacementsByFile[r.file] = [];
      replacementsByFile[r.file].push({ candidate: r, key, applied: 0 });
    }

    // Load en.ts
    if (!(await fileExists(EN_LOCALE))) {
      throw new Error(`English locale file not found at ${EN_LOCALE}`);
    }
    const enContentRaw = await readFile(EN_LOCALE, "utf8");

    // Compute new en.ts content with additions that are not already present
    const existingKeys = new Set();
    // Try to parse existing keys by simple regex `"key":` scanning
    const keyRegex = /["']([\w\.\-:]+)["']\s*:/g;
    let m;
    while ((m = keyRegex.exec(enContentRaw))) {
      existingKeys.add(m[1]);
    }

    const toAddToEn = additions.filter((a) => !existingKeys.has(a.key));
    console.log(`English locale: ${toAddToEn.length} new keys to add (out of ${additions.length})`);

    // Prepare writing replacements for target source files
    const backups = [];
    const modifiedFiles = [];

    const backupDir = path.join(backupBase, String(Date.now()));
    if (doApply) {
      ensureDirSync(backupDir);
      console.log(`Backups will be written to ${backupDir}`);
    } else {
      console.log("DRY RUN: no files will be written. Use --apply to write changes.");
    }

    // Apply file replacements (conservative heuristics)
    for (const relFile of Object.keys(replacementsByFile)) {
      const absFile = path.join(ROOT, relFile);
      if (!(await fileExists(absFile))) {
        console.warn(`File not found: ${relFile} (skipping)`);
        continue;
      }
      const original = await readFile(absFile, "utf8");
      let modified = original;
      let totalReplacedInFile = 0;

      for (const repl of replacementsByFile[relFile]) {
        const { candidate, key } = repl;
        const result = applyReplacementToContent(modified, candidate, key);
        if (result && typeof result === "object") {
          modified = result.content;
          const count = result.replacedCount || 0;
          repl.applied = count;
          totalReplacedInFile += count;
        }
      }

      if (totalReplacedInFile > 0) {
        console.log(`Planned replacements in ${relFile}: ${totalReplacedInFile}`);
        if (doApply) {
          // write backup and modified file
          const backupPath = path.join(backupDir, relFile);
          ensureDirSync(path.dirname(backupPath));
          fs.writeFileSync(backupPath, original, "utf8");
          backups.push(backupPath);

          fs.writeFileSync(absFile, modified, "utf8");
          modifiedFiles.push(relFile);
        }
      } else {
        // nothing replaced
      }
    }

    // Insert new keys into en.ts if any
    if (toAddToEn.length > 0) {
      const newEnContent = addEntriesToEnTs(enContentRaw, toAddToEn);
      if (doApply) {
        // backup en.ts
        const enBackup = path.join(backupDir, path.relative(ROOT, EN_LOCALE));
        ensureDirSync(path.dirname(enBackup));
        fs.writeFileSync(enBackup, enContentRaw, "utf8");
        backups.push(enBackup);
        // write en.ts
        fs.writeFileSync(EN_LOCALE, newEnContent, "utf8");
        console.log(`Wrote ${toAddToEn.length} new keys to ${EN_LOCALE}`);
      } else {
        console.log(`DRY RUN: would add ${toAddToEn.length} keys to ${EN_LOCALE}`);
      }
    } else {
      console.log("No new keys to add to en.ts (all keys already exist).");
    }

    // Populate other locales with MT placeholders if requested
    if (doTranslate) {
      console.log("Populating other locales with AUTO-TRANSLATED placeholders (MT: prefix).");
      const localeFiles = fs.readdirSync(LOCALES_DIR).filter((f) => f.endsWith(".ts") && f !== "en.ts");
      for (const lf of localeFiles) {
        const full = path.join(LOCALES_DIR, lf);
        const rawContent = await readFile(full, "utf8");
        // Build additions that are not present
        const presentKeys = new Set();
        let mm;
        while ((mm = keyRegex.exec(rawContent))) {
          presentKeys.add(mm[1]);
        }
        const additionsForLocale = toAddToEn.filter((a) => !presentKeys.has(a.key));
        if (additionsForLocale.length === 0) {
          console.log(`Locale ${lf}: no additions needed`);
          continue;
        }
        const newLocaleContent = addEntriesToOtherLocale(rawContent, additionsForLocale, lf);
        if (doApply) {
          const backupPath = path.join(backupDir, path.relative(ROOT, full));
          ensureDirSync(path.dirname(backupPath));
          fs.writeFileSync(backupPath, rawContent, "utf8");
          backups.push(backupPath);
          fs.writeFileSync(full, newLocaleContent, "utf8");
          console.log(`Wrote ${additionsForLocale.length} placeholder keys to ${lf}`);
        } else {
          console.log(`DRY RUN: would add ${additionsForLocale.length} placeholder keys to ${lf}`);
        }
      }
    } else {
      console.log("Skipping automatic population of other locales (--translate not set).");
    }

    // Summary of replacements
    let totalPlannedReplacements = 0;
    for (const relFile of Object.keys(replacementsByFile)) {
      for (const r of replacementsByFile[relFile]) {
        totalPlannedReplacements += r.applied || 0;
      }
    }

    console.log("");
    console.log("Summary:");
    console.log(`  Suggestions processed: ${slice.length}`);
    console.log(`  New en.ts keys to add: ${toAddToEn.length}`);
    console.log(`  Files modified: ${modifiedFiles.length}`);
    console.log(`  Total replacements performed/planned: ${totalPlannedReplacements}`);
    console.log(`  Backups created: ${backups.length > 0 ? backupDir : "none (dry-run)"}`);

    if (!doApply) {
      console.log("");
      console.log("DRY RUN mode: No files were changed. Run the script again with --apply to write changes.");
      console.log("Example:");
      console.log("  node scripts/i18n-apply-batch.cjs --report i18n-scan-report.json --batch 100 --offset 0 --apply --translate");
    } else {
      console.log("");
      console.log("Apply complete. Please review the changes and run formatting/linting as required.");
      console.log(`Backups available under ${backupDir}`);
    }
  } catch (err) {
    console.error("ERROR:", err && err.message ? err.message : String(err));
    process.exit(1);
  }
}

main();
