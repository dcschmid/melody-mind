#!/usr/bin/env node
/**
 * Script: generate-i18n-template.ts
 *
 * Purpose:
 * - Scans all locale files under `src/i18n/locales` (by default) for translation keys.
 * - Builds a clean `template.ts` containing the union of all keys found.
 * - Where possible, preserves existing text values from an existing `template.ts`.
 *
 * Usage:
 *   ts-node melody-mind/scripts/generate-i18n-template.ts
 *   node ./dist/scripts/generate-i18n-template.js --localesDir src/i18n/locales --out src/i18n/locales/template.ts
 *
 * Options:
 *   --localesDir  Directory to scan for locale files (default: src/i18n/locales)
 *   --out         Output template file (default: src/i18n/locales/template.ts)
 *   --dry-run     Do not write file, only print summary
 *
 * Notes:
 * - This script does not execute or import TypeScript files. It parses file text to extract keys.
 * - It expects locale files to export a default object like `export default { "key": "value", ... }`.
 * - It supports string values in single-quotes, double-quotes or backticks (basic extraction).
 */

import fs from "fs/promises";
import path from "path";

type KeyMap = { [key: string]: string | undefined };

const DEFAULT_LOCALES_DIR = "src/i18n/locales";
const DEFAULT_OUT = path.join(DEFAULT_LOCALES_DIR, "template.ts");

function parseArgs() {
  const args = process.argv.slice(2);
  const opts: { [k: string]: string | boolean } = {};
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a.startsWith("--")) {
      const k = a.replace(/^--/, "");
      const next = args[i + 1];
      if (!next || next.startsWith("--")) {
        opts[k] = true;
      } else {
        opts[k] = next;
        i++;
      }
    }
  }
  return {
    localesDir: (opts["localesDir"] as string) || DEFAULT_LOCALES_DIR,
    out: (opts["out"] as string) || DEFAULT_OUT,
    dryRun: Boolean(opts["dry-run"] || opts["dryrun"] || opts["dry"]),
  };
}

/**
 * Recursively list .ts files in a directory
 */
async function listTsFiles(dir: string): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const results: string[] = [];
  for (const ent of entries) {
    const full = path.join(dir, ent.name);
    if (ent.isDirectory()) {
      results.push(...(await listTsFiles(full)));
    } else if (ent.isFile() && ent.name.endsWith(".ts")) {
      results.push(full);
    }
  }
  return results;
}

/**
 * Extract keys and values from a locale .ts file by parsing the `export default { ... }` object text.
 * Returns mapping key -> raw string value (unescaped, best-effort).
 */
function extractKeysFromFileText(content: string): KeyMap {
  const map: KeyMap = {};
  // Find the export default object content
  const m = /export\s+default\s*{([\s\S]*?)}\s*;?\s*$/.exec(content);
  const body = m ? m[1] : content; // fallback to full content if pattern missing

  // Regex to match keys and their values (double/single/backtick strings)
  const keyValueRegex =
    /["']([^"']+)["']\s*:\s*(`[\s\S]*?`|'(?:\\.|[^'\\])*'|"(?:\\.|[^"\\])*")\s*(?:,|$)/g;

  let match: RegExpExecArray | null;
  while ((match = keyValueRegex.exec(body))) {
    const key = match[1];
    const rawValue = match[2];

    // normalize rawValue by removing delimiters
    let value = rawValue;
    if (value.startsWith("`") && value.endsWith("`")) {
      value = value.slice(1, -1);
    } else if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
      // unescape simple sequences
      value = value.replace(/\\n/g, "\n").replace(/\\"/g, '"').replace(/\\'/g, "'");
      value = value.replace(/\\\\/g, "\\");
    }
    // Trim possible indentation artifacts
    value = value.replace(/\r/g, "");
    map[key] = value;
  }

  return map;
}

/**
 * Read and parse a ts file at `filePath`. Returns KeyMap.
 */
async function extractFromFile(filePath: string): Promise<KeyMap> {
  try {
    const content = await fs.readFile(filePath, "utf8");
    return extractKeysFromFileText(content);
  } catch (error) {
    console.error(`Failed to read ${filePath}:`, error);
    return {};
  }
}

/**
 * Escape a string so it is safe to include as a double-quoted TS string literal.
 * Preserves newlines.
 */
function escapeForTs(value: string): string {
  return JSON.stringify(value);
}

/**
 * Compose template file content from a map of keys -> values.
 */
function composeTemplateFile(keys: string[], valuesMap: KeyMap): string {
  const lines: string[] = [];
  lines.push("// THIS FILE IS AUTO-GENERATED BY melody-mind/scripts/generate-i18n-template.ts");
  lines.push(
    "// Keep translations in per-locale files. This template contains canonical keys and default texts."
  );
  lines.push("");
  lines.push("export default {");

  for (const k of keys) {
    const v = valuesMap[k];
    const outVal = typeof v === "string" ? escapeForTs(v) : '""';
    // Indent with two spaces as project style
    lines.push(`  "${k}": ${outVal},`);
  }

  lines.push("};");
  return lines.join("\n");
}

/**
 * Main
 */
(async function main() {
  const { localesDir, out, dryRun } = parseArgs();

  try {
    const localesDirFull = path.resolve(process.cwd(), localesDir);
    const outFull = path.resolve(process.cwd(), out);

    // Ensure locales dir exists
    try {
      await fs.access(localesDirFull);
    } catch {
      console.error(`Locales directory not found: ${localesDirFull}`);
      process.exit(1);
    }

    const tsFiles = await listTsFiles(localesDirFull);

    // We'll read all .ts files except .bak copies and except the output template file itself.
    const filtered = tsFiles.filter((f) => {
      const basename = path.basename(f);
      if (basename.endsWith(".ts.bak")) {return false;}
      if (path.resolve(f) === path.resolve(outFull)) {return false;}
      if (basename === "template.ts") {return false;} // don't treat template as a source of new keys (but we'll read it separately)
      return true;
    });

    // Extract keys from all files and merge
    const unionKeys = new Set<string>();
    const extractedPerFile: { [fn: string]: KeyMap } = {};
    for (const f of filtered) {
      const map = await extractFromFile(f);
      extractedPerFile[f] = map;
      for (const k of Object.keys(map)) {
        unionKeys.add(k);
      }
    }

    // Read existing template.ts if present and extract values to preserve them
    const existingTemplatePath = path.resolve(process.cwd(), localesDir, "template.ts");
    let existingTemplateValues: KeyMap = {};
    try {
      const content = await fs.readFile(existingTemplatePath, "utf8");
      existingTemplateValues = extractKeysFromFileText(content);
    } catch {
      // no existing template.ts â€” that's fine
    }

    // Build output map: prefer existing template values; otherwise empty string.
    const allKeysSorted = Array.from(unionKeys).sort((a, b) =>
      a.localeCompare(b, "en", { sensitivity: "base" })
    );

    const finalValues: KeyMap = {};
    for (const k of allKeysSorted) {
      if (existingTemplateValues[k] !== undefined) {
        finalValues[k] = existingTemplateValues[k];
      } else {
        // If any locale had a non-empty value for this key, optionally we could pick the first non-empty.
        // For safety, we'll set an empty value here to indicate translation is needed.
        finalValues[k] = "";
      }
    }

    const outContent = composeTemplateFile(allKeysSorted, finalValues);

    console.log("");
    console.log("i18n template generator summary");
    console.log("================================");
    console.log(`Locales directory: ${localesDirFull}`);
    console.log(`Files scanned: ${filtered.length}`);
    console.log(`Total unique keys found: ${allKeysSorted.length}`);
    console.log(`Output file: ${outFull}`);
    console.log(`Dry run: ${dryRun ? "yes" : "no"}`);
    console.log("");

    if (dryRun) {
      console.log("Dry-run mode: not writing file. Preview (first 2000 chars):");
      console.log("----------------------------------------------------------------");
      console.log(outContent.slice(0, 2000));
      console.log("----------------------------------------------------------------");
      process.exit(0);
    }

    // Write backup of existing template.ts if present
    try {
      await fs.access(outFull);
      const backupPath = `${outFull  }.bak`;
      await fs.copyFile(outFull, backupPath);
      console.log(`Existing template backed up to ${backupPath}`);
    } catch {
      // no existing file, continue
    }

    // Ensure output directory exists
    await fs.mkdir(path.dirname(outFull), { recursive: true });
    await fs.writeFile(outFull, outContent, "utf8");
    console.log(`Wrote template file to ${outFull}`);
  } catch (error) {
    console.error("An error occurred:", error);
    process.exit(1);
  }
})();
